/* automatically generated by rust-bindgen 0.70.1 */

pub const FLECS_VERSION_MAJOR: u32 = 4;
pub const FLECS_VERSION_MINOR: u32 = 0;
pub const FLECS_VERSION_PATCH: u32 = 1;
pub const FLECS_HI_COMPONENT_ID: u32 = 256;
pub const FLECS_HI_ID_RECORD_ID: u32 = 1024;
pub const FLECS_SPARSE_PAGE_BITS: u32 = 12;
pub const FLECS_ENTITY_PAGE_BITS: u32 = 12;
pub const FLECS_ID_DESC_MAX: u32 = 32;
pub const FLECS_EVENT_DESC_MAX: u32 = 8;
pub const FLECS_VARIABLE_COUNT_MAX: u32 = 64;
pub const FLECS_TERM_COUNT_MAX: u32 = 32;
pub const FLECS_TERM_ARG_COUNT_MAX: u32 = 16;
pub const FLECS_QUERY_VARIABLE_COUNT_MAX: u32 = 64;
pub const FLECS_QUERY_SCOPE_NESTING_MAX: u32 = 8;
pub const EcsWorldQuitWorkers: u32 = 1;
pub const EcsWorldReadonly: u32 = 2;
pub const EcsWorldInit: u32 = 4;
pub const EcsWorldQuit: u32 = 8;
pub const EcsWorldFini: u32 = 16;
pub const EcsWorldMeasureFrameTime: u32 = 32;
pub const EcsWorldMeasureSystemTime: u32 = 64;
pub const EcsWorldMultiThreaded: u32 = 128;
pub const EcsOsApiHighResolutionTimer: u32 = 1;
pub const EcsOsApiLogWithColors: u32 = 2;
pub const EcsOsApiLogWithTimeStamp: u32 = 4;
pub const EcsOsApiLogWithTimeDelta: u32 = 8;
pub const EcsEntityIsId: u32 = 2147483648;
pub const EcsEntityIsTarget: u32 = 1073741824;
pub const EcsEntityIsTraversable: u32 = 536870912;
pub const EcsIdOnDeleteRemove: u32 = 1;
pub const EcsIdOnDeleteDelete: u32 = 2;
pub const EcsIdOnDeletePanic: u32 = 4;
pub const EcsIdOnDeleteMask: u32 = 7;
pub const EcsIdOnDeleteObjectRemove: u32 = 8;
pub const EcsIdOnDeleteObjectDelete: u32 = 16;
pub const EcsIdOnDeleteObjectPanic: u32 = 32;
pub const EcsIdOnDeleteObjectMask: u32 = 56;
pub const EcsIdOnInstantiateOverride: u32 = 64;
pub const EcsIdOnInstantiateInherit: u32 = 128;
pub const EcsIdOnInstantiateDontInherit: u32 = 256;
pub const EcsIdOnInstantiateMask: u32 = 448;
pub const EcsIdExclusive: u32 = 512;
pub const EcsIdTraversable: u32 = 1024;
pub const EcsIdTag: u32 = 2048;
pub const EcsIdWith: u32 = 4096;
pub const EcsIdCanToggle: u32 = 8192;
pub const EcsIdIsTransitive: u32 = 16384;
pub const EcsIdHasOnAdd: u32 = 65536;
pub const EcsIdHasOnRemove: u32 = 131072;
pub const EcsIdHasOnSet: u32 = 262144;
pub const EcsIdHasOnTableFill: u32 = 1048576;
pub const EcsIdHasOnTableEmpty: u32 = 2097152;
pub const EcsIdHasOnTableCreate: u32 = 4194304;
pub const EcsIdHasOnTableDelete: u32 = 8388608;
pub const EcsIdIsSparse: u32 = 16777216;
pub const EcsIdIsUnion: u32 = 33554432;
pub const EcsIdEventMask: u32 = 66519040;
pub const EcsIdMarkedForDelete: u32 = 1073741824;
pub const EcsIterIsValid: u32 = 1;
pub const EcsIterNoData: u32 = 2;
pub const EcsIterNoResults: u32 = 8;
pub const EcsIterIgnoreThis: u32 = 16;
pub const EcsIterHasCondSet: u32 = 64;
pub const EcsIterProfile: u32 = 128;
pub const EcsIterTrivialSearch: u32 = 256;
pub const EcsIterTrivialTest: u32 = 2048;
pub const EcsIterTrivialCached: u32 = 16384;
pub const EcsIterCacheSearch: u32 = 32768;
pub const EcsIterFixedInChangeComputed: u32 = 65536;
pub const EcsIterFixedInChanged: u32 = 131072;
pub const EcsIterSkip: u32 = 262144;
pub const EcsIterCppEach: u32 = 524288;
pub const EcsIterTableOnly: u32 = 1048576;
pub const EcsEventTableOnly: u32 = 1048576;
pub const EcsEventNoOnSet: u32 = 65536;
pub const EcsQueryMatchThis: u32 = 2048;
pub const EcsQueryMatchOnlyThis: u32 = 4096;
pub const EcsQueryMatchOnlySelf: u32 = 8192;
pub const EcsQueryMatchWildcards: u32 = 16384;
pub const EcsQueryHasCondSet: u32 = 32768;
pub const EcsQueryHasPred: u32 = 65536;
pub const EcsQueryHasScopes: u32 = 131072;
pub const EcsQueryHasRefs: u32 = 262144;
pub const EcsQueryHasOutTerms: u32 = 524288;
pub const EcsQueryHasNonThisOutTerms: u32 = 1048576;
pub const EcsQueryHasMonitor: u32 = 2097152;
pub const EcsQueryIsTrivial: u32 = 4194304;
pub const EcsQueryHasCacheable: u32 = 8388608;
pub const EcsQueryIsCacheable: u32 = 16777216;
pub const EcsQueryHasTableThisVar: u32 = 33554432;
pub const EcsQueryCacheYieldEmptyTables: u32 = 134217728;
pub const EcsTermMatchAny: u32 = 1;
pub const EcsTermMatchAnySrc: u32 = 2;
pub const EcsTermTransitive: u32 = 4;
pub const EcsTermReflexive: u32 = 8;
pub const EcsTermIdInherited: u32 = 16;
pub const EcsTermIsTrivial: u32 = 32;
pub const EcsTermIsCacheable: u32 = 128;
pub const EcsTermIsScope: u32 = 256;
pub const EcsTermIsMember: u32 = 512;
pub const EcsTermIsToggle: u32 = 1024;
pub const EcsTermKeepAlive: u32 = 2048;
pub const EcsTermIsSparse: u32 = 4096;
pub const EcsTermIsUnion: u32 = 8192;
pub const EcsTermIsOr: u32 = 16384;
pub const EcsObserverIsMulti: u32 = 2;
pub const EcsObserverIsMonitor: u32 = 4;
pub const EcsObserverIsDisabled: u32 = 8;
pub const EcsObserverIsParentDisabled: u32 = 16;
pub const EcsObserverBypassQuery: u32 = 32;
pub const EcsTableHasBuiltins: u32 = 2;
pub const EcsTableIsPrefab: u32 = 4;
pub const EcsTableHasIsA: u32 = 8;
pub const EcsTableHasChildOf: u32 = 16;
pub const EcsTableHasName: u32 = 32;
pub const EcsTableHasPairs: u32 = 64;
pub const EcsTableHasModule: u32 = 128;
pub const EcsTableIsDisabled: u32 = 256;
pub const EcsTableNotQueryable: u32 = 512;
pub const EcsTableHasCtors: u32 = 1024;
pub const EcsTableHasDtors: u32 = 2048;
pub const EcsTableHasCopy: u32 = 4096;
pub const EcsTableHasMove: u32 = 8192;
pub const EcsTableHasToggle: u32 = 16384;
pub const EcsTableHasOverrides: u32 = 32768;
pub const EcsTableHasOnAdd: u32 = 65536;
pub const EcsTableHasOnRemove: u32 = 131072;
pub const EcsTableHasOnSet: u32 = 262144;
pub const EcsTableHasOnTableFill: u32 = 1048576;
pub const EcsTableHasOnTableEmpty: u32 = 2097152;
pub const EcsTableHasOnTableCreate: u32 = 4194304;
pub const EcsTableHasOnTableDelete: u32 = 8388608;
pub const EcsTableHasSparse: u32 = 16777216;
pub const EcsTableHasUnion: u32 = 33554432;
pub const EcsTableHasTraversable: u32 = 67108864;
pub const EcsTableMarkedForDelete: u32 = 1073741824;
pub const EcsTableHasLifecycle: u32 = 3072;
pub const EcsTableIsComplex: u32 = 16796672;
pub const EcsTableHasAddActions: u32 = 328712;
pub const EcsTableHasRemoveActions: u32 = 133128;
pub const EcsAperiodicEmptyTables: u32 = 2;
pub const EcsAperiodicComponentMonitors: u32 = 4;
pub const EcsAperiodicEmptyQueries: u32 = 16;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const ecs_world_t_magic: u32 = 1701016439;
pub const ecs_stage_t_magic: u32 = 1701016435;
pub const ecs_query_t_magic: u32 = 1701016437;
pub const ecs_observer_t_magic: u32 = 1701016418;
pub const ECS_ROW_MASK: u32 = 268435455;
pub const ECS_ROW_FLAGS_MASK: i32 = -268435456;
pub const ECS_ID_FLAGS_MASK: i64 = -1152921504606846976;
pub const ECS_ENTITY_MASK: u32 = 4294967295;
pub const ECS_GENERATION_MASK: u64 = 281470681743360;
pub const ECS_COMPONENT_MASK: u64 = 1152921504606846975;
pub const EcsIterNextYield: u32 = 0;
pub const EcsIterYield: i32 = -1;
pub const EcsIterNext: u32 = 1;
pub const FLECS_SPARSE_PAGE_SIZE: u32 = 4096;
pub const ECS_STACK_PAGE_SIZE: u32 = 4096;
pub const ECS_STRBUF_SMALL_STRING_SIZE: u32 = 512;
pub const ECS_STRBUF_MAX_LIST_DEPTH: u32 = 32;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const EcsSelf: i64 = -9223372036854775808;
pub const EcsUp: u64 = 4611686018427387904;
pub const EcsTrav: u64 = 2305843009213693952;
pub const EcsCascade: u64 = 1152921504606846976;
pub const EcsDesc: u64 = 576460752303423488;
pub const EcsIsVariable: u64 = 288230376151711744;
pub const EcsIsEntity: u64 = 144115188075855872;
pub const EcsIsName: u64 = 72057594037927936;
pub const EcsTraverseFlags: i64 = -576460752303423488;
pub const EcsTermRefFlags: i64 = -72057594037927936;
pub const flecs_iter_cache_ids: u32 = 1;
pub const flecs_iter_cache_trs: u32 = 2;
pub const flecs_iter_cache_sources: u32 = 4;
pub const flecs_iter_cache_ptrs: u32 = 8;
pub const flecs_iter_cache_variables: u32 = 16;
pub const flecs_iter_cache_all: u32 = 255;
pub const ECS_MAX_RECURSION: u32 = 512;
pub const ECS_MAX_TOKEN_SIZE: u32 = 256;
pub const EcsQueryMatchPrefab: u32 = 2;
pub const EcsQueryMatchDisabled: u32 = 4;
pub const EcsQueryMatchEmptyTables: u32 = 8;
pub const EcsQueryAllowUnresolvedByName: u32 = 64;
pub const EcsQueryTableOnly: u32 = 128;
pub const EcsFirstUserComponentId: u32 = 8;
pub const EcsFirstUserEntityId: u32 = 384;
pub const FLECS_JOURNAL_LOG_LEVEL: u32 = 0;
pub const ECS_INVALID_OPERATION: u32 = 1;
pub const ECS_INVALID_PARAMETER: u32 = 2;
pub const ECS_CONSTRAINT_VIOLATED: u32 = 3;
pub const ECS_OUT_OF_MEMORY: u32 = 4;
pub const ECS_OUT_OF_RANGE: u32 = 5;
pub const ECS_UNSUPPORTED: u32 = 6;
pub const ECS_INTERNAL_ERROR: u32 = 7;
pub const ECS_ALREADY_DEFINED: u32 = 8;
pub const ECS_MISSING_OS_API: u32 = 9;
pub const ECS_OPERATION_FAILED: u32 = 10;
pub const ECS_INVALID_CONVERSION: u32 = 11;
pub const ECS_ID_IN_USE: u32 = 12;
pub const ECS_CYCLE_DETECTED: u32 = 13;
pub const ECS_LEAK_DETECTED: u32 = 14;
pub const ECS_DOUBLE_FREE: u32 = 15;
pub const ECS_INCONSISTENT_NAME: u32 = 20;
pub const ECS_NAME_IN_USE: u32 = 21;
pub const ECS_NOT_A_COMPONENT: u32 = 22;
pub const ECS_INVALID_COMPONENT_SIZE: u32 = 23;
pub const ECS_INVALID_COMPONENT_ALIGNMENT: u32 = 24;
pub const ECS_COMPONENT_NOT_REGISTERED: u32 = 25;
pub const ECS_INCONSISTENT_COMPONENT_ID: u32 = 26;
pub const ECS_INCONSISTENT_COMPONENT_ACTION: u32 = 27;
pub const ECS_MODULE_UNDEFINED: u32 = 28;
pub const ECS_MISSING_SYMBOL: u32 = 29;
pub const ECS_ALREADY_IN_USE: u32 = 30;
pub const ECS_ACCESS_VIOLATION: u32 = 40;
pub const ECS_COLUMN_INDEX_OUT_OF_RANGE: u32 = 41;
pub const ECS_COLUMN_IS_NOT_SHARED: u32 = 42;
pub const ECS_COLUMN_IS_SHARED: u32 = 43;
pub const ECS_COLUMN_TYPE_MISMATCH: u32 = 45;
pub const ECS_INVALID_WHILE_READONLY: u32 = 70;
pub const ECS_LOCKED_STORAGE: u32 = 71;
pub const ECS_INVALID_FROM_WORKER: u32 = 72;
pub const ECS_BLACK: &[u8; 8] = b"\x1B[1;30m\0";
pub const ECS_RED: &[u8; 8] = b"\x1B[0;31m\0";
pub const ECS_GREEN: &[u8; 8] = b"\x1B[0;32m\0";
pub const ECS_YELLOW: &[u8; 8] = b"\x1B[0;33m\0";
pub const ECS_BLUE: &[u8; 8] = b"\x1B[0;34m\0";
pub const ECS_MAGENTA: &[u8; 8] = b"\x1B[0;35m\0";
pub const ECS_CYAN: &[u8; 8] = b"\x1B[0;36m\0";
pub const ECS_WHITE: &[u8; 8] = b"\x1B[1;37m\0";
pub const ECS_GREY: &[u8; 8] = b"\x1B[0;37m\0";
pub const ECS_NORMAL: &[u8; 8] = b"\x1B[0;49m\0";
pub const ECS_BOLD: &[u8; 8] = b"\x1B[1;49m\0";
pub const ECS_HTTP_HEADER_COUNT_MAX: u32 = 32;
pub const ECS_HTTP_QUERY_PARAM_COUNT_MAX: u32 = 32;
pub const ECS_REST_DEFAULT_PORT: u32 = 27750;
pub const ECS_STAT_WINDOW: u32 = 60;
pub const ECS_ALERT_MAX_SEVERITY_FILTERS: u32 = 4;
pub const ECS_MEMBER_DESC_CACHE_SIZE: u32 = 32;
pub const ECS_META_MAX_SCOPE_DEPTH: u32 = 32;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __crt_locale_data_public"]
        [::std::mem::size_of::<__crt_locale_data_public>() - 16usize];
    ["Alignment of __crt_locale_data_public"]
        [::std::mem::align_of::<__crt_locale_data_public>() - 8usize];
    ["Offset of field: __crt_locale_data_public::_locale_pctype"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_pctype) - 0usize];
    ["Offset of field: __crt_locale_data_public::_locale_mb_cur_max"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_mb_cur_max) - 8usize];
    ["Offset of field: __crt_locale_data_public::_locale_lc_codepage"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_lc_codepage) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __crt_locale_pointers"][::std::mem::size_of::<__crt_locale_pointers>() - 16usize];
    ["Alignment of __crt_locale_pointers"]
        [::std::mem::align_of::<__crt_locale_pointers>() - 8usize];
    ["Offset of field: __crt_locale_pointers::locinfo"]
        [::std::mem::offset_of!(__crt_locale_pointers, locinfo) - 0usize];
    ["Offset of field: __crt_locale_pointers::mbcinfo"]
        [::std::mem::offset_of!(__crt_locale_pointers, mbcinfo) - 8usize];
};
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Mbstatet"][::std::mem::size_of::<_Mbstatet>() - 8usize];
    ["Alignment of _Mbstatet"][::std::mem::align_of::<_Mbstatet>() - 4usize];
    ["Offset of field: _Mbstatet::_Wchar"][::std::mem::offset_of!(_Mbstatet, _Wchar) - 0usize];
    ["Offset of field: _Mbstatet::_Byte"][::std::mem::offset_of!(_Mbstatet, _Byte) - 4usize];
    ["Offset of field: _Mbstatet::_State"][::std::mem::offset_of!(_Mbstatet, _State) - 6usize];
};
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _wassert(_Message: *const wchar_t, _File: *const wchar_t, _Line: ::std::os::raw::c_uint);
}
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type ecs_flags8_t = u8;
pub type ecs_flags16_t = u16;
pub type ecs_flags32_t = u32;
pub type ecs_flags64_t = u64;
pub type ecs_size_t = i32;
#[doc = " A component column."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_vec_t {
    pub array: *mut ::std::os::raw::c_void,
    pub count: i32,
    pub size: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_vec_t"][::std::mem::size_of::<ecs_vec_t>() - 16usize];
    ["Alignment of ecs_vec_t"][::std::mem::align_of::<ecs_vec_t>() - 8usize];
    ["Offset of field: ecs_vec_t::array"][::std::mem::offset_of!(ecs_vec_t, array) - 0usize];
    ["Offset of field: ecs_vec_t::count"][::std::mem::offset_of!(ecs_vec_t, count) - 8usize];
    ["Offset of field: ecs_vec_t::size"][::std::mem::offset_of!(ecs_vec_t, size) - 12usize];
};
extern "C" {
    pub fn ecs_vec_init(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_init_if(vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_fini(allocator: *mut ecs_allocator_t, vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_reset(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
    ) -> *mut ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_clear(vec: *mut ecs_vec_t);
}
extern "C" {
    pub fn ecs_vec_append(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_remove(vec: *mut ecs_vec_t, size: ecs_size_t, elem: i32);
}
extern "C" {
    pub fn ecs_vec_remove_last(vec: *mut ecs_vec_t);
}
extern "C" {
    pub fn ecs_vec_copy(
        allocator: *mut ecs_allocator_t,
        vec: *const ecs_vec_t,
        size: ecs_size_t,
    ) -> ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_copy_shrink(
        allocator: *mut ecs_allocator_t,
        vec: *const ecs_vec_t,
        size: ecs_size_t,
    ) -> ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_reclaim(allocator: *mut ecs_allocator_t, vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_set_size(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_size(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_count(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_count_zeromem(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_count(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_grow(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_count(vec: *const ecs_vec_t) -> i32;
}
extern "C" {
    pub fn ecs_vec_size(vec: *const ecs_vec_t) -> i32;
}
extern "C" {
    pub fn ecs_vec_get(
        vec: *const ecs_vec_t,
        size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_first(vec: *const ecs_vec_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_last(vec: *const ecs_vec_t, size: ecs_size_t) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_sparse_t {
    pub dense: ecs_vec_t,
    pub pages: ecs_vec_t,
    pub size: ecs_size_t,
    pub count: i32,
    pub max_id: u64,
    pub allocator: *mut ecs_allocator_t,
    pub page_allocator: *mut ecs_block_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_sparse_t"][::std::mem::size_of::<ecs_sparse_t>() - 64usize];
    ["Alignment of ecs_sparse_t"][::std::mem::align_of::<ecs_sparse_t>() - 8usize];
    ["Offset of field: ecs_sparse_t::dense"][::std::mem::offset_of!(ecs_sparse_t, dense) - 0usize];
    ["Offset of field: ecs_sparse_t::pages"][::std::mem::offset_of!(ecs_sparse_t, pages) - 16usize];
    ["Offset of field: ecs_sparse_t::size"][::std::mem::offset_of!(ecs_sparse_t, size) - 32usize];
    ["Offset of field: ecs_sparse_t::count"][::std::mem::offset_of!(ecs_sparse_t, count) - 36usize];
    ["Offset of field: ecs_sparse_t::max_id"]
        [::std::mem::offset_of!(ecs_sparse_t, max_id) - 40usize];
    ["Offset of field: ecs_sparse_t::allocator"]
        [::std::mem::offset_of!(ecs_sparse_t, allocator) - 48usize];
    ["Offset of field: ecs_sparse_t::page_allocator"]
        [::std::mem::offset_of!(ecs_sparse_t, page_allocator) - 56usize];
};
extern "C" {
    #[doc = " Initialize sparse set"]
    pub fn flecs_sparse_init(
        result: *mut ecs_sparse_t,
        allocator: *mut ecs_allocator_t,
        page_allocator: *mut ecs_block_allocator_t,
        size: ecs_size_t,
    );
}
extern "C" {
    pub fn flecs_sparse_fini(sparse: *mut ecs_sparse_t);
}
extern "C" {
    #[doc = " Remove all elements from sparse set"]
    pub fn flecs_sparse_clear(sparse: *mut ecs_sparse_t);
}
extern "C" {
    #[doc = " Add element to sparse set, this generates or recycles an id"]
    pub fn flecs_sparse_add(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get last issued id."]
    pub fn flecs_sparse_last_id(sparse: *const ecs_sparse_t) -> u64;
}
extern "C" {
    #[doc = " Generate or recycle a new id."]
    pub fn flecs_sparse_new_id(sparse: *mut ecs_sparse_t) -> u64;
}
extern "C" {
    #[doc = " Remove an element"]
    pub fn flecs_sparse_remove(sparse: *mut ecs_sparse_t, elem_size: ecs_size_t, id: u64);
}
extern "C" {
    #[doc = " Remove an element without liveliness checking"]
    pub fn flecs_sparse_remove_fast(
        sparse: *mut ecs_sparse_t,
        size: ecs_size_t,
        index: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Test if id is alive, which requires the generation count to match."]
    pub fn flecs_sparse_is_alive(sparse: *const ecs_sparse_t, id: u64) -> bool;
}
extern "C" {
    #[doc = " Get value from sparse set by dense id. This function is useful in\n combination with flecs_sparse_count for iterating all values in the set."]
    pub fn flecs_sparse_get_dense(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the number of alive elements in the sparse set."]
    pub fn flecs_sparse_count(sparse: *const ecs_sparse_t) -> i32;
}
extern "C" {
    #[doc = " Get element by (sparse) id. The returned pointer is stable for the duration\n of the sparse set, as it is stored in the sparse array."]
    pub fn flecs_sparse_get(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Same as flecs_sparse_get, but doesn't assert if id is not alive."]
    pub fn flecs_sparse_try(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Like get_sparse, but don't care whether element is alive or not."]
    pub fn flecs_sparse_get_any(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get or create element by (sparse) id."]
    pub fn flecs_sparse_ensure(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Fast version of ensure, no liveliness checking"]
    pub fn flecs_sparse_ensure_fast(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get pointer to ids (alive and not alive). Use with count() or size()."]
    pub fn flecs_sparse_ids(sparse: *const ecs_sparse_t) -> *const u64;
}
extern "C" {
    pub fn ecs_sparse_init(sparse: *mut ecs_sparse_t, elem_size: ecs_size_t);
}
extern "C" {
    pub fn ecs_sparse_add(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_sparse_last_id(sparse: *const ecs_sparse_t) -> u64;
}
extern "C" {
    pub fn ecs_sparse_count(sparse: *const ecs_sparse_t) -> i32;
}
extern "C" {
    pub fn ecs_sparse_get_dense(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_sparse_get(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_block_t {
    pub memory: *mut ::std::os::raw::c_void,
    pub next: *mut ecs_block_allocator_block_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_block_allocator_block_t"]
        [::std::mem::size_of::<ecs_block_allocator_block_t>() - 16usize];
    ["Alignment of ecs_block_allocator_block_t"]
        [::std::mem::align_of::<ecs_block_allocator_block_t>() - 8usize];
    ["Offset of field: ecs_block_allocator_block_t::memory"]
        [::std::mem::offset_of!(ecs_block_allocator_block_t, memory) - 0usize];
    ["Offset of field: ecs_block_allocator_block_t::next"]
        [::std::mem::offset_of!(ecs_block_allocator_block_t, next) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_chunk_header_t {
    pub next: *mut ecs_block_allocator_chunk_header_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_block_allocator_chunk_header_t"]
        [::std::mem::size_of::<ecs_block_allocator_chunk_header_t>() - 8usize];
    ["Alignment of ecs_block_allocator_chunk_header_t"]
        [::std::mem::align_of::<ecs_block_allocator_chunk_header_t>() - 8usize];
    ["Offset of field: ecs_block_allocator_chunk_header_t::next"]
        [::std::mem::offset_of!(ecs_block_allocator_chunk_header_t, next) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_t {
    pub head: *mut ecs_block_allocator_chunk_header_t,
    pub block_head: *mut ecs_block_allocator_block_t,
    pub block_tail: *mut ecs_block_allocator_block_t,
    pub chunk_size: i32,
    pub data_size: i32,
    pub chunks_per_block: i32,
    pub block_size: i32,
    pub alloc_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_block_allocator_t"][::std::mem::size_of::<ecs_block_allocator_t>() - 48usize];
    ["Alignment of ecs_block_allocator_t"]
        [::std::mem::align_of::<ecs_block_allocator_t>() - 8usize];
    ["Offset of field: ecs_block_allocator_t::head"]
        [::std::mem::offset_of!(ecs_block_allocator_t, head) - 0usize];
    ["Offset of field: ecs_block_allocator_t::block_head"]
        [::std::mem::offset_of!(ecs_block_allocator_t, block_head) - 8usize];
    ["Offset of field: ecs_block_allocator_t::block_tail"]
        [::std::mem::offset_of!(ecs_block_allocator_t, block_tail) - 16usize];
    ["Offset of field: ecs_block_allocator_t::chunk_size"]
        [::std::mem::offset_of!(ecs_block_allocator_t, chunk_size) - 24usize];
    ["Offset of field: ecs_block_allocator_t::data_size"]
        [::std::mem::offset_of!(ecs_block_allocator_t, data_size) - 28usize];
    ["Offset of field: ecs_block_allocator_t::chunks_per_block"]
        [::std::mem::offset_of!(ecs_block_allocator_t, chunks_per_block) - 32usize];
    ["Offset of field: ecs_block_allocator_t::block_size"]
        [::std::mem::offset_of!(ecs_block_allocator_t, block_size) - 36usize];
    ["Offset of field: ecs_block_allocator_t::alloc_count"]
        [::std::mem::offset_of!(ecs_block_allocator_t, alloc_count) - 40usize];
};
extern "C" {
    pub fn flecs_ballocator_init(ba: *mut ecs_block_allocator_t, size: ecs_size_t);
}
extern "C" {
    pub fn flecs_ballocator_new(size: ecs_size_t) -> *mut ecs_block_allocator_t;
}
extern "C" {
    pub fn flecs_ballocator_fini(ba: *mut ecs_block_allocator_t);
}
extern "C" {
    pub fn flecs_ballocator_free(ba: *mut ecs_block_allocator_t);
}
extern "C" {
    pub fn flecs_balloc(allocator: *mut ecs_block_allocator_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bcalloc(allocator: *mut ecs_block_allocator_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bfree(allocator: *mut ecs_block_allocator_t, memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn flecs_bfree_w_dbg_info(
        allocator: *mut ecs_block_allocator_t,
        memory: *mut ::std::os::raw::c_void,
        type_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn flecs_brealloc(
        dst: *mut ecs_block_allocator_t,
        src: *mut ecs_block_allocator_t,
        memory: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bdup(
        ba: *mut ecs_block_allocator_t,
        memory: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stack_page_t {
    pub data: *mut ::std::os::raw::c_void,
    pub next: *mut ecs_stack_page_t,
    pub sp: i16,
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_stack_page_t"][::std::mem::size_of::<ecs_stack_page_t>() - 24usize];
    ["Alignment of ecs_stack_page_t"][::std::mem::align_of::<ecs_stack_page_t>() - 8usize];
    ["Offset of field: ecs_stack_page_t::data"]
        [::std::mem::offset_of!(ecs_stack_page_t, data) - 0usize];
    ["Offset of field: ecs_stack_page_t::next"]
        [::std::mem::offset_of!(ecs_stack_page_t, next) - 8usize];
    ["Offset of field: ecs_stack_page_t::sp"]
        [::std::mem::offset_of!(ecs_stack_page_t, sp) - 16usize];
    ["Offset of field: ecs_stack_page_t::id"]
        [::std::mem::offset_of!(ecs_stack_page_t, id) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stack_cursor_t {
    pub prev: *mut ecs_stack_cursor_t,
    pub page: *mut ecs_stack_page_t,
    pub sp: i16,
    pub is_free: bool,
    pub owner: *mut ecs_stack_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_stack_cursor_t"][::std::mem::size_of::<ecs_stack_cursor_t>() - 32usize];
    ["Alignment of ecs_stack_cursor_t"][::std::mem::align_of::<ecs_stack_cursor_t>() - 8usize];
    ["Offset of field: ecs_stack_cursor_t::prev"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, prev) - 0usize];
    ["Offset of field: ecs_stack_cursor_t::page"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, page) - 8usize];
    ["Offset of field: ecs_stack_cursor_t::sp"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, sp) - 16usize];
    ["Offset of field: ecs_stack_cursor_t::is_free"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, is_free) - 18usize];
    ["Offset of field: ecs_stack_cursor_t::owner"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, owner) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stack_t {
    pub first: ecs_stack_page_t,
    pub tail_page: *mut ecs_stack_page_t,
    pub tail_cursor: *mut ecs_stack_cursor_t,
    pub cursor_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_stack_t"][::std::mem::size_of::<ecs_stack_t>() - 48usize];
    ["Alignment of ecs_stack_t"][::std::mem::align_of::<ecs_stack_t>() - 8usize];
    ["Offset of field: ecs_stack_t::first"][::std::mem::offset_of!(ecs_stack_t, first) - 0usize];
    ["Offset of field: ecs_stack_t::tail_page"]
        [::std::mem::offset_of!(ecs_stack_t, tail_page) - 24usize];
    ["Offset of field: ecs_stack_t::tail_cursor"]
        [::std::mem::offset_of!(ecs_stack_t, tail_cursor) - 32usize];
    ["Offset of field: ecs_stack_t::cursor_count"]
        [::std::mem::offset_of!(ecs_stack_t, cursor_count) - 40usize];
};
extern "C" {
    pub fn flecs_stack_init(stack: *mut ecs_stack_t);
}
extern "C" {
    pub fn flecs_stack_fini(stack: *mut ecs_stack_t);
}
extern "C" {
    pub fn flecs_stack_alloc(
        stack: *mut ecs_stack_t,
        size: ecs_size_t,
        align: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_stack_calloc(
        stack: *mut ecs_stack_t,
        size: ecs_size_t,
        align: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_stack_free(ptr: *mut ::std::os::raw::c_void, size: ecs_size_t);
}
extern "C" {
    pub fn flecs_stack_reset(stack: *mut ecs_stack_t);
}
extern "C" {
    pub fn flecs_stack_get_cursor(stack: *mut ecs_stack_t) -> *mut ecs_stack_cursor_t;
}
extern "C" {
    pub fn flecs_stack_restore_cursor(stack: *mut ecs_stack_t, cursor: *mut ecs_stack_cursor_t);
}
pub type ecs_map_data_t = u64;
pub type ecs_map_key_t = ecs_map_data_t;
pub type ecs_map_val_t = ecs_map_data_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bucket_entry_t {
    pub key: ecs_map_key_t,
    pub value: ecs_map_val_t,
    pub next: *mut ecs_bucket_entry_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_bucket_entry_t"][::std::mem::size_of::<ecs_bucket_entry_t>() - 24usize];
    ["Alignment of ecs_bucket_entry_t"][::std::mem::align_of::<ecs_bucket_entry_t>() - 8usize];
    ["Offset of field: ecs_bucket_entry_t::key"]
        [::std::mem::offset_of!(ecs_bucket_entry_t, key) - 0usize];
    ["Offset of field: ecs_bucket_entry_t::value"]
        [::std::mem::offset_of!(ecs_bucket_entry_t, value) - 8usize];
    ["Offset of field: ecs_bucket_entry_t::next"]
        [::std::mem::offset_of!(ecs_bucket_entry_t, next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bucket_t {
    pub first: *mut ecs_bucket_entry_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_bucket_t"][::std::mem::size_of::<ecs_bucket_t>() - 8usize];
    ["Alignment of ecs_bucket_t"][::std::mem::align_of::<ecs_bucket_t>() - 8usize];
    ["Offset of field: ecs_bucket_t::first"][::std::mem::offset_of!(ecs_bucket_t, first) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_t {
    pub bucket_shift: u8,
    pub shared_allocator: bool,
    pub buckets: *mut ecs_bucket_t,
    pub bucket_count: i32,
    pub count: i32,
    pub entry_allocator: *mut ecs_block_allocator_t,
    pub allocator: *mut ecs_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_map_t"][::std::mem::size_of::<ecs_map_t>() - 40usize];
    ["Alignment of ecs_map_t"][::std::mem::align_of::<ecs_map_t>() - 8usize];
    ["Offset of field: ecs_map_t::bucket_shift"]
        [::std::mem::offset_of!(ecs_map_t, bucket_shift) - 0usize];
    ["Offset of field: ecs_map_t::shared_allocator"]
        [::std::mem::offset_of!(ecs_map_t, shared_allocator) - 1usize];
    ["Offset of field: ecs_map_t::buckets"][::std::mem::offset_of!(ecs_map_t, buckets) - 8usize];
    ["Offset of field: ecs_map_t::bucket_count"]
        [::std::mem::offset_of!(ecs_map_t, bucket_count) - 16usize];
    ["Offset of field: ecs_map_t::count"][::std::mem::offset_of!(ecs_map_t, count) - 20usize];
    ["Offset of field: ecs_map_t::entry_allocator"]
        [::std::mem::offset_of!(ecs_map_t, entry_allocator) - 24usize];
    ["Offset of field: ecs_map_t::allocator"]
        [::std::mem::offset_of!(ecs_map_t, allocator) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_iter_t {
    pub map: *const ecs_map_t,
    pub bucket: *mut ecs_bucket_t,
    pub entry: *mut ecs_bucket_entry_t,
    pub res: *mut ecs_map_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_map_iter_t"][::std::mem::size_of::<ecs_map_iter_t>() - 32usize];
    ["Alignment of ecs_map_iter_t"][::std::mem::align_of::<ecs_map_iter_t>() - 8usize];
    ["Offset of field: ecs_map_iter_t::map"][::std::mem::offset_of!(ecs_map_iter_t, map) - 0usize];
    ["Offset of field: ecs_map_iter_t::bucket"]
        [::std::mem::offset_of!(ecs_map_iter_t, bucket) - 8usize];
    ["Offset of field: ecs_map_iter_t::entry"]
        [::std::mem::offset_of!(ecs_map_iter_t, entry) - 16usize];
    ["Offset of field: ecs_map_iter_t::res"][::std::mem::offset_of!(ecs_map_iter_t, res) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_params_t {
    pub allocator: *mut ecs_allocator_t,
    pub entry_allocator: ecs_block_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_map_params_t"][::std::mem::size_of::<ecs_map_params_t>() - 56usize];
    ["Alignment of ecs_map_params_t"][::std::mem::align_of::<ecs_map_params_t>() - 8usize];
    ["Offset of field: ecs_map_params_t::allocator"]
        [::std::mem::offset_of!(ecs_map_params_t, allocator) - 0usize];
    ["Offset of field: ecs_map_params_t::entry_allocator"]
        [::std::mem::offset_of!(ecs_map_params_t, entry_allocator) - 8usize];
};
extern "C" {
    pub fn ecs_map_params_init(params: *mut ecs_map_params_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    pub fn ecs_map_params_fini(params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = " Initialize new map."]
    pub fn ecs_map_init(map: *mut ecs_map_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    #[doc = " Initialize new map."]
    pub fn ecs_map_init_w_params(map: *mut ecs_map_t, params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = " Initialize new map if uninitialized, leave as is otherwise"]
    pub fn ecs_map_init_if(map: *mut ecs_map_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    pub fn ecs_map_init_w_params_if(result: *mut ecs_map_t, params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = " Deinitialize map."]
    pub fn ecs_map_fini(map: *mut ecs_map_t);
}
extern "C" {
    #[doc = " Get element for key, returns NULL if they key doesn't exist."]
    pub fn ecs_map_get(map: *const ecs_map_t, key: ecs_map_key_t) -> *mut ecs_map_val_t;
}
extern "C" {
    pub fn ecs_map_get_deref_(
        map: *const ecs_map_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get or insert element for key."]
    pub fn ecs_map_ensure(map: *mut ecs_map_t, key: ecs_map_key_t) -> *mut ecs_map_val_t;
}
extern "C" {
    #[doc = " Get or insert pointer element for key, allocate if the pointer is NULL"]
    pub fn ecs_map_ensure_alloc(
        map: *mut ecs_map_t,
        elem_size: ecs_size_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Insert element for key."]
    pub fn ecs_map_insert(map: *mut ecs_map_t, key: ecs_map_key_t, value: ecs_map_val_t);
}
extern "C" {
    #[doc = " Insert pointer element for key, populate with new allocation."]
    pub fn ecs_map_insert_alloc(
        map: *mut ecs_map_t,
        elem_size: ecs_size_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove key from map."]
    pub fn ecs_map_remove(map: *mut ecs_map_t, key: ecs_map_key_t) -> ecs_map_val_t;
}
extern "C" {
    pub fn ecs_map_remove_free(map: *mut ecs_map_t, key: ecs_map_key_t);
}
extern "C" {
    #[doc = " Remove all elements from map."]
    pub fn ecs_map_clear(map: *mut ecs_map_t);
}
extern "C" {
    #[doc = " Return iterator to map contents."]
    pub fn ecs_map_iter(map: *const ecs_map_t) -> ecs_map_iter_t;
}
extern "C" {
    #[doc = " Obtain next element in map from iterator."]
    pub fn ecs_map_next(iter: *mut ecs_map_iter_t) -> bool;
}
extern "C" {
    #[doc = " Copy map."]
    pub fn ecs_map_copy(dst: *mut ecs_map_t, src: *const ecs_map_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_switch_node_t {
    pub next: u32,
    pub prev: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_switch_node_t"][::std::mem::size_of::<ecs_switch_node_t>() - 8usize];
    ["Alignment of ecs_switch_node_t"][::std::mem::align_of::<ecs_switch_node_t>() - 4usize];
    ["Offset of field: ecs_switch_node_t::next"]
        [::std::mem::offset_of!(ecs_switch_node_t, next) - 0usize];
    ["Offset of field: ecs_switch_node_t::prev"]
        [::std::mem::offset_of!(ecs_switch_node_t, prev) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_switch_page_t {
    pub nodes: ecs_vec_t,
    pub values: ecs_vec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_switch_page_t"][::std::mem::size_of::<ecs_switch_page_t>() - 32usize];
    ["Alignment of ecs_switch_page_t"][::std::mem::align_of::<ecs_switch_page_t>() - 8usize];
    ["Offset of field: ecs_switch_page_t::nodes"]
        [::std::mem::offset_of!(ecs_switch_page_t, nodes) - 0usize];
    ["Offset of field: ecs_switch_page_t::values"]
        [::std::mem::offset_of!(ecs_switch_page_t, values) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_switch_t {
    pub hdrs: ecs_map_t,
    pub pages: ecs_vec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_switch_t"][::std::mem::size_of::<ecs_switch_t>() - 56usize];
    ["Alignment of ecs_switch_t"][::std::mem::align_of::<ecs_switch_t>() - 8usize];
    ["Offset of field: ecs_switch_t::hdrs"][::std::mem::offset_of!(ecs_switch_t, hdrs) - 0usize];
    ["Offset of field: ecs_switch_t::pages"][::std::mem::offset_of!(ecs_switch_t, pages) - 40usize];
};
extern "C" {
    #[doc = " Init new switch."]
    pub fn flecs_switch_init(sw: *mut ecs_switch_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    #[doc = " Fini switch."]
    pub fn flecs_switch_fini(sw: *mut ecs_switch_t);
}
extern "C" {
    #[doc = " Set value of element."]
    pub fn flecs_switch_set(sw: *mut ecs_switch_t, element: u32, value: u64) -> bool;
}
extern "C" {
    #[doc = " Reset value of element."]
    pub fn flecs_switch_reset(sw: *mut ecs_switch_t, element: u32) -> bool;
}
extern "C" {
    #[doc = " Get value for element."]
    pub fn flecs_switch_get(sw: *const ecs_switch_t, element: u32) -> u64;
}
extern "C" {
    #[doc = " Get first element for value."]
    pub fn flecs_switch_first(sw: *const ecs_switch_t, value: u64) -> u32;
}
extern "C" {
    #[doc = " Get next element."]
    pub fn flecs_switch_next(sw: *const ecs_switch_t, previous: u32) -> u32;
}
extern "C" {
    #[doc = " Get target iterator."]
    pub fn flecs_switch_targets(sw: *const ecs_switch_t) -> ecs_map_iter_t;
}
extern "C" {
    pub static mut ecs_block_allocator_alloc_count: i64;
}
extern "C" {
    pub static mut ecs_block_allocator_free_count: i64;
}
extern "C" {
    pub static mut ecs_stack_allocator_alloc_count: i64;
}
extern "C" {
    pub static mut ecs_stack_allocator_free_count: i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_allocator_t {
    pub chunks: ecs_block_allocator_t,
    pub sizes: ecs_sparse_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_allocator_t"][::std::mem::size_of::<ecs_allocator_t>() - 112usize];
    ["Alignment of ecs_allocator_t"][::std::mem::align_of::<ecs_allocator_t>() - 8usize];
    ["Offset of field: ecs_allocator_t::chunks"]
        [::std::mem::offset_of!(ecs_allocator_t, chunks) - 0usize];
    ["Offset of field: ecs_allocator_t::sizes"]
        [::std::mem::offset_of!(ecs_allocator_t, sizes) - 48usize];
};
extern "C" {
    pub fn flecs_allocator_init(a: *mut ecs_allocator_t);
}
extern "C" {
    pub fn flecs_allocator_fini(a: *mut ecs_allocator_t);
}
extern "C" {
    pub fn flecs_allocator_get(
        a: *mut ecs_allocator_t,
        size: ecs_size_t,
    ) -> *mut ecs_block_allocator_t;
}
extern "C" {
    pub fn flecs_strdup(
        a: *mut ecs_allocator_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_strfree(a: *mut ecs_allocator_t, str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn flecs_dup(
        a: *mut ecs_allocator_t,
        size: ecs_size_t,
        src: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_list_elem {
    pub count: i32,
    pub separator: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_strbuf_list_elem"][::std::mem::size_of::<ecs_strbuf_list_elem>() - 16usize];
    ["Alignment of ecs_strbuf_list_elem"][::std::mem::align_of::<ecs_strbuf_list_elem>() - 8usize];
    ["Offset of field: ecs_strbuf_list_elem::count"]
        [::std::mem::offset_of!(ecs_strbuf_list_elem, count) - 0usize];
    ["Offset of field: ecs_strbuf_list_elem::separator"]
        [::std::mem::offset_of!(ecs_strbuf_list_elem, separator) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_t {
    pub content: *mut ::std::os::raw::c_char,
    pub length: ecs_size_t,
    pub size: ecs_size_t,
    pub list_stack: [ecs_strbuf_list_elem; 32usize],
    pub list_sp: i32,
    pub small_string: [::std::os::raw::c_char; 512usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_strbuf_t"][::std::mem::size_of::<ecs_strbuf_t>() - 1048usize];
    ["Alignment of ecs_strbuf_t"][::std::mem::align_of::<ecs_strbuf_t>() - 8usize];
    ["Offset of field: ecs_strbuf_t::content"]
        [::std::mem::offset_of!(ecs_strbuf_t, content) - 0usize];
    ["Offset of field: ecs_strbuf_t::length"]
        [::std::mem::offset_of!(ecs_strbuf_t, length) - 8usize];
    ["Offset of field: ecs_strbuf_t::size"][::std::mem::offset_of!(ecs_strbuf_t, size) - 12usize];
    ["Offset of field: ecs_strbuf_t::list_stack"]
        [::std::mem::offset_of!(ecs_strbuf_t, list_stack) - 16usize];
    ["Offset of field: ecs_strbuf_t::list_sp"]
        [::std::mem::offset_of!(ecs_strbuf_t, list_sp) - 528usize];
    ["Offset of field: ecs_strbuf_t::small_string"]
        [::std::mem::offset_of!(ecs_strbuf_t, small_string) - 532usize];
};
extern "C" {
    pub fn ecs_strbuf_append(buffer: *mut ecs_strbuf_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ecs_strbuf_vappend(
        buffer: *mut ecs_strbuf_t,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn ecs_strbuf_appendstr(buffer: *mut ecs_strbuf_t, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ecs_strbuf_appendch(buffer: *mut ecs_strbuf_t, ch: ::std::os::raw::c_char);
}
extern "C" {
    pub fn ecs_strbuf_appendint(buffer: *mut ecs_strbuf_t, v: i64);
}
extern "C" {
    pub fn ecs_strbuf_appendflt(
        buffer: *mut ecs_strbuf_t,
        v: f64,
        nan_delim: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_strbuf_appendbool(buffer: *mut ecs_strbuf_t, v: bool);
}
extern "C" {
    pub fn ecs_strbuf_mergebuff(dst_buffer: *mut ecs_strbuf_t, src_buffer: *mut ecs_strbuf_t);
}
extern "C" {
    pub fn ecs_strbuf_appendstrn(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
        n: i32,
    );
}
extern "C" {
    pub fn ecs_strbuf_get(buffer: *mut ecs_strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_strbuf_get_small(buffer: *mut ecs_strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_strbuf_reset(buffer: *mut ecs_strbuf_t);
}
extern "C" {
    pub fn ecs_strbuf_list_push(
        buffer: *mut ecs_strbuf_t,
        list_open: *const ::std::os::raw::c_char,
        separator: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_strbuf_list_pop(
        buffer: *mut ecs_strbuf_t,
        list_close: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_strbuf_list_next(buffer: *mut ecs_strbuf_t);
}
extern "C" {
    pub fn ecs_strbuf_list_appendch(buffer: *mut ecs_strbuf_t, ch: ::std::os::raw::c_char);
}
extern "C" {
    pub fn ecs_strbuf_list_append(
        buffer: *mut ecs_strbuf_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_strbuf_list_appendstr(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_strbuf_list_appendstrn(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
        n: i32,
    );
}
extern "C" {
    pub fn ecs_strbuf_written(buffer: *const ecs_strbuf_t) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _iobuf"][::std::mem::size_of::<_iobuf>() - 8usize];
    ["Alignment of _iobuf"][::std::mem::align_of::<_iobuf>() - 8usize];
    ["Offset of field: _iobuf::_Placeholder"]
        [::std::mem::offset_of!(_iobuf, _Placeholder) - 0usize];
};
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _heapinfo"][::std::mem::size_of::<_heapinfo>() - 24usize];
    ["Alignment of _heapinfo"][::std::mem::align_of::<_heapinfo>() - 8usize];
    ["Offset of field: _heapinfo::_pentry"][::std::mem::offset_of!(_heapinfo, _pentry) - 0usize];
    ["Offset of field: _heapinfo::_size"][::std::mem::offset_of!(_heapinfo, _size) - 8usize];
    ["Offset of field: _heapinfo::_useflag"][::std::mem::offset_of!(_heapinfo, _useflag) - 16usize];
};
pub type _HEAPINFO = _heapinfo;
extern "C" {
    pub fn _alloca(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
#[doc = " Time type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_time_t {
    #[doc = "< Second part."]
    pub sec: u32,
    #[doc = "< Nanosecond part."]
    pub nanosec: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_time_t"][::std::mem::size_of::<ecs_time_t>() - 8usize];
    ["Alignment of ecs_time_t"][::std::mem::align_of::<ecs_time_t>() - 4usize];
    ["Offset of field: ecs_time_t::sec"][::std::mem::offset_of!(ecs_time_t, sec) - 0usize];
    ["Offset of field: ecs_time_t::nanosec"][::std::mem::offset_of!(ecs_time_t, nanosec) - 4usize];
};
extern "C" {
    #[doc = "< malloc count."]
    pub static mut ecs_os_api_malloc_count: i64;
}
extern "C" {
    #[doc = "< realloc count."]
    pub static mut ecs_os_api_realloc_count: i64;
}
extern "C" {
    #[doc = "< calloc count."]
    pub static mut ecs_os_api_calloc_count: i64;
}
extern "C" {
    #[doc = "< free count."]
    pub static mut ecs_os_api_free_count: i64;
}
pub type ecs_os_thread_t = usize;
pub type ecs_os_cond_t = usize;
pub type ecs_os_mutex_t = usize;
pub type ecs_os_dl_t = usize;
pub type ecs_os_sock_t = usize;
#[doc = " 64 bit thread id."]
pub type ecs_os_thread_id_t = u64;
#[doc = " Generic function pointer type."]
pub type ecs_os_proc_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " OS API init."]
pub type ecs_os_api_init_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " OS API deinit."]
pub type ecs_os_api_fini_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " OS API malloc function type."]
pub type ecs_os_api_malloc_t =
    ::std::option::Option<unsafe extern "C" fn(size: ecs_size_t) -> *mut ::std::os::raw::c_void>;
#[doc = " OS API free function type."]
pub type ecs_os_api_free_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
#[doc = " OS API realloc function type."]
pub type ecs_os_api_realloc_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " OS API calloc function type."]
pub type ecs_os_api_calloc_t =
    ::std::option::Option<unsafe extern "C" fn(size: ecs_size_t) -> *mut ::std::os::raw::c_void>;
#[doc = " OS API strdup function type."]
pub type ecs_os_api_strdup_t = ::std::option::Option<
    unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
#[doc = " OS API thread_callback function type."]
pub type ecs_os_thread_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = " OS API thread_new function type."]
pub type ecs_os_api_thread_new_t = ::std::option::Option<
    unsafe extern "C" fn(
        callback: ecs_os_thread_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_os_thread_t,
>;
#[doc = " OS API thread_join function type."]
pub type ecs_os_api_thread_join_t = ::std::option::Option<
    unsafe extern "C" fn(thread: ecs_os_thread_t) -> *mut ::std::os::raw::c_void,
>;
#[doc = " OS API thread_self function type."]
pub type ecs_os_api_thread_self_t =
    ::std::option::Option<unsafe extern "C" fn() -> ecs_os_thread_id_t>;
#[doc = " OS API task_new function type."]
pub type ecs_os_api_task_new_t = ::std::option::Option<
    unsafe extern "C" fn(
        callback: ecs_os_thread_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_os_thread_t,
>;
#[doc = " OS API task_join function type."]
pub type ecs_os_api_task_join_t = ::std::option::Option<
    unsafe extern "C" fn(thread: ecs_os_thread_t) -> *mut ::std::os::raw::c_void,
>;
#[doc = " OS API ainc function type."]
pub type ecs_os_api_ainc_t = ::std::option::Option<unsafe extern "C" fn(value: *mut i32) -> i32>;
#[doc = " OS API lainc function type."]
pub type ecs_os_api_lainc_t = ::std::option::Option<unsafe extern "C" fn(value: *mut i64) -> i64>;
#[doc = " OS API mutex_new function type."]
pub type ecs_os_api_mutex_new_t = ::std::option::Option<unsafe extern "C" fn() -> ecs_os_mutex_t>;
#[doc = " OS API mutex_lock function type."]
pub type ecs_os_api_mutex_lock_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
#[doc = " OS API mutex_unlock function type."]
pub type ecs_os_api_mutex_unlock_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
#[doc = " OS API mutex_free function type."]
pub type ecs_os_api_mutex_free_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
#[doc = " OS API cond_new function type."]
pub type ecs_os_api_cond_new_t = ::std::option::Option<unsafe extern "C" fn() -> ecs_os_cond_t>;
#[doc = " OS API cond_free function type."]
pub type ecs_os_api_cond_free_t = ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
#[doc = " OS API cond_signal function type."]
pub type ecs_os_api_cond_signal_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
#[doc = " OS API cond_broadcast function type."]
pub type ecs_os_api_cond_broadcast_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
#[doc = " OS API cond_wait function type."]
pub type ecs_os_api_cond_wait_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t, mutex: ecs_os_mutex_t)>;
#[doc = " OS API sleep function type."]
pub type ecs_os_api_sleep_t = ::std::option::Option<unsafe extern "C" fn(sec: i32, nanosec: i32)>;
#[doc = " OS API enable_high_timer_resolution function type."]
pub type ecs_os_api_enable_high_timer_resolution_t =
    ::std::option::Option<unsafe extern "C" fn(enable: bool)>;
#[doc = " OS API get_time function type."]
pub type ecs_os_api_get_time_t =
    ::std::option::Option<unsafe extern "C" fn(time_out: *mut ecs_time_t)>;
#[doc = " OS API now function type."]
pub type ecs_os_api_now_t = ::std::option::Option<unsafe extern "C" fn() -> u64>;
#[doc = " OS API log function type."]
pub type ecs_os_api_log_t = ::std::option::Option<
    unsafe extern "C" fn(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " OS API abort function type."]
pub type ecs_os_api_abort_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " OS API dlopen function type."]
pub type ecs_os_api_dlopen_t = ::std::option::Option<
    unsafe extern "C" fn(libname: *const ::std::os::raw::c_char) -> ecs_os_dl_t,
>;
#[doc = " OS API dlproc function type."]
pub type ecs_os_api_dlproc_t = ::std::option::Option<
    unsafe extern "C" fn(
        lib: ecs_os_dl_t,
        procname: *const ::std::os::raw::c_char,
    ) -> ecs_os_proc_t,
>;
#[doc = " OS API dlclose function type."]
pub type ecs_os_api_dlclose_t = ::std::option::Option<unsafe extern "C" fn(lib: ecs_os_dl_t)>;
#[doc = " OS API module_to_path function type."]
pub type ecs_os_api_module_to_path_t = ::std::option::Option<
    unsafe extern "C" fn(module_id: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
#[doc = " OS API interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_os_api_t {
    #[doc = "< init callback."]
    pub init_: ecs_os_api_init_t,
    #[doc = "< fini callback."]
    pub fini_: ecs_os_api_fini_t,
    #[doc = "< malloc callback."]
    pub malloc_: ecs_os_api_malloc_t,
    #[doc = "< realloc callback."]
    pub realloc_: ecs_os_api_realloc_t,
    #[doc = "< calloc callback."]
    pub calloc_: ecs_os_api_calloc_t,
    #[doc = "< free callback."]
    pub free_: ecs_os_api_free_t,
    #[doc = "< strdup callback."]
    pub strdup_: ecs_os_api_strdup_t,
    #[doc = "< thread_new callback."]
    pub thread_new_: ecs_os_api_thread_new_t,
    #[doc = "< thread_join callback."]
    pub thread_join_: ecs_os_api_thread_join_t,
    #[doc = "< thread_self callback."]
    pub thread_self_: ecs_os_api_thread_self_t,
    #[doc = "< task_new callback."]
    pub task_new_: ecs_os_api_thread_new_t,
    #[doc = "< task_join callback."]
    pub task_join_: ecs_os_api_thread_join_t,
    #[doc = "< ainc callback."]
    pub ainc_: ecs_os_api_ainc_t,
    #[doc = "< adec callback."]
    pub adec_: ecs_os_api_ainc_t,
    #[doc = "< lainc callback."]
    pub lainc_: ecs_os_api_lainc_t,
    #[doc = "< ladec callback."]
    pub ladec_: ecs_os_api_lainc_t,
    #[doc = "< mutex_new callback."]
    pub mutex_new_: ecs_os_api_mutex_new_t,
    #[doc = "< mutex_free callback."]
    pub mutex_free_: ecs_os_api_mutex_free_t,
    #[doc = "< mutex_lock callback."]
    pub mutex_lock_: ecs_os_api_mutex_lock_t,
    #[doc = "< mutex_unlock callback."]
    pub mutex_unlock_: ecs_os_api_mutex_lock_t,
    #[doc = "< cond_new callback."]
    pub cond_new_: ecs_os_api_cond_new_t,
    #[doc = "< cond_free callback."]
    pub cond_free_: ecs_os_api_cond_free_t,
    #[doc = "< cond_signal callback."]
    pub cond_signal_: ecs_os_api_cond_signal_t,
    #[doc = "< cond_broadcast callback."]
    pub cond_broadcast_: ecs_os_api_cond_broadcast_t,
    #[doc = "< cond_wait callback."]
    pub cond_wait_: ecs_os_api_cond_wait_t,
    #[doc = "< sleep callback."]
    pub sleep_: ecs_os_api_sleep_t,
    #[doc = "< now callback."]
    pub now_: ecs_os_api_now_t,
    #[doc = "< get_time callback."]
    pub get_time_: ecs_os_api_get_time_t,
    #[doc = "< log callback.\n The level should be interpreted as:\n >0: Debug tracing. Only enabled in debug builds.\n  0: Tracing. Enabled in debug/release builds.\n -2: Warning. An issue occurred, but operation was successful.\n -3: Error. An issue occurred, and operation was unsuccessful.\n -4: Fatal. An issue occurred, and application must quit."]
    pub log_: ecs_os_api_log_t,
    #[doc = "< abort callback."]
    pub abort_: ecs_os_api_abort_t,
    #[doc = "< dlopen callback."]
    pub dlopen_: ecs_os_api_dlopen_t,
    #[doc = "< dlproc callback."]
    pub dlproc_: ecs_os_api_dlproc_t,
    #[doc = "< dlclose callback."]
    pub dlclose_: ecs_os_api_dlclose_t,
    #[doc = "< module_to_dl callback."]
    pub module_to_dl_: ecs_os_api_module_to_path_t,
    #[doc = "< module_to_etc callback."]
    pub module_to_etc_: ecs_os_api_module_to_path_t,
    #[doc = "< Tracing level."]
    pub log_level_: i32,
    #[doc = "< Tracing indentation level."]
    pub log_indent_: i32,
    #[doc = "< Last logged error code."]
    pub log_last_error_: i32,
    #[doc = "< Last logged timestamp."]
    pub log_last_timestamp_: i64,
    #[doc = "< OS API flags"]
    pub flags_: ecs_flags32_t,
    #[doc = "< File used for logging output\n (hint, log_ decides where to write)"]
    pub log_out_: *mut FILE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_os_api_t"][::std::mem::size_of::<ecs_os_api_t>() - 320usize];
    ["Alignment of ecs_os_api_t"][::std::mem::align_of::<ecs_os_api_t>() - 8usize];
    ["Offset of field: ecs_os_api_t::init_"][::std::mem::offset_of!(ecs_os_api_t, init_) - 0usize];
    ["Offset of field: ecs_os_api_t::fini_"][::std::mem::offset_of!(ecs_os_api_t, fini_) - 8usize];
    ["Offset of field: ecs_os_api_t::malloc_"]
        [::std::mem::offset_of!(ecs_os_api_t, malloc_) - 16usize];
    ["Offset of field: ecs_os_api_t::realloc_"]
        [::std::mem::offset_of!(ecs_os_api_t, realloc_) - 24usize];
    ["Offset of field: ecs_os_api_t::calloc_"]
        [::std::mem::offset_of!(ecs_os_api_t, calloc_) - 32usize];
    ["Offset of field: ecs_os_api_t::free_"][::std::mem::offset_of!(ecs_os_api_t, free_) - 40usize];
    ["Offset of field: ecs_os_api_t::strdup_"]
        [::std::mem::offset_of!(ecs_os_api_t, strdup_) - 48usize];
    ["Offset of field: ecs_os_api_t::thread_new_"]
        [::std::mem::offset_of!(ecs_os_api_t, thread_new_) - 56usize];
    ["Offset of field: ecs_os_api_t::thread_join_"]
        [::std::mem::offset_of!(ecs_os_api_t, thread_join_) - 64usize];
    ["Offset of field: ecs_os_api_t::thread_self_"]
        [::std::mem::offset_of!(ecs_os_api_t, thread_self_) - 72usize];
    ["Offset of field: ecs_os_api_t::task_new_"]
        [::std::mem::offset_of!(ecs_os_api_t, task_new_) - 80usize];
    ["Offset of field: ecs_os_api_t::task_join_"]
        [::std::mem::offset_of!(ecs_os_api_t, task_join_) - 88usize];
    ["Offset of field: ecs_os_api_t::ainc_"][::std::mem::offset_of!(ecs_os_api_t, ainc_) - 96usize];
    ["Offset of field: ecs_os_api_t::adec_"]
        [::std::mem::offset_of!(ecs_os_api_t, adec_) - 104usize];
    ["Offset of field: ecs_os_api_t::lainc_"]
        [::std::mem::offset_of!(ecs_os_api_t, lainc_) - 112usize];
    ["Offset of field: ecs_os_api_t::ladec_"]
        [::std::mem::offset_of!(ecs_os_api_t, ladec_) - 120usize];
    ["Offset of field: ecs_os_api_t::mutex_new_"]
        [::std::mem::offset_of!(ecs_os_api_t, mutex_new_) - 128usize];
    ["Offset of field: ecs_os_api_t::mutex_free_"]
        [::std::mem::offset_of!(ecs_os_api_t, mutex_free_) - 136usize];
    ["Offset of field: ecs_os_api_t::mutex_lock_"]
        [::std::mem::offset_of!(ecs_os_api_t, mutex_lock_) - 144usize];
    ["Offset of field: ecs_os_api_t::mutex_unlock_"]
        [::std::mem::offset_of!(ecs_os_api_t, mutex_unlock_) - 152usize];
    ["Offset of field: ecs_os_api_t::cond_new_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_new_) - 160usize];
    ["Offset of field: ecs_os_api_t::cond_free_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_free_) - 168usize];
    ["Offset of field: ecs_os_api_t::cond_signal_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_signal_) - 176usize];
    ["Offset of field: ecs_os_api_t::cond_broadcast_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_broadcast_) - 184usize];
    ["Offset of field: ecs_os_api_t::cond_wait_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_wait_) - 192usize];
    ["Offset of field: ecs_os_api_t::sleep_"]
        [::std::mem::offset_of!(ecs_os_api_t, sleep_) - 200usize];
    ["Offset of field: ecs_os_api_t::now_"][::std::mem::offset_of!(ecs_os_api_t, now_) - 208usize];
    ["Offset of field: ecs_os_api_t::get_time_"]
        [::std::mem::offset_of!(ecs_os_api_t, get_time_) - 216usize];
    ["Offset of field: ecs_os_api_t::log_"][::std::mem::offset_of!(ecs_os_api_t, log_) - 224usize];
    ["Offset of field: ecs_os_api_t::abort_"]
        [::std::mem::offset_of!(ecs_os_api_t, abort_) - 232usize];
    ["Offset of field: ecs_os_api_t::dlopen_"]
        [::std::mem::offset_of!(ecs_os_api_t, dlopen_) - 240usize];
    ["Offset of field: ecs_os_api_t::dlproc_"]
        [::std::mem::offset_of!(ecs_os_api_t, dlproc_) - 248usize];
    ["Offset of field: ecs_os_api_t::dlclose_"]
        [::std::mem::offset_of!(ecs_os_api_t, dlclose_) - 256usize];
    ["Offset of field: ecs_os_api_t::module_to_dl_"]
        [::std::mem::offset_of!(ecs_os_api_t, module_to_dl_) - 264usize];
    ["Offset of field: ecs_os_api_t::module_to_etc_"]
        [::std::mem::offset_of!(ecs_os_api_t, module_to_etc_) - 272usize];
    ["Offset of field: ecs_os_api_t::log_level_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_level_) - 280usize];
    ["Offset of field: ecs_os_api_t::log_indent_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_indent_) - 284usize];
    ["Offset of field: ecs_os_api_t::log_last_error_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_last_error_) - 288usize];
    ["Offset of field: ecs_os_api_t::log_last_timestamp_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_last_timestamp_) - 296usize];
    ["Offset of field: ecs_os_api_t::flags_"]
        [::std::mem::offset_of!(ecs_os_api_t, flags_) - 304usize];
    ["Offset of field: ecs_os_api_t::log_out_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_out_) - 312usize];
};
extern "C" {
    #[doc = " Static OS API variable with configured callbacks."]
    pub static mut ecs_os_api: ecs_os_api_t;
}
extern "C" {
    #[doc = " Initialize OS API.\n This operation is not usually called by an application. To override callbacks\n of the OS API, use the following pattern:\n\n @code\n ecs_os_set_api_defaults();\n ecs_os_api_t os_api = ecs_os_get_api();\n os_api.abort_ = my_abort;\n ecs_os_set_api(&os_api);\n @endcode"]
    pub fn ecs_os_init();
}
extern "C" {
    #[doc = " Deinitialize OS API.\n This operation is not usually called by an application."]
    pub fn ecs_os_fini();
}
extern "C" {
    #[doc = " Override OS API.\n This overrides the OS API struct with new values for callbacks. See\n ecs_os_init() on how to use the function.\n\n @param os_api Pointer to struct with values to set."]
    pub fn ecs_os_set_api(os_api: *mut ecs_os_api_t);
}
extern "C" {
    #[doc = " Get OS API.\n\n @return A value with the current OS API callbacks\n @see ecs_os_init()"]
    pub fn ecs_os_get_api() -> ecs_os_api_t;
}
extern "C" {
    #[doc = " Set default values for OS API.\n This initializes the OS API struct with default values for callbacks like\n malloc and free.\n\n @see ecs_os_init()"]
    pub fn ecs_os_set_api_defaults();
}
extern "C" {
    #[doc = " Log at debug level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_dbg(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Log at trace level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_trace(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Log at warning level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_warn(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Log at error level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_err(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Log at fatal level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_fatal(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Convert errno to string.\n\n @param err The error number.\n @return A string describing the error."]
    pub fn ecs_os_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Utility for assigning strings.\n This operation frees an existing string and duplicates the input string.\n\n @param str Pointer to a string value.\n @param value The string value to assign."]
    pub fn ecs_os_strset(
        str_: *mut *mut ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Sleep with floating point time.\n\n @param t The time in seconds."]
    pub fn ecs_sleepf(t: f64);
}
extern "C" {
    #[doc = " Measure time since provided timestamp.\n Use with a time value initialized to 0 to obtain the number of seconds since\n the epoch. The operation will write the current timestamp in start.\n\n Usage:\n @code\n ecs_time_t t = {};\n ecs_time_measure(&t);\n // code\n double elapsed = ecs_time_measure(&t);\n @endcode\n\n @param start The starting timestamp.\n @return The time elapsed since start."]
    pub fn ecs_time_measure(start: *mut ecs_time_t) -> f64;
}
extern "C" {
    #[doc = " Calculate difference between two timestamps.\n\n @param t1 The first timestamp.\n @param t2 The first timestamp.\n @return The difference between timestamps."]
    pub fn ecs_time_sub(t1: ecs_time_t, t2: ecs_time_t) -> ecs_time_t;
}
extern "C" {
    #[doc = " Convert time value to a double.\n\n @param t The timestamp.\n @return The timestamp converted to a double."]
    pub fn ecs_time_to_double(t: ecs_time_t) -> f64;
}
extern "C" {
    #[doc = " Return newly allocated memory that contains a copy of src.\n\n @param src The source pointer.\n @param size The number of bytes to copy.\n @return The duplicated memory."]
    pub fn ecs_os_memdup(
        src: *const ::std::os::raw::c_void,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Are heap functions available?"]
    pub fn ecs_os_has_heap() -> bool;
}
extern "C" {
    #[doc = " Are threading functions available?"]
    pub fn ecs_os_has_threading() -> bool;
}
extern "C" {
    #[doc = " Are task functions available?"]
    pub fn ecs_os_has_task_support() -> bool;
}
extern "C" {
    #[doc = " Are time functions available?"]
    pub fn ecs_os_has_time() -> bool;
}
extern "C" {
    #[doc = " Are logging functions available?"]
    pub fn ecs_os_has_logging() -> bool;
}
extern "C" {
    #[doc = " Are dynamic library functions available?"]
    pub fn ecs_os_has_dl() -> bool;
}
extern "C" {
    #[doc = " Are module path functions available?"]
    pub fn ecs_os_has_modules() -> bool;
}
#[doc = " Ids are the things that can be added to an entity.\n An id can be an entity or pair, and can have optional id flags."]
pub type ecs_id_t = u64;
#[doc = " An entity identifier.\n Entity ids consist out of a number unique to the entity in the lower 32 bits,\n and a counter used to track entity liveliness in the upper 32 bits. When an\n id is recycled, its generation count is increased. This causes recycled ids\n to be very large (>4 billion), which is normal."]
pub type ecs_entity_t = ecs_id_t;
#[doc = " A type is a list of (component) ids.\n Types are used to communicate the \"type\" of an entity. In most type systems a\n typeof operation returns a single type. In ECS however, an entity can have\n multiple components, which is why an ECS type consists of a vector of ids.\n\n The component ids of a type are sorted, which ensures that it doesn't matter\n in which order components are added to an entity. For example, if adding\n Position then Velocity would result in type [Position, Velocity], first\n adding Velocity then Position would also result in type [Position, Velocity].\n\n Entities are grouped together by type in the ECS storage in tables. The\n storage has exactly one table per unique type that is created by the\n application that stores all entities and components for that type. This is\n also referred to as an archetype."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_t {
    #[doc = "< Array with ids."]
    pub array: *mut ecs_id_t,
    #[doc = "< Number of elements in array."]
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_type_t"][::std::mem::size_of::<ecs_type_t>() - 16usize];
    ["Alignment of ecs_type_t"][::std::mem::align_of::<ecs_type_t>() - 8usize];
    ["Offset of field: ecs_type_t::array"][::std::mem::offset_of!(ecs_type_t, array) - 0usize];
    ["Offset of field: ecs_type_t::count"][::std::mem::offset_of!(ecs_type_t, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stage_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_id_record_t {
    _unused: [u8; 0],
}
#[doc = " A poly object.\n A poly (short for polymorph) object is an object that has a variable list of\n capabilities, determined by a mixin table. This is the current list of types\n in the flecs API that can be used as an ecs_poly_t:\n\n - ecs_world_t\n - ecs_stage_t\n - ecs_query_t\n\n Functions that accept an ecs_poly_t argument can accept objects of these\n types. If the object does not have the requested mixin the API will throw an\n assert.\n\n The poly/mixin framework enables partially overlapping features to be\n implemented once, and enables objects of different types to interact with\n each other depending on what mixins they have, rather than their type\n (in some ways it's like a mini-ECS). Additionally, each poly object has a\n header that enables the API to do sanity checking on the input arguments."]
pub type ecs_poly_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_mixins_t {
    _unused: [u8; 0],
}
#[doc = " Header for ecs_poly_t objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_header_t {
    #[doc = "< Magic number verifying it's a flecs object"]
    pub magic: i32,
    #[doc = "< Magic number indicating which type of flecs object"]
    pub type_: i32,
    #[doc = "< Refcount, to enable RAII handles"]
    pub refcount: i32,
    #[doc = "< Table with offsets to (optional) mixins"]
    pub mixins: *mut ecs_mixins_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_header_t"][::std::mem::size_of::<ecs_header_t>() - 24usize];
    ["Alignment of ecs_header_t"][::std::mem::align_of::<ecs_header_t>() - 8usize];
    ["Offset of field: ecs_header_t::magic"][::std::mem::offset_of!(ecs_header_t, magic) - 0usize];
    ["Offset of field: ecs_header_t::type_"][::std::mem::offset_of!(ecs_header_t, type_) - 4usize];
    ["Offset of field: ecs_header_t::refcount"]
        [::std::mem::offset_of!(ecs_header_t, refcount) - 8usize];
    ["Offset of field: ecs_header_t::mixins"]
        [::std::mem::offset_of!(ecs_header_t, mixins) - 16usize];
};
#[doc = " Record for entity index"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_record_t {
    #[doc = "< Id record to (*, entity) for target entities"]
    pub idr: *mut ecs_id_record_t,
    #[doc = "< Identifies a type (and table) in world"]
    pub table: *mut ecs_table_t,
    #[doc = "< Table row of the entity"]
    pub row: u32,
    #[doc = "< Index in dense array of entity index"]
    pub dense: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_record_t"][::std::mem::size_of::<ecs_record_t>() - 24usize];
    ["Alignment of ecs_record_t"][::std::mem::align_of::<ecs_record_t>() - 8usize];
    ["Offset of field: ecs_record_t::idr"][::std::mem::offset_of!(ecs_record_t, idr) - 0usize];
    ["Offset of field: ecs_record_t::table"][::std::mem::offset_of!(ecs_record_t, table) - 8usize];
    ["Offset of field: ecs_record_t::row"][::std::mem::offset_of!(ecs_record_t, row) - 16usize];
    ["Offset of field: ecs_record_t::dense"][::std::mem::offset_of!(ecs_record_t, dense) - 20usize];
};
#[doc = " Header for table cache elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_cache_hdr_t {
    #[doc = "< Table cache of element. Of type ecs_id_record_t* for component index elements."]
    pub cache: *mut ecs_table_cache_t,
    #[doc = "< Table associated with element."]
    pub table: *mut ecs_table_t,
    #[doc = "< Next/previous elements for id in table cache."]
    pub prev: *mut ecs_table_cache_hdr_t,
    #[doc = "< Next/previous elements for id in table cache."]
    pub next: *mut ecs_table_cache_hdr_t,
    #[doc = "< Whether element is in empty list."]
    pub empty: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_table_cache_hdr_t"][::std::mem::size_of::<ecs_table_cache_hdr_t>() - 40usize];
    ["Alignment of ecs_table_cache_hdr_t"]
        [::std::mem::align_of::<ecs_table_cache_hdr_t>() - 8usize];
    ["Offset of field: ecs_table_cache_hdr_t::cache"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, cache) - 0usize];
    ["Offset of field: ecs_table_cache_hdr_t::table"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, table) - 8usize];
    ["Offset of field: ecs_table_cache_hdr_t::prev"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, prev) - 16usize];
    ["Offset of field: ecs_table_cache_hdr_t::next"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, next) - 24usize];
    ["Offset of field: ecs_table_cache_hdr_t::empty"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, empty) - 32usize];
};
#[doc = " Metadata describing where a component id is stored in a table.\n This type is used as element type for the component index table cache. One\n record exists per table/component in the table. Only records for wildcard ids\n can have a count > 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_record_t {
    #[doc = "< Table cache header"]
    pub hdr: ecs_table_cache_hdr_t,
    #[doc = "< First type index where id occurs in table"]
    pub index: i16,
    #[doc = "< Number of times id occurs in table"]
    pub count: i16,
    #[doc = "< First column index where id occurs"]
    pub column: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_table_record_t"][::std::mem::size_of::<ecs_table_record_t>() - 48usize];
    ["Alignment of ecs_table_record_t"][::std::mem::align_of::<ecs_table_record_t>() - 8usize];
    ["Offset of field: ecs_table_record_t::hdr"]
        [::std::mem::offset_of!(ecs_table_record_t, hdr) - 0usize];
    ["Offset of field: ecs_table_record_t::index"]
        [::std::mem::offset_of!(ecs_table_record_t, index) - 40usize];
    ["Offset of field: ecs_table_record_t::count"]
        [::std::mem::offset_of!(ecs_table_record_t, count) - 42usize];
    ["Offset of field: ecs_table_record_t::column"]
        [::std::mem::offset_of!(ecs_table_record_t, column) - 44usize];
};
#[doc = " Function prototype for runnables (systems, observers).\n The run callback overrides the default behavior for iterating through the\n results of a runnable object.\n\n The default runnable iterates the iterator, and calls an iter_action (see\n below) for each returned result.\n\n @param it The iterator to be iterated by the runnable."]
pub type ecs_run_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = " Function prototype for iterables.\n A system may invoke a callback multiple times, typically once for each\n matched table.\n\n @param it The iterator containing the data for the current match."]
pub type ecs_iter_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = " Function prototype for iterating an iterator.\n Stored inside initialized iterators. This allows an application to iterate\n an iterator without needing to know what created it.\n\n @param it The iterator to iterate.\n @return True if iterator has no more results, false if it does."]
pub type ecs_iter_next_action_t =
    ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t) -> bool>;
#[doc = " Function prototype for freeing an iterator.\n Free iterator resources.\n\n @param it The iterator to free."]
pub type ecs_iter_fini_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = " Callback used for comparing components"]
pub type ecs_order_by_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        e1: ecs_entity_t,
        ptr1: *const ::std::os::raw::c_void,
        e2: ecs_entity_t,
        ptr2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback used for sorting the entire table of components"]
pub type ecs_sort_table_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        entities: *mut ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
        size: i32,
        lo: i32,
        hi: i32,
        order_by: ecs_order_by_action_t,
    ),
>;
#[doc = " Callback used for grouping tables in a query"]
pub type ecs_group_by_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        group_id: ecs_id_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> u64,
>;
#[doc = " Callback invoked when a query creates a new group."]
pub type ecs_group_create_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        group_id: u64,
        group_by_ctx: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Callback invoked when a query deletes an existing group."]
pub type ecs_group_delete_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        group_id: u64,
        group_ctx: *mut ::std::os::raw::c_void,
        group_by_ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Initialization action for modules"]
pub type ecs_module_action_t = ::std::option::Option<unsafe extern "C" fn(world: *mut ecs_world_t)>;
#[doc = " Action callback on world exit"]
pub type ecs_fini_action_t = ::std::option::Option<
    unsafe extern "C" fn(world: *mut ecs_world_t, ctx: *mut ::std::os::raw::c_void),
>;
#[doc = " Function to cleanup context data"]
pub type ecs_ctx_free_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = " Callback used for sorting values"]
pub type ecs_compare_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr1: *const ::std::os::raw::c_void,
        ptr2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback used for hashing values"]
pub type ecs_hash_value_action_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> u64>;
#[doc = " Constructor/destructor callback"]
pub type ecs_xtor_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = " Copy is invoked when a component is copied into another component."]
pub type ecs_copy_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst_ptr: *mut ::std::os::raw::c_void,
        src_ptr: *const ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = " Move is invoked when a component is moved to another component."]
pub type ecs_move_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst_ptr: *mut ::std::os::raw::c_void,
        src_ptr: *mut ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = " Destructor function for poly objects."]
pub type flecs_poly_dtor_t = ::std::option::Option<unsafe extern "C" fn(poly: *mut ecs_poly_t)>;
#[doc = "< InOut for regular terms, In for shared terms"]
pub const ecs_inout_kind_t_EcsInOutDefault: ecs_inout_kind_t = 0;
#[doc = "< Term is neither read nor written"]
pub const ecs_inout_kind_t_EcsInOutNone: ecs_inout_kind_t = 1;
#[doc = "< Same as InOutNone + prevents term from triggering observers"]
pub const ecs_inout_kind_t_EcsInOutFilter: ecs_inout_kind_t = 2;
#[doc = "< Term is both read and written"]
pub const ecs_inout_kind_t_EcsInOut: ecs_inout_kind_t = 3;
#[doc = "< Term is only read"]
pub const ecs_inout_kind_t_EcsIn: ecs_inout_kind_t = 4;
#[doc = "< Term is only written"]
pub const ecs_inout_kind_t_EcsOut: ecs_inout_kind_t = 5;
#[doc = " Specify read/write access for term"]
pub type ecs_inout_kind_t = ::std::os::raw::c_int;
#[doc = "< The term must match"]
pub const ecs_oper_kind_t_EcsAnd: ecs_oper_kind_t = 0;
#[doc = "< One of the terms in an or chain must match"]
pub const ecs_oper_kind_t_EcsOr: ecs_oper_kind_t = 1;
#[doc = "< The term must not match"]
pub const ecs_oper_kind_t_EcsNot: ecs_oper_kind_t = 2;
#[doc = "< The term may match"]
pub const ecs_oper_kind_t_EcsOptional: ecs_oper_kind_t = 3;
#[doc = "< Term must match all components from term id"]
pub const ecs_oper_kind_t_EcsAndFrom: ecs_oper_kind_t = 4;
#[doc = "< Term must match at least one component from term id"]
pub const ecs_oper_kind_t_EcsOrFrom: ecs_oper_kind_t = 5;
#[doc = "< Term must match none of the components from term id"]
pub const ecs_oper_kind_t_EcsNotFrom: ecs_oper_kind_t = 6;
#[doc = " Specify operator for term"]
pub type ecs_oper_kind_t = ::std::os::raw::c_int;
#[doc = "< Behavior determined by query creation context"]
pub const ecs_query_cache_kind_t_EcsQueryCacheDefault: ecs_query_cache_kind_t = 0;
#[doc = "< Cache query terms that are cacheable"]
pub const ecs_query_cache_kind_t_EcsQueryCacheAuto: ecs_query_cache_kind_t = 1;
#[doc = "< Require that all query terms can be cached"]
pub const ecs_query_cache_kind_t_EcsQueryCacheAll: ecs_query_cache_kind_t = 2;
#[doc = "< No caching"]
pub const ecs_query_cache_kind_t_EcsQueryCacheNone: ecs_query_cache_kind_t = 3;
#[doc = " Specify cache policy for query"]
pub type ecs_query_cache_kind_t = ::std::os::raw::c_int;
#[doc = " Type that describes a reference to an entity or variable in a term."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_term_ref_t {
    #[doc = "< Entity id. If left to 0 and flags does not\n specify whether id is an entity or a variable\n the id will be initialized to #EcsThis.\n To explicitly set the id to 0, leave the id\n member to 0 and set #EcsIsEntity in flags."]
    pub id: ecs_entity_t,
    #[doc = "< Name. This can be either the variable name\n (when the #EcsIsVariable flag is set) or an\n entity name. When ecs_term_t::move is true,\n the API assumes ownership over the string and\n will free it when the term is destroyed."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_term_ref_t"][::std::mem::size_of::<ecs_term_ref_t>() - 16usize];
    ["Alignment of ecs_term_ref_t"][::std::mem::align_of::<ecs_term_ref_t>() - 8usize];
    ["Offset of field: ecs_term_ref_t::id"][::std::mem::offset_of!(ecs_term_ref_t, id) - 0usize];
    ["Offset of field: ecs_term_ref_t::name"]
        [::std::mem::offset_of!(ecs_term_ref_t, name) - 8usize];
};
#[doc = " Type that describes a term (single element in a query)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_term_t {
    #[doc = "< Component id to be matched by term. Can be\n set directly, or will be populated from the\n first/second members, which provide more\n flexibility."]
    pub id: ecs_id_t,
    #[doc = "< Source of term"]
    pub src: ecs_term_ref_t,
    #[doc = "< Component or first element of pair"]
    pub first: ecs_term_ref_t,
    #[doc = "< Second element of pair"]
    pub second: ecs_term_ref_t,
    #[doc = "< Relationship to traverse when looking for the\n component. The relationship must have\n the `Traversable` property. Default is `IsA`."]
    pub trav: ecs_entity_t,
    #[doc = "< Access to contents matched by term"]
    pub inout: i16,
    #[doc = "< Operator of term"]
    pub oper: i16,
    #[doc = "< Index of field for term in iterator"]
    pub field_index: i8,
    #[doc = "< Flags that help eval, set by ecs_query_init()"]
    pub flags_: ecs_flags16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_term_t"][::std::mem::size_of::<ecs_term_t>() - 72usize];
    ["Alignment of ecs_term_t"][::std::mem::align_of::<ecs_term_t>() - 8usize];
    ["Offset of field: ecs_term_t::id"][::std::mem::offset_of!(ecs_term_t, id) - 0usize];
    ["Offset of field: ecs_term_t::src"][::std::mem::offset_of!(ecs_term_t, src) - 8usize];
    ["Offset of field: ecs_term_t::first"][::std::mem::offset_of!(ecs_term_t, first) - 24usize];
    ["Offset of field: ecs_term_t::second"][::std::mem::offset_of!(ecs_term_t, second) - 40usize];
    ["Offset of field: ecs_term_t::trav"][::std::mem::offset_of!(ecs_term_t, trav) - 56usize];
    ["Offset of field: ecs_term_t::inout"][::std::mem::offset_of!(ecs_term_t, inout) - 64usize];
    ["Offset of field: ecs_term_t::oper"][::std::mem::offset_of!(ecs_term_t, oper) - 66usize];
    ["Offset of field: ecs_term_t::field_index"]
        [::std::mem::offset_of!(ecs_term_t, field_index) - 68usize];
    ["Offset of field: ecs_term_t::flags_"][::std::mem::offset_of!(ecs_term_t, flags_) - 70usize];
};
#[doc = " Queries are lists of constraints (terms) that match entities.\n Created with ecs_query_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_t {
    #[doc = "< Object header"]
    pub hdr: ecs_header_t,
    #[doc = "< Query terms"]
    pub terms: [ecs_term_t; 32usize],
    #[doc = "< Component sizes. Indexed by field"]
    pub sizes: [i32; 32usize],
    #[doc = "< Component ids. Indexed by field"]
    pub ids: [ecs_id_t; 32usize],
    #[doc = "< Query flags"]
    pub flags: ecs_flags32_t,
    #[doc = "< Number of query variables"]
    pub var_count: i8,
    #[doc = "< Number of query terms"]
    pub term_count: i8,
    #[doc = "< Number of fields returned by query"]
    pub field_count: i8,
    #[doc = "< Fields with a fixed source"]
    pub fixed_fields: ecs_flags32_t,
    #[doc = "< Fields with a static (component) id"]
    pub static_id_fields: ecs_flags32_t,
    #[doc = "< Fields that have data"]
    pub data_fields: ecs_flags32_t,
    #[doc = "< Fields that write data"]
    pub write_fields: ecs_flags32_t,
    #[doc = "< Fields that read data"]
    pub read_fields: ecs_flags32_t,
    #[doc = "< Fields that must be acquired with field_at"]
    pub row_fields: ecs_flags32_t,
    #[doc = "< Fields that don't write shared data"]
    pub shared_readonly_fields: ecs_flags32_t,
    #[doc = "< Fields that will be set"]
    pub set_fields: ecs_flags32_t,
    #[doc = "< Caching policy of query"]
    pub cache_kind: ecs_query_cache_kind_t,
    #[doc = "< Array with variable names for iterator"]
    pub vars: *mut *mut ::std::os::raw::c_char,
    #[doc = "< User context to pass to callback"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Context to be used for language bindings"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Entity associated with query (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "< Actual world."]
    pub real_world: *mut ecs_world_t,
    #[doc = "< World or stage query was created with."]
    pub world: *mut ecs_world_t,
    #[doc = "< Number of times query is evaluated"]
    pub eval_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_t"][::std::mem::size_of::<ecs_query_t>() - 2816usize];
    ["Alignment of ecs_query_t"][::std::mem::align_of::<ecs_query_t>() - 8usize];
    ["Offset of field: ecs_query_t::hdr"][::std::mem::offset_of!(ecs_query_t, hdr) - 0usize];
    ["Offset of field: ecs_query_t::terms"][::std::mem::offset_of!(ecs_query_t, terms) - 24usize];
    ["Offset of field: ecs_query_t::sizes"][::std::mem::offset_of!(ecs_query_t, sizes) - 2328usize];
    ["Offset of field: ecs_query_t::ids"][::std::mem::offset_of!(ecs_query_t, ids) - 2456usize];
    ["Offset of field: ecs_query_t::flags"][::std::mem::offset_of!(ecs_query_t, flags) - 2712usize];
    ["Offset of field: ecs_query_t::var_count"]
        [::std::mem::offset_of!(ecs_query_t, var_count) - 2716usize];
    ["Offset of field: ecs_query_t::term_count"]
        [::std::mem::offset_of!(ecs_query_t, term_count) - 2717usize];
    ["Offset of field: ecs_query_t::field_count"]
        [::std::mem::offset_of!(ecs_query_t, field_count) - 2718usize];
    ["Offset of field: ecs_query_t::fixed_fields"]
        [::std::mem::offset_of!(ecs_query_t, fixed_fields) - 2720usize];
    ["Offset of field: ecs_query_t::static_id_fields"]
        [::std::mem::offset_of!(ecs_query_t, static_id_fields) - 2724usize];
    ["Offset of field: ecs_query_t::data_fields"]
        [::std::mem::offset_of!(ecs_query_t, data_fields) - 2728usize];
    ["Offset of field: ecs_query_t::write_fields"]
        [::std::mem::offset_of!(ecs_query_t, write_fields) - 2732usize];
    ["Offset of field: ecs_query_t::read_fields"]
        [::std::mem::offset_of!(ecs_query_t, read_fields) - 2736usize];
    ["Offset of field: ecs_query_t::row_fields"]
        [::std::mem::offset_of!(ecs_query_t, row_fields) - 2740usize];
    ["Offset of field: ecs_query_t::shared_readonly_fields"]
        [::std::mem::offset_of!(ecs_query_t, shared_readonly_fields) - 2744usize];
    ["Offset of field: ecs_query_t::set_fields"]
        [::std::mem::offset_of!(ecs_query_t, set_fields) - 2748usize];
    ["Offset of field: ecs_query_t::cache_kind"]
        [::std::mem::offset_of!(ecs_query_t, cache_kind) - 2752usize];
    ["Offset of field: ecs_query_t::vars"][::std::mem::offset_of!(ecs_query_t, vars) - 2760usize];
    ["Offset of field: ecs_query_t::ctx"][::std::mem::offset_of!(ecs_query_t, ctx) - 2768usize];
    ["Offset of field: ecs_query_t::binding_ctx"]
        [::std::mem::offset_of!(ecs_query_t, binding_ctx) - 2776usize];
    ["Offset of field: ecs_query_t::entity"]
        [::std::mem::offset_of!(ecs_query_t, entity) - 2784usize];
    ["Offset of field: ecs_query_t::real_world"]
        [::std::mem::offset_of!(ecs_query_t, real_world) - 2792usize];
    ["Offset of field: ecs_query_t::world"][::std::mem::offset_of!(ecs_query_t, world) - 2800usize];
    ["Offset of field: ecs_query_t::eval_count"]
        [::std::mem::offset_of!(ecs_query_t, eval_count) - 2808usize];
};
#[doc = " An observer reacts to events matching a query.\n Created with ecs_observer_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observer_t {
    #[doc = "< Object header"]
    pub hdr: ecs_header_t,
    #[doc = "< Observer query"]
    pub query: *mut ecs_query_t,
    #[doc = " Observer events"]
    pub events: [ecs_entity_t; 8usize],
    #[doc = "< Number of events"]
    pub event_count: i32,
    #[doc = "< See ecs_observer_desc_t::callback"]
    pub callback: ecs_iter_action_t,
    #[doc = "< See ecs_observer_desc_t::run"]
    pub run: ecs_run_action_t,
    #[doc = "< Observer context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback language binding context"]
    pub callback_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Run language binding context"]
    pub run_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = "< Callback to free callback_ctx"]
    pub callback_ctx_free: ecs_ctx_free_t,
    #[doc = "< Callback to free run_ctx"]
    pub run_ctx_free: ecs_ctx_free_t,
    #[doc = "< Observable for observer"]
    pub observable: *mut ecs_observable_t,
    #[doc = "< The world"]
    pub world: *mut ecs_world_t,
    #[doc = "< Entity associated with observer"]
    pub entity: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_observer_t"][::std::mem::size_of::<ecs_observer_t>() - 192usize];
    ["Alignment of ecs_observer_t"][::std::mem::align_of::<ecs_observer_t>() - 8usize];
    ["Offset of field: ecs_observer_t::hdr"][::std::mem::offset_of!(ecs_observer_t, hdr) - 0usize];
    ["Offset of field: ecs_observer_t::query"]
        [::std::mem::offset_of!(ecs_observer_t, query) - 24usize];
    ["Offset of field: ecs_observer_t::events"]
        [::std::mem::offset_of!(ecs_observer_t, events) - 32usize];
    ["Offset of field: ecs_observer_t::event_count"]
        [::std::mem::offset_of!(ecs_observer_t, event_count) - 96usize];
    ["Offset of field: ecs_observer_t::callback"]
        [::std::mem::offset_of!(ecs_observer_t, callback) - 104usize];
    ["Offset of field: ecs_observer_t::run"]
        [::std::mem::offset_of!(ecs_observer_t, run) - 112usize];
    ["Offset of field: ecs_observer_t::ctx"]
        [::std::mem::offset_of!(ecs_observer_t, ctx) - 120usize];
    ["Offset of field: ecs_observer_t::callback_ctx"]
        [::std::mem::offset_of!(ecs_observer_t, callback_ctx) - 128usize];
    ["Offset of field: ecs_observer_t::run_ctx"]
        [::std::mem::offset_of!(ecs_observer_t, run_ctx) - 136usize];
    ["Offset of field: ecs_observer_t::ctx_free"]
        [::std::mem::offset_of!(ecs_observer_t, ctx_free) - 144usize];
    ["Offset of field: ecs_observer_t::callback_ctx_free"]
        [::std::mem::offset_of!(ecs_observer_t, callback_ctx_free) - 152usize];
    ["Offset of field: ecs_observer_t::run_ctx_free"]
        [::std::mem::offset_of!(ecs_observer_t, run_ctx_free) - 160usize];
    ["Offset of field: ecs_observer_t::observable"]
        [::std::mem::offset_of!(ecs_observer_t, observable) - 168usize];
    ["Offset of field: ecs_observer_t::world"]
        [::std::mem::offset_of!(ecs_observer_t, world) - 176usize];
    ["Offset of field: ecs_observer_t::entity"]
        [::std::mem::offset_of!(ecs_observer_t, entity) - 184usize];
};
#[doc = " Type that contains component lifecycle callbacks.\n\n @ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_hooks_t {
    #[doc = "< ctor"]
    pub ctor: ecs_xtor_t,
    #[doc = "< dtor"]
    pub dtor: ecs_xtor_t,
    #[doc = "< copy assignment"]
    pub copy: ecs_copy_t,
    #[doc = "< move assignment"]
    pub move_: ecs_move_t,
    #[doc = " Ctor + copy"]
    pub copy_ctor: ecs_copy_t,
    #[doc = " Ctor + move"]
    pub move_ctor: ecs_move_t,
    #[doc = " Ctor + move + dtor (or move_ctor + dtor).\n This combination is typically used when a component is moved from one\n location to a new location, like when it is moved to a new table. If\n not set explicitly it will be derived from other callbacks."]
    pub ctor_move_dtor: ecs_move_t,
    #[doc = " Move + dtor.\n This combination is typically used when a component is moved from one\n location to an existing location, like what happens during a remove. If\n not set explicitly it will be derived from other callbacks."]
    pub move_dtor: ecs_move_t,
    #[doc = " Callback that is invoked when an instance of a component is added. This\n callback is invoked before triggers are invoked."]
    pub on_add: ecs_iter_action_t,
    #[doc = " Callback that is invoked when an instance of the component is set. This\n callback is invoked before triggers are invoked, and enable the component\n to respond to changes on itself before others can."]
    pub on_set: ecs_iter_action_t,
    #[doc = " Callback that is invoked when an instance of the component is removed.\n This callback is invoked after the triggers are invoked, and before the\n destructor is invoked."]
    pub on_remove: ecs_iter_action_t,
    #[doc = "< User defined context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Language binding context"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = "< Callback to free binding_ctx"]
    pub binding_ctx_free: ecs_ctx_free_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_type_hooks_t"][::std::mem::size_of::<ecs_type_hooks_t>() - 120usize];
    ["Alignment of ecs_type_hooks_t"][::std::mem::align_of::<ecs_type_hooks_t>() - 8usize];
    ["Offset of field: ecs_type_hooks_t::ctor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, ctor) - 0usize];
    ["Offset of field: ecs_type_hooks_t::dtor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, dtor) - 8usize];
    ["Offset of field: ecs_type_hooks_t::copy"]
        [::std::mem::offset_of!(ecs_type_hooks_t, copy) - 16usize];
    ["Offset of field: ecs_type_hooks_t::move_"]
        [::std::mem::offset_of!(ecs_type_hooks_t, move_) - 24usize];
    ["Offset of field: ecs_type_hooks_t::copy_ctor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, copy_ctor) - 32usize];
    ["Offset of field: ecs_type_hooks_t::move_ctor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, move_ctor) - 40usize];
    ["Offset of field: ecs_type_hooks_t::ctor_move_dtor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, ctor_move_dtor) - 48usize];
    ["Offset of field: ecs_type_hooks_t::move_dtor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, move_dtor) - 56usize];
    ["Offset of field: ecs_type_hooks_t::on_add"]
        [::std::mem::offset_of!(ecs_type_hooks_t, on_add) - 64usize];
    ["Offset of field: ecs_type_hooks_t::on_set"]
        [::std::mem::offset_of!(ecs_type_hooks_t, on_set) - 72usize];
    ["Offset of field: ecs_type_hooks_t::on_remove"]
        [::std::mem::offset_of!(ecs_type_hooks_t, on_remove) - 80usize];
    ["Offset of field: ecs_type_hooks_t::ctx"]
        [::std::mem::offset_of!(ecs_type_hooks_t, ctx) - 88usize];
    ["Offset of field: ecs_type_hooks_t::binding_ctx"]
        [::std::mem::offset_of!(ecs_type_hooks_t, binding_ctx) - 96usize];
    ["Offset of field: ecs_type_hooks_t::ctx_free"]
        [::std::mem::offset_of!(ecs_type_hooks_t, ctx_free) - 104usize];
    ["Offset of field: ecs_type_hooks_t::binding_ctx_free"]
        [::std::mem::offset_of!(ecs_type_hooks_t, binding_ctx_free) - 112usize];
};
#[doc = " Type that contains component information (passed to ctors/dtors/...)\n\n @ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_info_t {
    #[doc = "< Size of type"]
    pub size: ecs_size_t,
    #[doc = "< Alignment of type"]
    pub alignment: ecs_size_t,
    #[doc = "< Type hooks"]
    pub hooks: ecs_type_hooks_t,
    #[doc = "< Handle to component (do not set)"]
    pub component: ecs_entity_t,
    #[doc = "< Type name."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_type_info_t"][::std::mem::size_of::<ecs_type_info_t>() - 144usize];
    ["Alignment of ecs_type_info_t"][::std::mem::align_of::<ecs_type_info_t>() - 8usize];
    ["Offset of field: ecs_type_info_t::size"]
        [::std::mem::offset_of!(ecs_type_info_t, size) - 0usize];
    ["Offset of field: ecs_type_info_t::alignment"]
        [::std::mem::offset_of!(ecs_type_info_t, alignment) - 4usize];
    ["Offset of field: ecs_type_info_t::hooks"]
        [::std::mem::offset_of!(ecs_type_info_t, hooks) - 8usize];
    ["Offset of field: ecs_type_info_t::component"]
        [::std::mem::offset_of!(ecs_type_info_t, component) - 128usize];
    ["Offset of field: ecs_type_info_t::name"]
        [::std::mem::offset_of!(ecs_type_info_t, name) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_data_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_cache_table_match_t {
    _unused: [u8; 0],
}
#[doc = " All observers for a specific event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_record_t {
    pub any: *mut ecs_event_id_record_t,
    pub wildcard: *mut ecs_event_id_record_t,
    pub wildcard_pair: *mut ecs_event_id_record_t,
    pub event_ids: ecs_map_t,
    pub event: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_event_record_t"][::std::mem::size_of::<ecs_event_record_t>() - 72usize];
    ["Alignment of ecs_event_record_t"][::std::mem::align_of::<ecs_event_record_t>() - 8usize];
    ["Offset of field: ecs_event_record_t::any"]
        [::std::mem::offset_of!(ecs_event_record_t, any) - 0usize];
    ["Offset of field: ecs_event_record_t::wildcard"]
        [::std::mem::offset_of!(ecs_event_record_t, wildcard) - 8usize];
    ["Offset of field: ecs_event_record_t::wildcard_pair"]
        [::std::mem::offset_of!(ecs_event_record_t, wildcard_pair) - 16usize];
    ["Offset of field: ecs_event_record_t::event_ids"]
        [::std::mem::offset_of!(ecs_event_record_t, event_ids) - 24usize];
    ["Offset of field: ecs_event_record_t::event"]
        [::std::mem::offset_of!(ecs_event_record_t, event) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observable_t {
    pub on_add: ecs_event_record_t,
    pub on_remove: ecs_event_record_t,
    pub on_set: ecs_event_record_t,
    pub on_wildcard: ecs_event_record_t,
    pub events: ecs_sparse_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_observable_t"][::std::mem::size_of::<ecs_observable_t>() - 352usize];
    ["Alignment of ecs_observable_t"][::std::mem::align_of::<ecs_observable_t>() - 8usize];
    ["Offset of field: ecs_observable_t::on_add"]
        [::std::mem::offset_of!(ecs_observable_t, on_add) - 0usize];
    ["Offset of field: ecs_observable_t::on_remove"]
        [::std::mem::offset_of!(ecs_observable_t, on_remove) - 72usize];
    ["Offset of field: ecs_observable_t::on_set"]
        [::std::mem::offset_of!(ecs_observable_t, on_set) - 144usize];
    ["Offset of field: ecs_observable_t::on_wildcard"]
        [::std::mem::offset_of!(ecs_observable_t, on_wildcard) - 216usize];
    ["Offset of field: ecs_observable_t::events"]
        [::std::mem::offset_of!(ecs_observable_t, events) - 288usize];
};
#[doc = " Range in table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_range_t {
    pub table: *mut ecs_table_t,
    pub offset: i32,
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_table_range_t"][::std::mem::size_of::<ecs_table_range_t>() - 16usize];
    ["Alignment of ecs_table_range_t"][::std::mem::align_of::<ecs_table_range_t>() - 8usize];
    ["Offset of field: ecs_table_range_t::table"]
        [::std::mem::offset_of!(ecs_table_range_t, table) - 0usize];
    ["Offset of field: ecs_table_range_t::offset"]
        [::std::mem::offset_of!(ecs_table_range_t, offset) - 8usize];
    ["Offset of field: ecs_table_range_t::count"]
        [::std::mem::offset_of!(ecs_table_range_t, count) - 12usize];
};
#[doc = " Value of query variable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_var_t {
    pub range: ecs_table_range_t,
    pub entity: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_var_t"][::std::mem::size_of::<ecs_var_t>() - 24usize];
    ["Alignment of ecs_var_t"][::std::mem::align_of::<ecs_var_t>() - 8usize];
    ["Offset of field: ecs_var_t::range"][::std::mem::offset_of!(ecs_var_t, range) - 0usize];
    ["Offset of field: ecs_var_t::entity"][::std::mem::offset_of!(ecs_var_t, entity) - 16usize];
};
#[doc = " Cached reference."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_ref_t {
    pub entity: ecs_entity_t,
    pub id: ecs_entity_t,
    pub table_id: u64,
    pub tr: *mut ecs_table_record_t,
    pub record: *mut ecs_record_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_ref_t"][::std::mem::size_of::<ecs_ref_t>() - 40usize];
    ["Alignment of ecs_ref_t"][::std::mem::align_of::<ecs_ref_t>() - 8usize];
    ["Offset of field: ecs_ref_t::entity"][::std::mem::offset_of!(ecs_ref_t, entity) - 0usize];
    ["Offset of field: ecs_ref_t::id"][::std::mem::offset_of!(ecs_ref_t, id) - 8usize];
    ["Offset of field: ecs_ref_t::table_id"][::std::mem::offset_of!(ecs_ref_t, table_id) - 16usize];
    ["Offset of field: ecs_ref_t::tr"][::std::mem::offset_of!(ecs_ref_t, tr) - 24usize];
    ["Offset of field: ecs_ref_t::record"][::std::mem::offset_of!(ecs_ref_t, record) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_page_iter_t {
    pub offset: i32,
    pub limit: i32,
    pub remaining: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_page_iter_t"][::std::mem::size_of::<ecs_page_iter_t>() - 12usize];
    ["Alignment of ecs_page_iter_t"][::std::mem::align_of::<ecs_page_iter_t>() - 4usize];
    ["Offset of field: ecs_page_iter_t::offset"]
        [::std::mem::offset_of!(ecs_page_iter_t, offset) - 0usize];
    ["Offset of field: ecs_page_iter_t::limit"]
        [::std::mem::offset_of!(ecs_page_iter_t, limit) - 4usize];
    ["Offset of field: ecs_page_iter_t::remaining"]
        [::std::mem::offset_of!(ecs_page_iter_t, remaining) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_worker_iter_t {
    pub index: i32,
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_worker_iter_t"][::std::mem::size_of::<ecs_worker_iter_t>() - 8usize];
    ["Alignment of ecs_worker_iter_t"][::std::mem::align_of::<ecs_worker_iter_t>() - 4usize];
    ["Offset of field: ecs_worker_iter_t::index"]
        [::std::mem::offset_of!(ecs_worker_iter_t, index) - 0usize];
    ["Offset of field: ecs_worker_iter_t::count"]
        [::std::mem::offset_of!(ecs_worker_iter_t, count) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_cache_iter_t {
    pub cur: *mut ecs_table_cache_hdr_t,
    pub next: *mut ecs_table_cache_hdr_t,
    pub next_list: *mut ecs_table_cache_hdr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_table_cache_iter_t"][::std::mem::size_of::<ecs_table_cache_iter_t>() - 24usize];
    ["Alignment of ecs_table_cache_iter_t"]
        [::std::mem::align_of::<ecs_table_cache_iter_t>() - 8usize];
    ["Offset of field: ecs_table_cache_iter_t::cur"]
        [::std::mem::offset_of!(ecs_table_cache_iter_t, cur) - 0usize];
    ["Offset of field: ecs_table_cache_iter_t::next"]
        [::std::mem::offset_of!(ecs_table_cache_iter_t, next) - 8usize];
    ["Offset of field: ecs_table_cache_iter_t::next_list"]
        [::std::mem::offset_of!(ecs_table_cache_iter_t, next_list) - 16usize];
};
#[doc = " Each iterator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_each_iter_t {
    pub it: ecs_table_cache_iter_t,
    pub ids: ecs_id_t,
    pub sources: ecs_entity_t,
    pub sizes: ecs_size_t,
    pub columns: i32,
    pub trs: *const ecs_table_record_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_each_iter_t"][::std::mem::size_of::<ecs_each_iter_t>() - 56usize];
    ["Alignment of ecs_each_iter_t"][::std::mem::align_of::<ecs_each_iter_t>() - 8usize];
    ["Offset of field: ecs_each_iter_t::it"][::std::mem::offset_of!(ecs_each_iter_t, it) - 0usize];
    ["Offset of field: ecs_each_iter_t::ids"]
        [::std::mem::offset_of!(ecs_each_iter_t, ids) - 24usize];
    ["Offset of field: ecs_each_iter_t::sources"]
        [::std::mem::offset_of!(ecs_each_iter_t, sources) - 32usize];
    ["Offset of field: ecs_each_iter_t::sizes"]
        [::std::mem::offset_of!(ecs_each_iter_t, sizes) - 40usize];
    ["Offset of field: ecs_each_iter_t::columns"]
        [::std::mem::offset_of!(ecs_each_iter_t, columns) - 44usize];
    ["Offset of field: ecs_each_iter_t::trs"]
        [::std::mem::offset_of!(ecs_each_iter_t, trs) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_op_profile_t {
    pub count: [i32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_op_profile_t"][::std::mem::size_of::<ecs_query_op_profile_t>() - 8usize];
    ["Alignment of ecs_query_op_profile_t"]
        [::std::mem::align_of::<ecs_query_op_profile_t>() - 4usize];
    ["Offset of field: ecs_query_op_profile_t::count"]
        [::std::mem::offset_of!(ecs_query_op_profile_t, count) - 0usize];
};
#[doc = " Query iterator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_iter_t {
    pub query: *const ecs_query_t,
    pub vars: *mut ecs_var_t,
    pub query_vars: *mut ecs_query_var_t,
    pub ops: *mut ecs_query_op_t,
    pub op_ctx: *mut ecs_query_op_ctx_t,
    pub node: *mut ecs_query_cache_table_match_t,
    pub prev: *mut ecs_query_cache_table_match_t,
    pub last: *mut ecs_query_cache_table_match_t,
    pub written: *mut u64,
    pub skip_count: i32,
    pub profile: *mut ecs_query_op_profile_t,
    pub op: i16,
    pub sp: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_iter_t"][::std::mem::size_of::<ecs_query_iter_t>() - 96usize];
    ["Alignment of ecs_query_iter_t"][::std::mem::align_of::<ecs_query_iter_t>() - 8usize];
    ["Offset of field: ecs_query_iter_t::query"]
        [::std::mem::offset_of!(ecs_query_iter_t, query) - 0usize];
    ["Offset of field: ecs_query_iter_t::vars"]
        [::std::mem::offset_of!(ecs_query_iter_t, vars) - 8usize];
    ["Offset of field: ecs_query_iter_t::query_vars"]
        [::std::mem::offset_of!(ecs_query_iter_t, query_vars) - 16usize];
    ["Offset of field: ecs_query_iter_t::ops"]
        [::std::mem::offset_of!(ecs_query_iter_t, ops) - 24usize];
    ["Offset of field: ecs_query_iter_t::op_ctx"]
        [::std::mem::offset_of!(ecs_query_iter_t, op_ctx) - 32usize];
    ["Offset of field: ecs_query_iter_t::node"]
        [::std::mem::offset_of!(ecs_query_iter_t, node) - 40usize];
    ["Offset of field: ecs_query_iter_t::prev"]
        [::std::mem::offset_of!(ecs_query_iter_t, prev) - 48usize];
    ["Offset of field: ecs_query_iter_t::last"]
        [::std::mem::offset_of!(ecs_query_iter_t, last) - 56usize];
    ["Offset of field: ecs_query_iter_t::written"]
        [::std::mem::offset_of!(ecs_query_iter_t, written) - 64usize];
    ["Offset of field: ecs_query_iter_t::skip_count"]
        [::std::mem::offset_of!(ecs_query_iter_t, skip_count) - 72usize];
    ["Offset of field: ecs_query_iter_t::profile"]
        [::std::mem::offset_of!(ecs_query_iter_t, profile) - 80usize];
    ["Offset of field: ecs_query_iter_t::op"]
        [::std::mem::offset_of!(ecs_query_iter_t, op) - 88usize];
    ["Offset of field: ecs_query_iter_t::sp"]
        [::std::mem::offset_of!(ecs_query_iter_t, sp) - 90usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_iter_cache_t {
    pub stack_cursor: *mut ecs_stack_cursor_t,
    pub used: ecs_flags8_t,
    pub allocated: ecs_flags8_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_cache_t"][::std::mem::size_of::<ecs_iter_cache_t>() - 16usize];
    ["Alignment of ecs_iter_cache_t"][::std::mem::align_of::<ecs_iter_cache_t>() - 8usize];
    ["Offset of field: ecs_iter_cache_t::stack_cursor"]
        [::std::mem::offset_of!(ecs_iter_cache_t, stack_cursor) - 0usize];
    ["Offset of field: ecs_iter_cache_t::used"]
        [::std::mem::offset_of!(ecs_iter_cache_t, used) - 8usize];
    ["Offset of field: ecs_iter_cache_t::allocated"]
        [::std::mem::offset_of!(ecs_iter_cache_t, allocated) - 9usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_iter_private_t {
    pub iter: ecs_iter_private_t__bindgen_ty_1,
    pub entity_iter: *mut ::std::os::raw::c_void,
    pub cache: ecs_iter_cache_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ecs_iter_private_t__bindgen_ty_1 {
    pub query: ecs_query_iter_t,
    pub page: ecs_page_iter_t,
    pub worker: ecs_worker_iter_t,
    pub each: ecs_each_iter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_private_t__bindgen_ty_1"]
        [::std::mem::size_of::<ecs_iter_private_t__bindgen_ty_1>() - 96usize];
    ["Alignment of ecs_iter_private_t__bindgen_ty_1"]
        [::std::mem::align_of::<ecs_iter_private_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: ecs_iter_private_t__bindgen_ty_1::query"]
        [::std::mem::offset_of!(ecs_iter_private_t__bindgen_ty_1, query) - 0usize];
    ["Offset of field: ecs_iter_private_t__bindgen_ty_1::page"]
        [::std::mem::offset_of!(ecs_iter_private_t__bindgen_ty_1, page) - 0usize];
    ["Offset of field: ecs_iter_private_t__bindgen_ty_1::worker"]
        [::std::mem::offset_of!(ecs_iter_private_t__bindgen_ty_1, worker) - 0usize];
    ["Offset of field: ecs_iter_private_t__bindgen_ty_1::each"]
        [::std::mem::offset_of!(ecs_iter_private_t__bindgen_ty_1, each) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_private_t"][::std::mem::size_of::<ecs_iter_private_t>() - 120usize];
    ["Alignment of ecs_iter_private_t"][::std::mem::align_of::<ecs_iter_private_t>() - 8usize];
    ["Offset of field: ecs_iter_private_t::iter"]
        [::std::mem::offset_of!(ecs_iter_private_t, iter) - 0usize];
    ["Offset of field: ecs_iter_private_t::entity_iter"]
        [::std::mem::offset_of!(ecs_iter_private_t, entity_iter) - 96usize];
    ["Offset of field: ecs_iter_private_t::cache"]
        [::std::mem::offset_of!(ecs_iter_private_t, cache) - 104usize];
};
extern "C" {
    pub fn flecs_module_path_from_c(
        c_name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_identifier_is_0(id: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn flecs_default_ctor(
        ptr: *mut ::std::os::raw::c_void,
        count: i32,
        ctx: *const ecs_type_info_t,
    );
}
extern "C" {
    pub fn flecs_vasprintf(
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_asprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write an escaped character.\n Write a character to an output string, insert escape character if necessary.\n\n @param out The string to write the character to.\n @param in The input character.\n @param delimiter The delimiter used (for example '\"')\n @return Pointer to the character after the last one written."]
    pub fn flecs_chresc(
        out: *mut ::std::os::raw::c_char,
        in_: ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse an escaped character.\n Parse a character with a potential escape sequence.\n\n @param in Pointer to character in input string.\n @param out Output string.\n @return Pointer to the character after the last one read."]
    pub fn flecs_chrparse(
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write an escaped string.\n Write an input string to an output string, escape characters where necessary.\n To determine the size of the output string, call the operation with a NULL\n argument for 'out', and use the returned size to allocate a string that is\n large enough.\n\n @param out Pointer to output string (must be).\n @param size Maximum number of characters written to output.\n @param delimiter The delimiter used (for example '\"').\n @param in The input string.\n @return The number of characters that (would) have been written."]
    pub fn flecs_stresc(
        out: *mut ::std::os::raw::c_char,
        size: ecs_size_t,
        delimiter: ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
    ) -> ecs_size_t;
}
extern "C" {
    #[doc = " Return escaped string.\n Return escaped version of input string. Same as flecs_stresc(), but returns an\n allocated string of the right size.\n\n @param delimiter The delimiter used (for example '\"').\n @param in The input string.\n @return Escaped string."]
    pub fn flecs_astresc(
        delimiter: ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Skip whitespace and newline characters.\n This function skips whitespace characters.\n\n @param ptr Pointer to (potential) whitespaces to skip.\n @return Pointer to the next non-whitespace character."]
    pub fn flecs_parse_ws_eol(ptr: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse digit.\n This function will parse until the first non-digit character is found. The\n provided expression must contain at least one digit character.\n\n @param ptr The expression to parse.\n @param token The output buffer.\n @return Pointer to the first non-digit character."]
    pub fn flecs_parse_digit(
        ptr: *const ::std::os::raw::c_char,
        token: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_to_snake_case(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_table_observed_count(table: *const ecs_table_t) -> i32;
}
extern "C" {
    pub fn flecs_dump_backtrace(stream: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_suspend_readonly_state_t {
    pub is_readonly: bool,
    pub is_deferred: bool,
    pub defer_count: i32,
    pub scope: ecs_entity_t,
    pub with: ecs_entity_t,
    pub commands: ecs_vec_t,
    pub defer_stack: ecs_stack_t,
    pub stage: *mut ecs_stage_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_suspend_readonly_state_t"]
        [::std::mem::size_of::<ecs_suspend_readonly_state_t>() - 96usize];
    ["Alignment of ecs_suspend_readonly_state_t"]
        [::std::mem::align_of::<ecs_suspend_readonly_state_t>() - 8usize];
    ["Offset of field: ecs_suspend_readonly_state_t::is_readonly"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, is_readonly) - 0usize];
    ["Offset of field: ecs_suspend_readonly_state_t::is_deferred"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, is_deferred) - 1usize];
    ["Offset of field: ecs_suspend_readonly_state_t::defer_count"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, defer_count) - 4usize];
    ["Offset of field: ecs_suspend_readonly_state_t::scope"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, scope) - 8usize];
    ["Offset of field: ecs_suspend_readonly_state_t::with"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, with) - 16usize];
    ["Offset of field: ecs_suspend_readonly_state_t::commands"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, commands) - 24usize];
    ["Offset of field: ecs_suspend_readonly_state_t::defer_stack"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, defer_stack) - 40usize];
    ["Offset of field: ecs_suspend_readonly_state_t::stage"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, stage) - 88usize];
};
extern "C" {
    pub fn flecs_suspend_readonly(
        world: *const ecs_world_t,
        state: *mut ecs_suspend_readonly_state_t,
    ) -> *mut ecs_world_t;
}
extern "C" {
    pub fn flecs_resume_readonly(world: *mut ecs_world_t, state: *mut ecs_suspend_readonly_state_t);
}
extern "C" {
    pub fn flecs_poly_claim_(poly: *mut ecs_poly_t) -> i32;
}
extern "C" {
    pub fn flecs_poly_release_(poly: *mut ecs_poly_t) -> i32;
}
extern "C" {
    pub fn flecs_poly_refcount(poly: *mut ecs_poly_t) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_hm_bucket_t {
    pub keys: ecs_vec_t,
    pub values: ecs_vec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_hm_bucket_t"][::std::mem::size_of::<ecs_hm_bucket_t>() - 32usize];
    ["Alignment of ecs_hm_bucket_t"][::std::mem::align_of::<ecs_hm_bucket_t>() - 8usize];
    ["Offset of field: ecs_hm_bucket_t::keys"]
        [::std::mem::offset_of!(ecs_hm_bucket_t, keys) - 0usize];
    ["Offset of field: ecs_hm_bucket_t::values"]
        [::std::mem::offset_of!(ecs_hm_bucket_t, values) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_hashmap_t {
    pub hash: ecs_hash_value_action_t,
    pub compare: ecs_compare_action_t,
    pub key_size: ecs_size_t,
    pub value_size: ecs_size_t,
    pub hashmap_allocator: *mut ecs_block_allocator_t,
    pub bucket_allocator: ecs_block_allocator_t,
    pub impl_: ecs_map_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_hashmap_t"][::std::mem::size_of::<ecs_hashmap_t>() - 120usize];
    ["Alignment of ecs_hashmap_t"][::std::mem::align_of::<ecs_hashmap_t>() - 8usize];
    ["Offset of field: ecs_hashmap_t::hash"][::std::mem::offset_of!(ecs_hashmap_t, hash) - 0usize];
    ["Offset of field: ecs_hashmap_t::compare"]
        [::std::mem::offset_of!(ecs_hashmap_t, compare) - 8usize];
    ["Offset of field: ecs_hashmap_t::key_size"]
        [::std::mem::offset_of!(ecs_hashmap_t, key_size) - 16usize];
    ["Offset of field: ecs_hashmap_t::value_size"]
        [::std::mem::offset_of!(ecs_hashmap_t, value_size) - 20usize];
    ["Offset of field: ecs_hashmap_t::hashmap_allocator"]
        [::std::mem::offset_of!(ecs_hashmap_t, hashmap_allocator) - 24usize];
    ["Offset of field: ecs_hashmap_t::bucket_allocator"]
        [::std::mem::offset_of!(ecs_hashmap_t, bucket_allocator) - 32usize];
    ["Offset of field: ecs_hashmap_t::impl_"]
        [::std::mem::offset_of!(ecs_hashmap_t, impl_) - 80usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flecs_hashmap_iter_t {
    pub it: ecs_map_iter_t,
    pub bucket: *mut ecs_hm_bucket_t,
    pub index: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flecs_hashmap_iter_t"][::std::mem::size_of::<flecs_hashmap_iter_t>() - 48usize];
    ["Alignment of flecs_hashmap_iter_t"][::std::mem::align_of::<flecs_hashmap_iter_t>() - 8usize];
    ["Offset of field: flecs_hashmap_iter_t::it"]
        [::std::mem::offset_of!(flecs_hashmap_iter_t, it) - 0usize];
    ["Offset of field: flecs_hashmap_iter_t::bucket"]
        [::std::mem::offset_of!(flecs_hashmap_iter_t, bucket) - 32usize];
    ["Offset of field: flecs_hashmap_iter_t::index"]
        [::std::mem::offset_of!(flecs_hashmap_iter_t, index) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flecs_hashmap_result_t {
    pub key: *mut ::std::os::raw::c_void,
    pub value: *mut ::std::os::raw::c_void,
    pub hash: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flecs_hashmap_result_t"][::std::mem::size_of::<flecs_hashmap_result_t>() - 24usize];
    ["Alignment of flecs_hashmap_result_t"]
        [::std::mem::align_of::<flecs_hashmap_result_t>() - 8usize];
    ["Offset of field: flecs_hashmap_result_t::key"]
        [::std::mem::offset_of!(flecs_hashmap_result_t, key) - 0usize];
    ["Offset of field: flecs_hashmap_result_t::value"]
        [::std::mem::offset_of!(flecs_hashmap_result_t, value) - 8usize];
    ["Offset of field: flecs_hashmap_result_t::hash"]
        [::std::mem::offset_of!(flecs_hashmap_result_t, hash) - 16usize];
};
extern "C" {
    pub fn flecs_hashmap_init_(
        hm: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        value_size: ecs_size_t,
        hash: ecs_hash_value_action_t,
        compare: ecs_compare_action_t,
        allocator: *mut ecs_allocator_t,
    );
}
extern "C" {
    pub fn flecs_hashmap_fini(map: *mut ecs_hashmap_t);
}
extern "C" {
    pub fn flecs_hashmap_get_(
        map: *const ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_hashmap_ensure_(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> flecs_hashmap_result_t;
}
extern "C" {
    pub fn flecs_hashmap_set_(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *mut ::std::os::raw::c_void,
        value_size: ecs_size_t,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn flecs_hashmap_remove_(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    );
}
extern "C" {
    pub fn flecs_hashmap_remove_w_hash_(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
        hash: u64,
    );
}
extern "C" {
    pub fn flecs_hashmap_get_bucket(map: *const ecs_hashmap_t, hash: u64) -> *mut ecs_hm_bucket_t;
}
extern "C" {
    pub fn flecs_hm_bucket_remove(
        map: *mut ecs_hashmap_t,
        bucket: *mut ecs_hm_bucket_t,
        hash: u64,
        index: i32,
    );
}
extern "C" {
    pub fn flecs_hashmap_copy(dst: *mut ecs_hashmap_t, src: *const ecs_hashmap_t);
}
extern "C" {
    pub fn flecs_hashmap_iter(map: *mut ecs_hashmap_t) -> flecs_hashmap_iter_t;
}
extern "C" {
    pub fn flecs_hashmap_next_(
        it: *mut flecs_hashmap_iter_t,
        key_size: ecs_size_t,
        key_out: *mut ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Utility to hold a value of a dynamic type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_value_t {
    #[doc = "< Type of value."]
    pub type_: ecs_entity_t,
    #[doc = "< Pointer to value."]
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_value_t"][::std::mem::size_of::<ecs_value_t>() - 16usize];
    ["Alignment of ecs_value_t"][::std::mem::align_of::<ecs_value_t>() - 8usize];
    ["Offset of field: ecs_value_t::type_"][::std::mem::offset_of!(ecs_value_t, type_) - 0usize];
    ["Offset of field: ecs_value_t::ptr"][::std::mem::offset_of!(ecs_value_t, ptr) - 8usize];
};
#[doc = " Used with ecs_entity_init().\n\n @ingroup entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_entity_desc_t {
    #[doc = "< Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = "< Set to modify existing entity (optional)"]
    pub id: ecs_entity_t,
    #[doc = "< Parent entity."]
    pub parent: ecs_entity_t,
    #[doc = "< Name of the entity. If no entity is provided, an\n entity with this name will be looked up first. When\n an entity is provided, the name will be verified\n with the existing entity."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Optional custom separator for hierarchical names.\n Leave to NULL for default ('.') separator. Set to\n an empty string to prevent tokenization of name."]
    pub sep: *const ::std::os::raw::c_char,
    #[doc = "< Optional, used for identifiers relative to root"]
    pub root_sep: *const ::std::os::raw::c_char,
    #[doc = "< Optional entity symbol. A symbol is an unscoped\n identifier that can be used to lookup an entity. The\n primary use case for this is to associate the entity\n with a language identifier, such as a type or\n function name, where these identifiers differ from\n the name they are registered with in flecs. For\n example, C type \"EcsPosition\" might be registered\n as \"flecs.components.transform.Position\", with the\n symbol set to \"EcsPosition\"."]
    pub symbol: *const ::std::os::raw::c_char,
    #[doc = "< When set to true, a low id (typically reserved for\n components) will be used to create the entity, if\n no id is specified."]
    pub use_low_id: bool,
    #[doc = " 0-terminated array of ids to add to the entity."]
    pub add: *const ecs_id_t,
    #[doc = " 0-terminated array of values to set on the entity."]
    pub set: *const ecs_value_t,
    #[doc = " String expression with components to add"]
    pub add_expr: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_entity_desc_t"][::std::mem::size_of::<ecs_entity_desc_t>() - 88usize];
    ["Alignment of ecs_entity_desc_t"][::std::mem::align_of::<ecs_entity_desc_t>() - 8usize];
    ["Offset of field: ecs_entity_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_entity_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_entity_desc_t::id"]
        [::std::mem::offset_of!(ecs_entity_desc_t, id) - 8usize];
    ["Offset of field: ecs_entity_desc_t::parent"]
        [::std::mem::offset_of!(ecs_entity_desc_t, parent) - 16usize];
    ["Offset of field: ecs_entity_desc_t::name"]
        [::std::mem::offset_of!(ecs_entity_desc_t, name) - 24usize];
    ["Offset of field: ecs_entity_desc_t::sep"]
        [::std::mem::offset_of!(ecs_entity_desc_t, sep) - 32usize];
    ["Offset of field: ecs_entity_desc_t::root_sep"]
        [::std::mem::offset_of!(ecs_entity_desc_t, root_sep) - 40usize];
    ["Offset of field: ecs_entity_desc_t::symbol"]
        [::std::mem::offset_of!(ecs_entity_desc_t, symbol) - 48usize];
    ["Offset of field: ecs_entity_desc_t::use_low_id"]
        [::std::mem::offset_of!(ecs_entity_desc_t, use_low_id) - 56usize];
    ["Offset of field: ecs_entity_desc_t::add"]
        [::std::mem::offset_of!(ecs_entity_desc_t, add) - 64usize];
    ["Offset of field: ecs_entity_desc_t::set"]
        [::std::mem::offset_of!(ecs_entity_desc_t, set) - 72usize];
    ["Offset of field: ecs_entity_desc_t::add_expr"]
        [::std::mem::offset_of!(ecs_entity_desc_t, add_expr) - 80usize];
};
#[doc = " Used with ecs_bulk_init().\n\n @ingroup entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bulk_desc_t {
    #[doc = "< Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = "< Entities to bulk insert. Entity ids provided by\n the application must be empty (cannot\n have components). If no entity ids are provided, the\n operation will create 'count' new entities."]
    pub entities: *mut ecs_entity_t,
    #[doc = "< Number of entities to create/populate"]
    pub count: i32,
    #[doc = "< Ids to create the entities with"]
    pub ids: [ecs_id_t; 32usize],
    #[doc = "< Array with component data to insert. Each element in\n the array must correspond with an element in the ids\n array. If an element in the ids array is a tag, the\n data array must contain a NULL. An element may be\n set to NULL for a component, in which case the\n component will not be set by the operation."]
    pub data: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Table to insert the entities into. Should not be set\n at the same time as ids. When 'table' is set at the\n same time as 'data', the elements in the data array\n must correspond with the ids in the table's type."]
    pub table: *mut ecs_table_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_bulk_desc_t"][::std::mem::size_of::<ecs_bulk_desc_t>() - 296usize];
    ["Alignment of ecs_bulk_desc_t"][::std::mem::align_of::<ecs_bulk_desc_t>() - 8usize];
    ["Offset of field: ecs_bulk_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_bulk_desc_t::entities"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, entities) - 8usize];
    ["Offset of field: ecs_bulk_desc_t::count"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, count) - 16usize];
    ["Offset of field: ecs_bulk_desc_t::ids"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, ids) - 24usize];
    ["Offset of field: ecs_bulk_desc_t::data"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, data) - 280usize];
    ["Offset of field: ecs_bulk_desc_t::table"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, table) - 288usize];
};
#[doc = " Used with ecs_component_init().\n\n @ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_component_desc_t {
    #[doc = "< Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = " Existing entity to associate with observer (optional)"]
    pub entity: ecs_entity_t,
    #[doc = " Parameters for type (size, hooks, ...)"]
    pub type_: ecs_type_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_component_desc_t"][::std::mem::size_of::<ecs_component_desc_t>() - 160usize];
    ["Alignment of ecs_component_desc_t"][::std::mem::align_of::<ecs_component_desc_t>() - 8usize];
    ["Offset of field: ecs_component_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_component_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_component_desc_t::entity"]
        [::std::mem::offset_of!(ecs_component_desc_t, entity) - 8usize];
    ["Offset of field: ecs_component_desc_t::type_"]
        [::std::mem::offset_of!(ecs_component_desc_t, type_) - 16usize];
};
#[doc = " Iterator.\n Used for iterating queries. The ecs_iter_t type contains all the information\n that is provided by a query, and contains all the state required for the\n iterator code.\n\n Functions that create iterators accept as first argument the world, and as\n second argument the object they iterate. For example:\n\n @code\n ecs_iter_t it = ecs_query_iter(world, q);\n @endcode\n\n When this code is called from a system, it is important to use the world\n provided by its iterator object to ensure thread safety. For example:\n\n @code\n void Collide(ecs_iter_t *it) {\n   ecs_iter_t qit = ecs_query_iter(it->world, Colliders);\n }\n @endcode\n\n An iterator contains resources that need to be released. By default this\n is handled by the last call to next() that returns false. When iteration is\n ended before iteration has completed, an application has to manually call\n ecs_iter_fini() to release the iterator resources:\n\n @code\n ecs_iter_t it = ecs_query_iter(world, q);\n while (ecs_query_next(&it)) {\n   if (cond) {\n     ecs_iter_fini(&it);\n     break;\n   }\n }\n @endcode\n\n @ingroup queries"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_iter_t {
    #[doc = "< The world. Can point to stage when in deferred/readonly mode."]
    pub world: *mut ecs_world_t,
    #[doc = "< Actual world. Never points to a stage."]
    pub real_world: *mut ecs_world_t,
    #[doc = "< Entity identifiers"]
    pub entities: *const ecs_entity_t,
    #[doc = "< Component sizes"]
    pub sizes: *const ecs_size_t,
    #[doc = "< Current table"]
    pub table: *mut ecs_table_t,
    #[doc = "< Prev or next table when adding/removing"]
    pub other_table: *mut ecs_table_t,
    #[doc = "< (Component) ids"]
    pub ids: *mut ecs_id_t,
    #[doc = "< Values of variables (if any)"]
    pub variables: *mut ecs_var_t,
    #[doc = "< Info on where to find field in table"]
    pub trs: *mut *const ecs_table_record_t,
    #[doc = "< Entity on which the id was matched (0 if same as entities)"]
    pub sources: *mut ecs_entity_t,
    #[doc = "< Bitset that marks constrained variables"]
    pub constrained_vars: ecs_flags64_t,
    #[doc = "< Group id for table, if group_by is used"]
    pub group_id: u64,
    #[doc = "< Fields that are set"]
    pub set_fields: ecs_flags32_t,
    #[doc = "< Bitset with fields that aren't component arrays"]
    pub ref_fields: ecs_flags32_t,
    #[doc = "< Fields that must be obtained with field_at"]
    pub row_fields: ecs_flags32_t,
    #[doc = "< Bitset with fields matched through up traversal"]
    pub up_fields: ecs_flags32_t,
    #[doc = "< The system (if applicable)"]
    pub system: ecs_entity_t,
    #[doc = "< The event (if applicable)"]
    pub event: ecs_entity_t,
    #[doc = "< The (component) id for the event"]
    pub event_id: ecs_id_t,
    #[doc = "< Unique event id. Used to dedup observer calls"]
    pub event_cur: i32,
    #[doc = "< Number of fields in iterator"]
    pub field_count: i8,
    #[doc = "< Index of term that emitted an event.\n This field will be set to the 'index' field\n of an observer term."]
    pub term_index: i8,
    #[doc = "< Number of variables for query"]
    pub variable_count: i8,
    #[doc = "< Query being evaluated"]
    pub query: *const ecs_query_t,
    #[doc = "< Names of variables (if any)"]
    pub variable_names: *mut *mut ::std::os::raw::c_char,
    #[doc = "< Param passed to ecs_run"]
    pub param: *mut ::std::os::raw::c_void,
    #[doc = "< System context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< System binding context"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback language binding context"]
    pub callback_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Run language binding context"]
    pub run_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Time elapsed since last frame"]
    pub delta_time: f32,
    #[doc = "< Time elapsed since last system invocation"]
    pub delta_system_time: f32,
    #[doc = "< Offset relative to start of iteration"]
    pub frame_offset: i32,
    #[doc = "< Offset relative to current table"]
    pub offset: i32,
    #[doc = "< Number of entities to iterate"]
    pub count: i32,
    #[doc = "< Iterator flags"]
    pub flags: ecs_flags32_t,
    #[doc = "< When set, system execution is interrupted"]
    pub interrupted_by: ecs_entity_t,
    #[doc = "< Private data"]
    pub priv_: ecs_iter_private_t,
    #[doc = "< Function to progress iterator"]
    pub next: ecs_iter_next_action_t,
    #[doc = "< Callback of system or observer"]
    pub callback: ecs_iter_action_t,
    #[doc = "< Function to cleanup iterator resources"]
    pub fini: ecs_iter_fini_action_t,
    #[doc = "< Optional, allows for creating iterator chains"]
    pub chain_it: *mut ecs_iter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_t"][::std::mem::size_of::<ecs_iter_t>() - 384usize];
    ["Alignment of ecs_iter_t"][::std::mem::align_of::<ecs_iter_t>() - 8usize];
    ["Offset of field: ecs_iter_t::world"][::std::mem::offset_of!(ecs_iter_t, world) - 0usize];
    ["Offset of field: ecs_iter_t::real_world"]
        [::std::mem::offset_of!(ecs_iter_t, real_world) - 8usize];
    ["Offset of field: ecs_iter_t::entities"]
        [::std::mem::offset_of!(ecs_iter_t, entities) - 16usize];
    ["Offset of field: ecs_iter_t::sizes"][::std::mem::offset_of!(ecs_iter_t, sizes) - 24usize];
    ["Offset of field: ecs_iter_t::table"][::std::mem::offset_of!(ecs_iter_t, table) - 32usize];
    ["Offset of field: ecs_iter_t::other_table"]
        [::std::mem::offset_of!(ecs_iter_t, other_table) - 40usize];
    ["Offset of field: ecs_iter_t::ids"][::std::mem::offset_of!(ecs_iter_t, ids) - 48usize];
    ["Offset of field: ecs_iter_t::variables"]
        [::std::mem::offset_of!(ecs_iter_t, variables) - 56usize];
    ["Offset of field: ecs_iter_t::trs"][::std::mem::offset_of!(ecs_iter_t, trs) - 64usize];
    ["Offset of field: ecs_iter_t::sources"][::std::mem::offset_of!(ecs_iter_t, sources) - 72usize];
    ["Offset of field: ecs_iter_t::constrained_vars"]
        [::std::mem::offset_of!(ecs_iter_t, constrained_vars) - 80usize];
    ["Offset of field: ecs_iter_t::group_id"]
        [::std::mem::offset_of!(ecs_iter_t, group_id) - 88usize];
    ["Offset of field: ecs_iter_t::set_fields"]
        [::std::mem::offset_of!(ecs_iter_t, set_fields) - 96usize];
    ["Offset of field: ecs_iter_t::ref_fields"]
        [::std::mem::offset_of!(ecs_iter_t, ref_fields) - 100usize];
    ["Offset of field: ecs_iter_t::row_fields"]
        [::std::mem::offset_of!(ecs_iter_t, row_fields) - 104usize];
    ["Offset of field: ecs_iter_t::up_fields"]
        [::std::mem::offset_of!(ecs_iter_t, up_fields) - 108usize];
    ["Offset of field: ecs_iter_t::system"][::std::mem::offset_of!(ecs_iter_t, system) - 112usize];
    ["Offset of field: ecs_iter_t::event"][::std::mem::offset_of!(ecs_iter_t, event) - 120usize];
    ["Offset of field: ecs_iter_t::event_id"]
        [::std::mem::offset_of!(ecs_iter_t, event_id) - 128usize];
    ["Offset of field: ecs_iter_t::event_cur"]
        [::std::mem::offset_of!(ecs_iter_t, event_cur) - 136usize];
    ["Offset of field: ecs_iter_t::field_count"]
        [::std::mem::offset_of!(ecs_iter_t, field_count) - 140usize];
    ["Offset of field: ecs_iter_t::term_index"]
        [::std::mem::offset_of!(ecs_iter_t, term_index) - 141usize];
    ["Offset of field: ecs_iter_t::variable_count"]
        [::std::mem::offset_of!(ecs_iter_t, variable_count) - 142usize];
    ["Offset of field: ecs_iter_t::query"][::std::mem::offset_of!(ecs_iter_t, query) - 144usize];
    ["Offset of field: ecs_iter_t::variable_names"]
        [::std::mem::offset_of!(ecs_iter_t, variable_names) - 152usize];
    ["Offset of field: ecs_iter_t::param"][::std::mem::offset_of!(ecs_iter_t, param) - 160usize];
    ["Offset of field: ecs_iter_t::ctx"][::std::mem::offset_of!(ecs_iter_t, ctx) - 168usize];
    ["Offset of field: ecs_iter_t::binding_ctx"]
        [::std::mem::offset_of!(ecs_iter_t, binding_ctx) - 176usize];
    ["Offset of field: ecs_iter_t::callback_ctx"]
        [::std::mem::offset_of!(ecs_iter_t, callback_ctx) - 184usize];
    ["Offset of field: ecs_iter_t::run_ctx"]
        [::std::mem::offset_of!(ecs_iter_t, run_ctx) - 192usize];
    ["Offset of field: ecs_iter_t::delta_time"]
        [::std::mem::offset_of!(ecs_iter_t, delta_time) - 200usize];
    ["Offset of field: ecs_iter_t::delta_system_time"]
        [::std::mem::offset_of!(ecs_iter_t, delta_system_time) - 204usize];
    ["Offset of field: ecs_iter_t::frame_offset"]
        [::std::mem::offset_of!(ecs_iter_t, frame_offset) - 208usize];
    ["Offset of field: ecs_iter_t::offset"][::std::mem::offset_of!(ecs_iter_t, offset) - 212usize];
    ["Offset of field: ecs_iter_t::count"][::std::mem::offset_of!(ecs_iter_t, count) - 216usize];
    ["Offset of field: ecs_iter_t::flags"][::std::mem::offset_of!(ecs_iter_t, flags) - 220usize];
    ["Offset of field: ecs_iter_t::interrupted_by"]
        [::std::mem::offset_of!(ecs_iter_t, interrupted_by) - 224usize];
    ["Offset of field: ecs_iter_t::priv_"][::std::mem::offset_of!(ecs_iter_t, priv_) - 232usize];
    ["Offset of field: ecs_iter_t::next"][::std::mem::offset_of!(ecs_iter_t, next) - 352usize];
    ["Offset of field: ecs_iter_t::callback"]
        [::std::mem::offset_of!(ecs_iter_t, callback) - 360usize];
    ["Offset of field: ecs_iter_t::fini"][::std::mem::offset_of!(ecs_iter_t, fini) - 368usize];
    ["Offset of field: ecs_iter_t::chain_it"]
        [::std::mem::offset_of!(ecs_iter_t, chain_it) - 376usize];
};
#[doc = " Used with ecs_query_init().\n\n \\ingroup queries"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_desc_t {
    #[doc = " Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = " Query terms"]
    pub terms: [ecs_term_t; 32usize],
    #[doc = " Query DSL expression (optional)"]
    pub expr: *const ::std::os::raw::c_char,
    #[doc = " Caching policy of query"]
    pub cache_kind: ecs_query_cache_kind_t,
    #[doc = " Flags for enabling query features"]
    pub flags: ecs_flags32_t,
    #[doc = " Callback used for ordering query results. If order_by_id is 0, the\n pointer provided to the callback will be NULL. If the callback is not\n set, results will not be ordered."]
    pub order_by_callback: ecs_order_by_action_t,
    #[doc = " Callback used for ordering query results. Same as order_by_callback,\n but more efficient."]
    pub order_by_table_callback: ecs_sort_table_action_t,
    #[doc = " Component to sort on, used together with order_by_callback or\n order_by_table_callback."]
    pub order_by: ecs_entity_t,
    #[doc = " Component id to be used for grouping. Used together with the\n group_by_callback."]
    pub group_by: ecs_id_t,
    #[doc = " Callback used for grouping results. If the callback is not set, results\n will not be grouped. When set, this callback will be used to calculate a\n \"rank\" for each entity (table) based on its components. This rank is then\n used to sort entities (tables), so that entities (tables) of the same\n rank are \"grouped\" together when iterated."]
    pub group_by_callback: ecs_group_by_action_t,
    #[doc = " Callback that is invoked when a new group is created. The return value of\n the callback is stored as context for a group."]
    pub on_group_create: ecs_group_create_action_t,
    #[doc = " Callback that is invoked when an existing group is deleted. The return\n value of the on_group_create callback is passed as context parameter."]
    pub on_group_delete: ecs_group_delete_action_t,
    #[doc = " Context to pass to group_by"]
    pub group_by_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Function to free group_by_ctx"]
    pub group_by_ctx_free: ecs_ctx_free_t,
    #[doc = " User context to pass to callback"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Context to be used for language bindings"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = " Callback to free binding_ctx"]
    pub binding_ctx_free: ecs_ctx_free_t,
    #[doc = " Entity associated with query (optional)"]
    pub entity: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_desc_t"][::std::mem::size_of::<ecs_query_desc_t>() - 2440usize];
    ["Alignment of ecs_query_desc_t"][::std::mem::align_of::<ecs_query_desc_t>() - 8usize];
    ["Offset of field: ecs_query_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_query_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_query_desc_t::terms"]
        [::std::mem::offset_of!(ecs_query_desc_t, terms) - 8usize];
    ["Offset of field: ecs_query_desc_t::expr"]
        [::std::mem::offset_of!(ecs_query_desc_t, expr) - 2312usize];
    ["Offset of field: ecs_query_desc_t::cache_kind"]
        [::std::mem::offset_of!(ecs_query_desc_t, cache_kind) - 2320usize];
    ["Offset of field: ecs_query_desc_t::flags"]
        [::std::mem::offset_of!(ecs_query_desc_t, flags) - 2324usize];
    ["Offset of field: ecs_query_desc_t::order_by_callback"]
        [::std::mem::offset_of!(ecs_query_desc_t, order_by_callback) - 2328usize];
    ["Offset of field: ecs_query_desc_t::order_by_table_callback"]
        [::std::mem::offset_of!(ecs_query_desc_t, order_by_table_callback) - 2336usize];
    ["Offset of field: ecs_query_desc_t::order_by"]
        [::std::mem::offset_of!(ecs_query_desc_t, order_by) - 2344usize];
    ["Offset of field: ecs_query_desc_t::group_by"]
        [::std::mem::offset_of!(ecs_query_desc_t, group_by) - 2352usize];
    ["Offset of field: ecs_query_desc_t::group_by_callback"]
        [::std::mem::offset_of!(ecs_query_desc_t, group_by_callback) - 2360usize];
    ["Offset of field: ecs_query_desc_t::on_group_create"]
        [::std::mem::offset_of!(ecs_query_desc_t, on_group_create) - 2368usize];
    ["Offset of field: ecs_query_desc_t::on_group_delete"]
        [::std::mem::offset_of!(ecs_query_desc_t, on_group_delete) - 2376usize];
    ["Offset of field: ecs_query_desc_t::group_by_ctx"]
        [::std::mem::offset_of!(ecs_query_desc_t, group_by_ctx) - 2384usize];
    ["Offset of field: ecs_query_desc_t::group_by_ctx_free"]
        [::std::mem::offset_of!(ecs_query_desc_t, group_by_ctx_free) - 2392usize];
    ["Offset of field: ecs_query_desc_t::ctx"]
        [::std::mem::offset_of!(ecs_query_desc_t, ctx) - 2400usize];
    ["Offset of field: ecs_query_desc_t::binding_ctx"]
        [::std::mem::offset_of!(ecs_query_desc_t, binding_ctx) - 2408usize];
    ["Offset of field: ecs_query_desc_t::ctx_free"]
        [::std::mem::offset_of!(ecs_query_desc_t, ctx_free) - 2416usize];
    ["Offset of field: ecs_query_desc_t::binding_ctx_free"]
        [::std::mem::offset_of!(ecs_query_desc_t, binding_ctx_free) - 2424usize];
    ["Offset of field: ecs_query_desc_t::entity"]
        [::std::mem::offset_of!(ecs_query_desc_t, entity) - 2432usize];
};
#[doc = " Used with ecs_observer_init().\n\n @ingroup observers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observer_desc_t {
    #[doc = " Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = " Existing entity to associate with observer (optional)"]
    pub entity: ecs_entity_t,
    #[doc = " Query for observer"]
    pub query: ecs_query_desc_t,
    #[doc = " Events to observe (OnAdd, OnRemove, OnSet)"]
    pub events: [ecs_entity_t; 8usize],
    #[doc = " When observer is created, generate events from existing data. For example,\n #EcsOnAdd `Position` would match all existing instances of `Position`."]
    pub yield_existing: bool,
    #[doc = " Callback to invoke on an event, invoked when the observer matches."]
    pub callback: ecs_iter_action_t,
    #[doc = " Callback invoked on an event. When left to NULL the default runner\n is used which matches the event with the observer's query, and calls\n 'callback' when it matches.\n A reason to override the run function is to improve performance, if there\n are more efficient way to test whether an event matches the observer than\n the general purpose query matcher."]
    pub run: ecs_run_action_t,
    #[doc = " User context to pass to callback"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = " Context associated with callback (for language bindings)."]
    pub callback_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free callback ctx."]
    pub callback_ctx_free: ecs_ctx_free_t,
    #[doc = " Context associated with run (for language bindings)."]
    pub run_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free run ctx."]
    pub run_ctx_free: ecs_ctx_free_t,
    #[doc = " Observable with which to register the observer"]
    pub observable: *mut ecs_poly_t,
    #[doc = " Optional shared last event id for multiple observers. Ensures only one\n of the observers with the shared id gets triggered for an event"]
    pub last_event_id: *mut i32,
    #[doc = " Used for internal purposes"]
    pub term_index_: i8,
    pub flags_: ecs_flags32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_observer_desc_t"][::std::mem::size_of::<ecs_observer_desc_t>() - 2616usize];
    ["Alignment of ecs_observer_desc_t"][::std::mem::align_of::<ecs_observer_desc_t>() - 8usize];
    ["Offset of field: ecs_observer_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_observer_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_observer_desc_t::entity"]
        [::std::mem::offset_of!(ecs_observer_desc_t, entity) - 8usize];
    ["Offset of field: ecs_observer_desc_t::query"]
        [::std::mem::offset_of!(ecs_observer_desc_t, query) - 16usize];
    ["Offset of field: ecs_observer_desc_t::events"]
        [::std::mem::offset_of!(ecs_observer_desc_t, events) - 2456usize];
    ["Offset of field: ecs_observer_desc_t::yield_existing"]
        [::std::mem::offset_of!(ecs_observer_desc_t, yield_existing) - 2520usize];
    ["Offset of field: ecs_observer_desc_t::callback"]
        [::std::mem::offset_of!(ecs_observer_desc_t, callback) - 2528usize];
    ["Offset of field: ecs_observer_desc_t::run"]
        [::std::mem::offset_of!(ecs_observer_desc_t, run) - 2536usize];
    ["Offset of field: ecs_observer_desc_t::ctx"]
        [::std::mem::offset_of!(ecs_observer_desc_t, ctx) - 2544usize];
    ["Offset of field: ecs_observer_desc_t::ctx_free"]
        [::std::mem::offset_of!(ecs_observer_desc_t, ctx_free) - 2552usize];
    ["Offset of field: ecs_observer_desc_t::callback_ctx"]
        [::std::mem::offset_of!(ecs_observer_desc_t, callback_ctx) - 2560usize];
    ["Offset of field: ecs_observer_desc_t::callback_ctx_free"]
        [::std::mem::offset_of!(ecs_observer_desc_t, callback_ctx_free) - 2568usize];
    ["Offset of field: ecs_observer_desc_t::run_ctx"]
        [::std::mem::offset_of!(ecs_observer_desc_t, run_ctx) - 2576usize];
    ["Offset of field: ecs_observer_desc_t::run_ctx_free"]
        [::std::mem::offset_of!(ecs_observer_desc_t, run_ctx_free) - 2584usize];
    ["Offset of field: ecs_observer_desc_t::observable"]
        [::std::mem::offset_of!(ecs_observer_desc_t, observable) - 2592usize];
    ["Offset of field: ecs_observer_desc_t::last_event_id"]
        [::std::mem::offset_of!(ecs_observer_desc_t, last_event_id) - 2600usize];
    ["Offset of field: ecs_observer_desc_t::term_index_"]
        [::std::mem::offset_of!(ecs_observer_desc_t, term_index_) - 2608usize];
    ["Offset of field: ecs_observer_desc_t::flags_"]
        [::std::mem::offset_of!(ecs_observer_desc_t, flags_) - 2612usize];
};
#[doc = " Used with ecs_emit().\n\n @ingroup observers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_desc_t {
    #[doc = " The event id. Only observers for the specified event will be notified"]
    pub event: ecs_entity_t,
    #[doc = " Component ids. Only observers with a matching component id will be\n notified. Observers are guaranteed to get notified once, even if they\n match more than one id."]
    pub ids: *const ecs_type_t,
    #[doc = " The table for which to notify."]
    pub table: *mut ecs_table_t,
    #[doc = " Optional 2nd table to notify. This can be used to communicate the\n previous or next table, in case an entity is moved between tables."]
    pub other_table: *mut ecs_table_t,
    #[doc = " Limit notified entities to ones starting from offset (row) in table"]
    pub offset: i32,
    #[doc = " Limit number of notified entities to count. offset+count must be less\n than the total number of entities in the table. If left to 0, it will be\n automatically determined by doing `ecs_table_count(table) - offset`."]
    pub count: i32,
    #[doc = " Single-entity alternative to setting table / offset / count"]
    pub entity: ecs_entity_t,
    #[doc = " Optional context.\n The type of the param must be the event, where the event is a component.\n When an event is enqueued, the value of param is coped to a temporary\n storage of the event type."]
    pub param: *mut ::std::os::raw::c_void,
    #[doc = " Same as param, but with the guarantee that the value won't be modified.\n When an event with a const parameter is enqueued, the value of the param\n is copied to a temporary storage of the event type."]
    pub const_param: *const ::std::os::raw::c_void,
    #[doc = " Observable (usually the world)"]
    pub observable: *mut ecs_poly_t,
    #[doc = " Event flags"]
    pub flags: ecs_flags32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_event_desc_t"][::std::mem::size_of::<ecs_event_desc_t>() - 80usize];
    ["Alignment of ecs_event_desc_t"][::std::mem::align_of::<ecs_event_desc_t>() - 8usize];
    ["Offset of field: ecs_event_desc_t::event"]
        [::std::mem::offset_of!(ecs_event_desc_t, event) - 0usize];
    ["Offset of field: ecs_event_desc_t::ids"]
        [::std::mem::offset_of!(ecs_event_desc_t, ids) - 8usize];
    ["Offset of field: ecs_event_desc_t::table"]
        [::std::mem::offset_of!(ecs_event_desc_t, table) - 16usize];
    ["Offset of field: ecs_event_desc_t::other_table"]
        [::std::mem::offset_of!(ecs_event_desc_t, other_table) - 24usize];
    ["Offset of field: ecs_event_desc_t::offset"]
        [::std::mem::offset_of!(ecs_event_desc_t, offset) - 32usize];
    ["Offset of field: ecs_event_desc_t::count"]
        [::std::mem::offset_of!(ecs_event_desc_t, count) - 36usize];
    ["Offset of field: ecs_event_desc_t::entity"]
        [::std::mem::offset_of!(ecs_event_desc_t, entity) - 40usize];
    ["Offset of field: ecs_event_desc_t::param"]
        [::std::mem::offset_of!(ecs_event_desc_t, param) - 48usize];
    ["Offset of field: ecs_event_desc_t::const_param"]
        [::std::mem::offset_of!(ecs_event_desc_t, const_param) - 56usize];
    ["Offset of field: ecs_event_desc_t::observable"]
        [::std::mem::offset_of!(ecs_event_desc_t, observable) - 64usize];
    ["Offset of field: ecs_event_desc_t::flags"]
        [::std::mem::offset_of!(ecs_event_desc_t, flags) - 72usize];
};
#[doc = " Type with information about the current Flecs build"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_build_info_t {
    #[doc = "< Compiler used to compile flecs"]
    pub compiler: *const ::std::os::raw::c_char,
    #[doc = "< Addons included in build"]
    pub addons: *mut *const ::std::os::raw::c_char,
    #[doc = "< Stringified version"]
    pub version: *const ::std::os::raw::c_char,
    #[doc = "< Major flecs version"]
    pub version_major: i16,
    #[doc = "< Minor flecs version"]
    pub version_minor: i16,
    #[doc = "< Patch flecs version"]
    pub version_patch: i16,
    #[doc = "< Is this a debug build"]
    pub debug: bool,
    #[doc = "< Is this a sanitize build"]
    pub sanitize: bool,
    #[doc = "< Is this a perf tracing build"]
    pub perf_trace: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_build_info_t"][::std::mem::size_of::<ecs_build_info_t>() - 40usize];
    ["Alignment of ecs_build_info_t"][::std::mem::align_of::<ecs_build_info_t>() - 8usize];
    ["Offset of field: ecs_build_info_t::compiler"]
        [::std::mem::offset_of!(ecs_build_info_t, compiler) - 0usize];
    ["Offset of field: ecs_build_info_t::addons"]
        [::std::mem::offset_of!(ecs_build_info_t, addons) - 8usize];
    ["Offset of field: ecs_build_info_t::version"]
        [::std::mem::offset_of!(ecs_build_info_t, version) - 16usize];
    ["Offset of field: ecs_build_info_t::version_major"]
        [::std::mem::offset_of!(ecs_build_info_t, version_major) - 24usize];
    ["Offset of field: ecs_build_info_t::version_minor"]
        [::std::mem::offset_of!(ecs_build_info_t, version_minor) - 26usize];
    ["Offset of field: ecs_build_info_t::version_patch"]
        [::std::mem::offset_of!(ecs_build_info_t, version_patch) - 28usize];
    ["Offset of field: ecs_build_info_t::debug"]
        [::std::mem::offset_of!(ecs_build_info_t, debug) - 30usize];
    ["Offset of field: ecs_build_info_t::sanitize"]
        [::std::mem::offset_of!(ecs_build_info_t, sanitize) - 31usize];
    ["Offset of field: ecs_build_info_t::perf_trace"]
        [::std::mem::offset_of!(ecs_build_info_t, perf_trace) - 32usize];
};
#[doc = " Type that contains information about the world."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_info_t {
    #[doc = "< Last issued component entity id"]
    pub last_component_id: ecs_entity_t,
    #[doc = "< First allowed entity id"]
    pub min_id: ecs_entity_t,
    #[doc = "< Last allowed entity id"]
    pub max_id: ecs_entity_t,
    #[doc = "< Raw delta time (no time scaling)"]
    pub delta_time_raw: f32,
    #[doc = "< Time passed to or computed by ecs_progress()"]
    pub delta_time: f32,
    #[doc = "< Time scale applied to delta_time"]
    pub time_scale: f32,
    #[doc = "< Target fps"]
    pub target_fps: f32,
    #[doc = "< Total time spent processing a frame"]
    pub frame_time_total: f32,
    #[doc = "< Total time spent in systems"]
    pub system_time_total: f32,
    #[doc = "< Total time spent notifying observers"]
    pub emit_time_total: f32,
    #[doc = "< Total time spent in merges"]
    pub merge_time_total: f32,
    #[doc = "< Time spent on query rematching"]
    pub rematch_time_total: f32,
    #[doc = "< Time elapsed in simulation"]
    pub world_time_total: f64,
    #[doc = "< Time elapsed in simulation (no scaling)"]
    pub world_time_total_raw: f64,
    #[doc = "< Total number of frames"]
    pub frame_count_total: i64,
    #[doc = "< Total number of merges"]
    pub merge_count_total: i64,
    #[doc = "< Total number of rematches"]
    pub rematch_count_total: i64,
    #[doc = "< Total number of times a new id was created"]
    pub id_create_total: i64,
    #[doc = "< Total number of times an id was deleted"]
    pub id_delete_total: i64,
    #[doc = "< Total number of times a table was created"]
    pub table_create_total: i64,
    #[doc = "< Total number of times a table was deleted"]
    pub table_delete_total: i64,
    #[doc = "< Total number of pipeline builds"]
    pub pipeline_build_count_total: i64,
    #[doc = "< Total number of systems ran in last frame"]
    pub systems_ran_frame: i64,
    #[doc = "< Total number of times observer was invoked"]
    pub observers_ran_frame: i64,
    #[doc = "< Number of tag (no data) ids in the world"]
    pub tag_id_count: i32,
    #[doc = "< Number of component (data) ids in the world"]
    pub component_id_count: i32,
    #[doc = "< Number of pair ids in the world"]
    pub pair_id_count: i32,
    #[doc = "< Number of tables"]
    pub table_count: i32,
    #[doc = "< Number of tables without entities"]
    pub empty_table_count: i32,
    #[doc = "< Command statistics."]
    pub cmd: ecs_world_info_t__bindgen_ty_1,
    #[doc = "< Value set by ecs_set_name_prefix(). Used\n to remove library prefixes of symbol\n names (such as `Ecs`, `ecs_`) when\n registering them as names."]
    pub name_prefix: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_info_t__bindgen_ty_1 {
    #[doc = "< Add commands processed"]
    pub add_count: i64,
    #[doc = "< Remove commands processed"]
    pub remove_count: i64,
    #[doc = "< Selete commands processed"]
    pub delete_count: i64,
    #[doc = "< Clear commands processed"]
    pub clear_count: i64,
    #[doc = "< Set commands processed"]
    pub set_count: i64,
    #[doc = "< Ensure/emplace commands processed"]
    pub ensure_count: i64,
    #[doc = "< Modified commands processed"]
    pub modified_count: i64,
    #[doc = "< Commands discarded, happens when entity is no longer alive when running the command"]
    pub discard_count: i64,
    #[doc = "< Enqueued custom events"]
    pub event_count: i64,
    #[doc = "< Other commands processed"]
    pub other_count: i64,
    #[doc = "< Entities for which commands were batched"]
    pub batched_entity_count: i64,
    #[doc = "< Commands batched"]
    pub batched_command_count: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_info_t__bindgen_ty_1"]
        [::std::mem::size_of::<ecs_world_info_t__bindgen_ty_1>() - 96usize];
    ["Alignment of ecs_world_info_t__bindgen_ty_1"]
        [::std::mem::align_of::<ecs_world_info_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::add_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, add_count) - 0usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::remove_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, remove_count) - 8usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::delete_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, delete_count) - 16usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::clear_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, clear_count) - 24usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::set_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, set_count) - 32usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::ensure_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, ensure_count) - 40usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::modified_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, modified_count) - 48usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::discard_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, discard_count) - 56usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::event_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, event_count) - 64usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::other_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, other_count) - 72usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::batched_entity_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, batched_entity_count) - 80usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::batched_command_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, batched_command_count) - 88usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_info_t"][::std::mem::size_of::<ecs_world_info_t>() - 288usize];
    ["Alignment of ecs_world_info_t"][::std::mem::align_of::<ecs_world_info_t>() - 8usize];
    ["Offset of field: ecs_world_info_t::last_component_id"]
        [::std::mem::offset_of!(ecs_world_info_t, last_component_id) - 0usize];
    ["Offset of field: ecs_world_info_t::min_id"]
        [::std::mem::offset_of!(ecs_world_info_t, min_id) - 8usize];
    ["Offset of field: ecs_world_info_t::max_id"]
        [::std::mem::offset_of!(ecs_world_info_t, max_id) - 16usize];
    ["Offset of field: ecs_world_info_t::delta_time_raw"]
        [::std::mem::offset_of!(ecs_world_info_t, delta_time_raw) - 24usize];
    ["Offset of field: ecs_world_info_t::delta_time"]
        [::std::mem::offset_of!(ecs_world_info_t, delta_time) - 28usize];
    ["Offset of field: ecs_world_info_t::time_scale"]
        [::std::mem::offset_of!(ecs_world_info_t, time_scale) - 32usize];
    ["Offset of field: ecs_world_info_t::target_fps"]
        [::std::mem::offset_of!(ecs_world_info_t, target_fps) - 36usize];
    ["Offset of field: ecs_world_info_t::frame_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, frame_time_total) - 40usize];
    ["Offset of field: ecs_world_info_t::system_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, system_time_total) - 44usize];
    ["Offset of field: ecs_world_info_t::emit_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, emit_time_total) - 48usize];
    ["Offset of field: ecs_world_info_t::merge_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, merge_time_total) - 52usize];
    ["Offset of field: ecs_world_info_t::rematch_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, rematch_time_total) - 56usize];
    ["Offset of field: ecs_world_info_t::world_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, world_time_total) - 64usize];
    ["Offset of field: ecs_world_info_t::world_time_total_raw"]
        [::std::mem::offset_of!(ecs_world_info_t, world_time_total_raw) - 72usize];
    ["Offset of field: ecs_world_info_t::frame_count_total"]
        [::std::mem::offset_of!(ecs_world_info_t, frame_count_total) - 80usize];
    ["Offset of field: ecs_world_info_t::merge_count_total"]
        [::std::mem::offset_of!(ecs_world_info_t, merge_count_total) - 88usize];
    ["Offset of field: ecs_world_info_t::rematch_count_total"]
        [::std::mem::offset_of!(ecs_world_info_t, rematch_count_total) - 96usize];
    ["Offset of field: ecs_world_info_t::id_create_total"]
        [::std::mem::offset_of!(ecs_world_info_t, id_create_total) - 104usize];
    ["Offset of field: ecs_world_info_t::id_delete_total"]
        [::std::mem::offset_of!(ecs_world_info_t, id_delete_total) - 112usize];
    ["Offset of field: ecs_world_info_t::table_create_total"]
        [::std::mem::offset_of!(ecs_world_info_t, table_create_total) - 120usize];
    ["Offset of field: ecs_world_info_t::table_delete_total"]
        [::std::mem::offset_of!(ecs_world_info_t, table_delete_total) - 128usize];
    ["Offset of field: ecs_world_info_t::pipeline_build_count_total"]
        [::std::mem::offset_of!(ecs_world_info_t, pipeline_build_count_total) - 136usize];
    ["Offset of field: ecs_world_info_t::systems_ran_frame"]
        [::std::mem::offset_of!(ecs_world_info_t, systems_ran_frame) - 144usize];
    ["Offset of field: ecs_world_info_t::observers_ran_frame"]
        [::std::mem::offset_of!(ecs_world_info_t, observers_ran_frame) - 152usize];
    ["Offset of field: ecs_world_info_t::tag_id_count"]
        [::std::mem::offset_of!(ecs_world_info_t, tag_id_count) - 160usize];
    ["Offset of field: ecs_world_info_t::component_id_count"]
        [::std::mem::offset_of!(ecs_world_info_t, component_id_count) - 164usize];
    ["Offset of field: ecs_world_info_t::pair_id_count"]
        [::std::mem::offset_of!(ecs_world_info_t, pair_id_count) - 168usize];
    ["Offset of field: ecs_world_info_t::table_count"]
        [::std::mem::offset_of!(ecs_world_info_t, table_count) - 172usize];
    ["Offset of field: ecs_world_info_t::empty_table_count"]
        [::std::mem::offset_of!(ecs_world_info_t, empty_table_count) - 176usize];
    ["Offset of field: ecs_world_info_t::cmd"]
        [::std::mem::offset_of!(ecs_world_info_t, cmd) - 184usize];
    ["Offset of field: ecs_world_info_t::name_prefix"]
        [::std::mem::offset_of!(ecs_world_info_t, name_prefix) - 280usize];
};
#[doc = " Type that contains information about a query group."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_group_info_t {
    #[doc = "< How often tables have been matched/unmatched"]
    pub match_count: i32,
    #[doc = "< Number of tables in group"]
    pub table_count: i32,
    #[doc = "< Group context, returned by on_group_create"]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_group_info_t"][::std::mem::size_of::<ecs_query_group_info_t>() - 16usize];
    ["Alignment of ecs_query_group_info_t"]
        [::std::mem::align_of::<ecs_query_group_info_t>() - 8usize];
    ["Offset of field: ecs_query_group_info_t::match_count"]
        [::std::mem::offset_of!(ecs_query_group_info_t, match_count) - 0usize];
    ["Offset of field: ecs_query_group_info_t::table_count"]
        [::std::mem::offset_of!(ecs_query_group_info_t, table_count) - 4usize];
    ["Offset of field: ecs_query_group_info_t::ctx"]
        [::std::mem::offset_of!(ecs_query_group_info_t, ctx) - 8usize];
};
#[doc = " A (string) identifier. Used as pair with #EcsName and #EcsSymbol tags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsIdentifier {
    #[doc = "< Identifier string"]
    pub value: *mut ::std::os::raw::c_char,
    #[doc = "< Length of identifier"]
    pub length: ecs_size_t,
    #[doc = "< Hash of current value"]
    pub hash: u64,
    #[doc = "< Hash of existing record in current index"]
    pub index_hash: u64,
    #[doc = "< Current index"]
    pub index: *mut ecs_hashmap_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsIdentifier"][::std::mem::size_of::<EcsIdentifier>() - 40usize];
    ["Alignment of EcsIdentifier"][::std::mem::align_of::<EcsIdentifier>() - 8usize];
    ["Offset of field: EcsIdentifier::value"]
        [::std::mem::offset_of!(EcsIdentifier, value) - 0usize];
    ["Offset of field: EcsIdentifier::length"]
        [::std::mem::offset_of!(EcsIdentifier, length) - 8usize];
    ["Offset of field: EcsIdentifier::hash"][::std::mem::offset_of!(EcsIdentifier, hash) - 16usize];
    ["Offset of field: EcsIdentifier::index_hash"]
        [::std::mem::offset_of!(EcsIdentifier, index_hash) - 24usize];
    ["Offset of field: EcsIdentifier::index"]
        [::std::mem::offset_of!(EcsIdentifier, index) - 32usize];
};
#[doc = " Component information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsComponent {
    #[doc = "< Component size"]
    pub size: ecs_size_t,
    #[doc = "< Component alignment"]
    pub alignment: ecs_size_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsComponent"][::std::mem::size_of::<EcsComponent>() - 8usize];
    ["Alignment of EcsComponent"][::std::mem::align_of::<EcsComponent>() - 4usize];
    ["Offset of field: EcsComponent::size"][::std::mem::offset_of!(EcsComponent, size) - 0usize];
    ["Offset of field: EcsComponent::alignment"]
        [::std::mem::offset_of!(EcsComponent, alignment) - 4usize];
};
#[doc = " Component for storing a poly object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsPoly {
    #[doc = "< Pointer to poly object"]
    pub poly: *mut ecs_poly_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsPoly"][::std::mem::size_of::<EcsPoly>() - 8usize];
    ["Alignment of EcsPoly"][::std::mem::align_of::<EcsPoly>() - 8usize];
    ["Offset of field: EcsPoly::poly"][::std::mem::offset_of!(EcsPoly, poly) - 0usize];
};
#[doc = " When added to an entity this informs serialization formats which component\n to use when a value is assigned to an entity without specifying the\n component. This is intended as a hint, serialization formats are not required\n to use it. Adding this component does not change the behavior of core ECS\n operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsDefaultChildComponent {
    #[doc = "< Default component id."]
    pub component: ecs_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsDefaultChildComponent"]
        [::std::mem::size_of::<EcsDefaultChildComponent>() - 8usize];
    ["Alignment of EcsDefaultChildComponent"]
        [::std::mem::align_of::<EcsDefaultChildComponent>() - 8usize];
    ["Offset of field: EcsDefaultChildComponent::component"]
        [::std::mem::offset_of!(EcsDefaultChildComponent, component) - 0usize];
};
extern "C" {
    #[doc = " Indicates that the id is a pair."]
    pub static ECS_PAIR: ecs_id_t;
}
extern "C" {
    #[doc = " Automatically override component when it is inherited"]
    pub static ECS_AUTO_OVERRIDE: ecs_id_t;
}
extern "C" {
    #[doc = " Adds bitset to storage which allows component to be enabled/disabled"]
    pub static ECS_TOGGLE: ecs_id_t;
}
extern "C" {
    #[doc = " Component component id."]
    pub static FLECS_IDEcsComponentID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Identifier component id."]
    pub static FLECS_IDEcsIdentifierID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Poly component id."]
    pub static FLECS_IDEcsPolyID_: ecs_entity_t;
}
extern "C" {
    #[doc = " DefaultChildComponent component id."]
    pub static FLECS_IDEcsDefaultChildComponentID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to queries."]
    pub static EcsQuery: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to observers."]
    pub static EcsObserver: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to systems."]
    pub static EcsSystem: ecs_entity_t;
}
extern "C" {
    #[doc = " TickSource component id."]
    pub static FLECS_IDEcsTickSourceID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Pipeline module component ids"]
    pub static FLECS_IDEcsPipelineQueryID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Timer component id."]
    pub static FLECS_IDEcsTimerID_: ecs_entity_t;
}
extern "C" {
    #[doc = " RateFilter component id."]
    pub static FLECS_IDEcsRateFilterID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Root scope for builtin flecs entities"]
    pub static EcsFlecs: ecs_entity_t;
}
extern "C" {
    #[doc = " Core module scope"]
    pub static EcsFlecsCore: ecs_entity_t;
}
extern "C" {
    #[doc = " Entity associated with world (used for \"attaching\" components to world)"]
    pub static EcsWorld: ecs_entity_t;
}
extern "C" {
    #[doc = " Wildcard entity (\"*\"). Matches any id, returns all matches."]
    pub static EcsWildcard: ecs_entity_t;
}
extern "C" {
    #[doc = " Any entity (\"_\"). Matches any id, returns only the first."]
    pub static EcsAny: ecs_entity_t;
}
extern "C" {
    #[doc = " This entity. Default source for queries."]
    pub static EcsThis: ecs_entity_t;
}
extern "C" {
    #[doc = " Variable entity (\"$\"). Used in expressions to prefix variable names"]
    pub static EcsVariable: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks a relationship as transitive.\n Behavior:\n\n @code\n   if R(X, Y) and R(Y, Z) then R(X, Z)\n @endcode"]
    pub static EcsTransitive: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks a relationship as reflexive.\n Behavior:\n\n @code\n   R(X, X) == true\n @endcode"]
    pub static EcsReflexive: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensures that entity/component cannot be used as target in `IsA` relationship.\n Final can improve the performance of queries as they will not attempt to\n substitute a final component with its subsets.\n\n Behavior:\n\n @code\n   if IsA(X, Y) and Final(Y) throw error\n @endcode"]
    pub static EcsFinal: ecs_entity_t;
}
extern "C" {
    #[doc = " Relationship that specifies component inheritance behavior."]
    pub static EcsOnInstantiate: ecs_entity_t;
}
extern "C" {
    #[doc = " Override component on instantiate.\n This will copy the component from the base entity `(IsA target)` to the\n instance. The base component will never be inherited from the prefab."]
    pub static EcsOverride: ecs_entity_t;
}
extern "C" {
    #[doc = " Inherit component on instantiate.\n This will inherit (share) the component from the base entity `(IsA target)`.\n The component can be manually overridden by adding it to the instance."]
    pub static EcsInherit: ecs_entity_t;
}
extern "C" {
    #[doc = " Never inherit component on instantiate.\n This will not copy or share the component from the base entity `(IsA target)`.\n When the component is added to an instance, its value will never be copied\n from the base entity."]
    pub static EcsDontInherit: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks relationship as commutative.\n Behavior:\n\n @code\n   if R(X, Y) then R(Y, X)\n @endcode"]
    pub static EcsSymmetric: ecs_entity_t;
}
extern "C" {
    #[doc = " Can be added to relationship to indicate that the relationship can only occur\n once on an entity. Adding a 2nd instance will replace the 1st.\n\n Behavior:\n\n @code\n   R(X, Y) + R(X, Z) = R(X, Z)\n @endcode"]
    pub static EcsExclusive: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks a relationship as acyclic. Acyclic relationships may not form cycles."]
    pub static EcsAcyclic: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks a relationship as traversable. Traversable relationships may be\n traversed with \"up\" queries. Traversable relationships are acyclic."]
    pub static EcsTraversable: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure that a component always is added together with another component.\n\n Behavior:\n\n @code\n   If With(R, O) and R(X) then O(X)\n   If With(R, O) and R(X, Y) then O(X, Y)\n @endcode"]
    pub static EcsWith: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure that relationship target is child of specified entity.\n\n Behavior:\n\n @code\n   If OneOf(R, O) and R(X, Y), Y must be a child of O\n   If OneOf(R) and R(X, Y), Y must be a child of R\n @endcode"]
    pub static EcsOneOf: ecs_entity_t;
}
extern "C" {
    #[doc = " Mark a component as toggleable with ecs_enable_id()."]
    pub static EcsCanToggle: ecs_entity_t;
}
extern "C" {
    #[doc = " Can be added to components to indicate it is a trait. Traits are components\n and/or tags that are added to other components to modify their behavior."]
    pub static EcsTrait: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure that an entity is always used in pair as relationship.\n\n Behavior:\n\n @code\n   e.add(R) panics\n   e.add(X, R) panics, unless X has the \"Trait\" trait\n @endcode"]
    pub static EcsRelationship: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure that an entity is always used in pair as target.\n\n Behavior:\n\n @code\n   e.add(T) panics\n   e.add(T, X) panics\n @endcode"]
    pub static EcsTarget: ecs_entity_t;
}
extern "C" {
    #[doc = " Can be added to relationship to indicate that it should never hold data,\n even when it or the relationship target is a component."]
    pub static EcsPairIsTag: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag to indicate name identifier"]
    pub static EcsName: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag to indicate symbol identifier"]
    pub static EcsSymbol: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag to indicate alias identifier"]
    pub static EcsAlias: ecs_entity_t;
}
extern "C" {
    #[doc = " Used to express parent-child relationships."]
    pub static EcsChildOf: ecs_entity_t;
}
extern "C" {
    #[doc = " Used to express inheritance relationships."]
    pub static EcsIsA: ecs_entity_t;
}
extern "C" {
    #[doc = " Used to express dependency relationships"]
    pub static EcsDependsOn: ecs_entity_t;
}
extern "C" {
    #[doc = " Used to express a slot (used with prefab inheritance)"]
    pub static EcsSlotOf: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to module entities"]
    pub static EcsModule: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag to indicate an entity/component/system is private to a module"]
    pub static EcsPrivate: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to prefab entities. Any entity with this tag is automatically\n ignored by queries, unless #EcsPrefab is explicitly queried for."]
    pub static EcsPrefab: ecs_entity_t;
}
extern "C" {
    #[doc = " When this tag is added to an entity it is skipped by queries, unless\n #EcsDisabled is explicitly queried for."]
    pub static EcsDisabled: ecs_entity_t;
}
extern "C" {
    #[doc = " Trait added to entities that should never be returned by queries. Reserved\n for internal entities that have special meaning to the query engine, such as\n #EcsThis, #EcsWildcard, #EcsAny."]
    pub static EcsNotQueryable: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when an id is added to an entity"]
    pub static EcsOnAdd: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when an id is removed from an entity"]
    pub static EcsOnRemove: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a component is set for an entity"]
    pub static EcsOnSet: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers observer when an entity starts/stops matching a query"]
    pub static EcsMonitor: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a table is created."]
    pub static EcsOnTableCreate: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a table is deleted."]
    pub static EcsOnTableDelete: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a table becomes empty (doesn't emit on creation)."]
    pub static EcsOnTableEmpty: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a table becomes non-empty."]
    pub static EcsOnTableFill: ecs_entity_t;
}
extern "C" {
    #[doc = " Relationship used for specifying cleanup behavior."]
    pub static EcsOnDelete: ecs_entity_t;
}
extern "C" {
    #[doc = " Relationship used to define what should happen when a target entity (second\n element of a pair) is deleted."]
    pub static EcsOnDeleteTarget: ecs_entity_t;
}
extern "C" {
    #[doc = " Remove cleanup policy. Must be used as target in pair with #EcsOnDelete or\n #EcsOnDeleteTarget."]
    pub static EcsRemove: ecs_entity_t;
}
extern "C" {
    #[doc = " Delete cleanup policy. Must be used as target in pair with #EcsOnDelete or\n #EcsOnDeleteTarget."]
    pub static EcsDelete: ecs_entity_t;
}
extern "C" {
    #[doc = " Panic cleanup policy. Must be used as target in pair with #EcsOnDelete or\n #EcsOnDeleteTarget."]
    pub static EcsPanic: ecs_entity_t;
}
extern "C" {
    #[doc = " Mark component as sparse"]
    pub static EcsSparse: ecs_entity_t;
}
extern "C" {
    #[doc = " Mark relationship as union"]
    pub static EcsUnion: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate `$var == ...` matching in queries."]
    pub static EcsPredEq: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate `$var == \"name\"` matching in queries."]
    pub static EcsPredMatch: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate `$var ~= \"pattern\"` matching in queries."]
    pub static EcsPredLookup: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate the start of a scope (`{`) in queries."]
    pub static EcsScopeOpen: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate the end of a scope (`}`) in queries."]
    pub static EcsScopeClose: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag used to indicate query is empty.\n This tag is removed automatically when a query becomes non-empty, and is not\n automatically re-added when it becomes empty."]
    pub static EcsEmpty: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pipeline component id."]
    pub static FLECS_IDEcsPipelineID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnStart pipeline phase."]
    pub static EcsOnStart: ecs_entity_t;
}
extern "C" {
    #[doc = "< PreFrame pipeline phase."]
    pub static EcsPreFrame: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnLoad pipeline phase."]
    pub static EcsOnLoad: ecs_entity_t;
}
extern "C" {
    #[doc = "< PostLoad pipeline phase."]
    pub static EcsPostLoad: ecs_entity_t;
}
extern "C" {
    #[doc = "< PreUpdate pipeline phase."]
    pub static EcsPreUpdate: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnUpdate pipeline phase."]
    pub static EcsOnUpdate: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnValidate pipeline phase."]
    pub static EcsOnValidate: ecs_entity_t;
}
extern "C" {
    #[doc = "< PostUpdate pipeline phase."]
    pub static EcsPostUpdate: ecs_entity_t;
}
extern "C" {
    #[doc = "< PreStore pipeline phase."]
    pub static EcsPreStore: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnStore pipeline phase."]
    pub static EcsOnStore: ecs_entity_t;
}
extern "C" {
    #[doc = "< PostFrame pipeline phase."]
    pub static EcsPostFrame: ecs_entity_t;
}
extern "C" {
    #[doc = "< Phase pipeline phase."]
    pub static EcsPhase: ecs_entity_t;
}
extern "C" {
    #[doc = " Create a new world.\n This operation automatically imports modules from addons Flecs has been built\n with, except when the module specifies otherwise.\n\n @return A new world"]
    pub fn ecs_init() -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Create a new world with just the core module.\n Same as ecs_init(), but doesn't import modules from addons. This operation is\n faster than ecs_init() and results in less memory utilization.\n\n @return A new tiny world"]
    pub fn ecs_mini() -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Create a new world with arguments.\n Same as ecs_init(), but allows passing in command line arguments. Command line\n arguments are used to:\n - automatically derive the name of the application from argv[0]\n\n @return A new world"]
    pub fn ecs_init_w_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Delete a world.\n This operation deletes the world, and everything it contains.\n\n @param world The world to delete.\n @return Zero if successful, non-zero if failed."]
    pub fn ecs_fini(world: *mut ecs_world_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether the world is being deleted.\n This operation can be used in callbacks like type hooks or observers to\n detect if they are invoked while the world is being deleted.\n\n @param world The world.\n @return True if being deleted, false if not."]
    pub fn ecs_is_fini(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Register action to be executed when world is destroyed.\n Fini actions are typically used when a module needs to clean up before a\n world shuts down.\n\n @param world The world.\n @param action The function to execute.\n @param ctx Userdata to pass to the function"]
    pub fn ecs_atfini(
        world: *mut ecs_world_t,
        action: ecs_fini_action_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Type returned by ecs_get_entities()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_entities_t {
    #[doc = "< Array with all entity ids in the world."]
    pub ids: *const ecs_entity_t,
    #[doc = "< Total number of entity ids."]
    pub count: i32,
    #[doc = "< Number of alive entity ids."]
    pub alive_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_entities_t"][::std::mem::size_of::<ecs_entities_t>() - 16usize];
    ["Alignment of ecs_entities_t"][::std::mem::align_of::<ecs_entities_t>() - 8usize];
    ["Offset of field: ecs_entities_t::ids"][::std::mem::offset_of!(ecs_entities_t, ids) - 0usize];
    ["Offset of field: ecs_entities_t::count"]
        [::std::mem::offset_of!(ecs_entities_t, count) - 8usize];
    ["Offset of field: ecs_entities_t::alive_count"]
        [::std::mem::offset_of!(ecs_entities_t, alive_count) - 12usize];
};
extern "C" {
    #[doc = " Return entity identifiers in world.\n This operation returns an array with all entity ids that exist in the world.\n Note that the returned array will change and may get invalidated as a result\n of entity creation & deletion.\n\n To iterate all alive entity ids, do:\n @code\n ecs_entities_t entities = ecs_get_entities(world);\n for (int i = 0; i < entities.alive_count; i ++) {\n   ecs_entity_t id = entities.ids[i];\n }\n @endcode\n\n To iterate not-alive ids, do:\n @code\n for (int i = entities.alive_count + 1; i < entities.count; i ++) {\n   ecs_entity_t id = entities.ids[i];\n }\n @endcode\n\n The returned array does not need to be freed. Mutating the returned array\n will return in undefined behavior (and likely crashes).\n\n @param world The world.\n @return Struct with entity id array."]
    pub fn ecs_get_entities(world: *const ecs_world_t) -> ecs_entities_t;
}
extern "C" {
    #[doc = " Begin frame.\n When an application does not use ecs_progress() to control the main loop, it\n can still use Flecs features such as FPS limiting and time measurements. This\n operation needs to be invoked whenever a new frame is about to get processed.\n\n Calls to ecs_frame_begin() must always be followed by ecs_frame_end().\n\n The function accepts a delta_time parameter, which will get passed to\n systems. This value is also used to compute the amount of time the function\n needs to sleep to ensure it does not exceed the target_fps, when it is set.\n When 0 is provided for delta_time, the time will be measured.\n\n This function should only be ran from the main thread.\n\n @param world The world.\n @param delta_time Time elapsed since the last frame.\n @return The provided delta_time, or measured time if 0 was provided."]
    pub fn ecs_frame_begin(world: *mut ecs_world_t, delta_time: f32) -> f32;
}
extern "C" {
    #[doc = " End frame.\n This operation must be called at the end of the frame, and always after\n ecs_frame_begin().\n\n @param world The world."]
    pub fn ecs_frame_end(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Register action to be executed once after frame.\n Post frame actions are typically used for calling operations that cannot be\n invoked during iteration, such as changing the number of threads.\n\n @param world The world.\n @param action The function to execute.\n @param ctx Userdata to pass to the function"]
    pub fn ecs_run_post_frame(
        world: *mut ecs_world_t,
        action: ecs_fini_action_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Signal exit\n This operation signals that the application should quit. It will cause\n ecs_progress() to return false.\n\n @param world The world to quit."]
    pub fn ecs_quit(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Return whether a quit has been requested.\n\n @param world The world.\n @return Whether a quit has been requested.\n @see ecs_quit()"]
    pub fn ecs_should_quit(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Measure frame time.\n Frame time measurements measure the total time passed in a single frame, and\n how much of that time was spent on systems and on merging.\n\n Frame time measurements add a small constant-time overhead to an application.\n When an application sets a target FPS, frame time measurements are enabled by\n default.\n\n @param world The world.\n @param enable Whether to enable or disable frame time measuring."]
    pub fn ecs_measure_frame_time(world: *mut ecs_world_t, enable: bool);
}
extern "C" {
    #[doc = " Measure system time.\n System time measurements measure the time spent in each system.\n\n System time measurements add overhead to every system invocation and\n therefore have a small but measurable impact on application performance.\n System time measurements must be enabled before obtaining system statistics.\n\n @param world The world.\n @param enable Whether to enable or disable system time measuring."]
    pub fn ecs_measure_system_time(world: *mut ecs_world_t, enable: bool);
}
extern "C" {
    #[doc = " Set target frames per second (FPS) for application.\n Setting the target FPS ensures that ecs_progress() is not invoked faster than\n the specified FPS. When enabled, ecs_progress() tracks the time passed since\n the last invocation, and sleeps the remaining time of the frame (if any).\n\n This feature ensures systems are ran at a consistent interval, as well as\n conserving CPU time by not running systems more often than required.\n\n Note that ecs_progress() only sleeps if there is time left in the frame. Both\n time spent in flecs as time spent outside of flecs are taken into\n account.\n\n @param world The world.\n @param fps The target FPS."]
    pub fn ecs_set_target_fps(world: *mut ecs_world_t, fps: f32);
}
extern "C" {
    #[doc = " Set default query flags.\n Set a default value for the ecs_filter_desc_t::flags field. Default flags\n are applied in addition to the flags provided in the descriptor. For a\n list of available flags, see include/flecs/private/api_flags.h. Typical flags\n to use are:\n\n  - `EcsQueryMatchEmptyTables`\n  - `EcsQueryMatchDisabled`\n  - `EcsQueryMatchPrefab`\n\n @param world The world.\n @param flags The query flags."]
    pub fn ecs_set_default_query_flags(world: *mut ecs_world_t, flags: ecs_flags32_t);
}
extern "C" {
    #[doc = " Begin readonly mode.\n This operation puts the world in readonly mode, which disallows mutations on\n the world. Readonly mode exists so that internal mechanisms can implement\n optimizations that certain aspects of the world to not change, while also\n providing a mechanism for applications to prevent accidental mutations in,\n for example, multithreaded applications.\n\n Readonly mode is a stronger version of deferred mode. In deferred mode\n ECS operations such as add/remove/set/delete etc. are added to a command\n queue to be executed later. In readonly mode, operations that could break\n scheduler logic (such as creating systems, queries) are also disallowed.\n\n Readonly mode itself has a single threaded and a multi threaded mode. In\n single threaded mode certain mutations on the world are still allowed, for\n example:\n - Entity liveliness operations (such as new, make_alive), so that systems are\n   able to create new entities.\n - Implicit component registration, so that this works from systems\n - Mutations to supporting data structures for the evaluation of uncached\n   queries (filters), so that these can be created on the fly.\n\n These mutations are safe in a single threaded applications, but for\n multithreaded applications the world needs to be entirely immutable. For this\n purpose multi threaded readonly mode exists, which disallows all mutations on\n the world. This means that in multi threaded applications, entity liveliness\n operations, implicit component registration, and on-the-fly query creation\n are not guaranteed to work.\n\n While in readonly mode, applications can still enqueue ECS operations on a\n stage. Stages are managed automatically when using the pipeline addon and\n ecs_progress(), but they can also be configured manually as shown here:\n\n @code\n // Number of stages typically corresponds with number of threads\n ecs_set_stage_count(world, 2);\n ecs_stage_t *stage = ecs_get_stage(world, 1);\n\n ecs_readonly_begin(world);\n ecs_add(world, e, Tag); // readonly assert\n ecs_add(stage, e, Tag); // OK\n @endcode\n\n When an attempt is made to perform an operation on a world in readonly mode,\n the code will throw an assert saying that the world is in readonly mode.\n\n A call to ecs_readonly_begin() must be followed up with ecs_readonly_end().\n When ecs_readonly_end() is called, all enqueued commands from configured\n stages are merged back into the world. Calls to ecs_readonly_begin() and\n ecs_readonly_end() should always happen from a context where the code has\n exclusive access to the world. The functions themselves are not thread safe.\n\n In a typical application, a (non-exhaustive) call stack that uses\n ecs_readonly_begin() and ecs_readonly_end() will look like this:\n\n @code\n ecs_progress()\n   ecs_readonly_begin()\n     ecs_defer_begin()\n\n       // user code\n\n   ecs_readonly_end()\n     ecs_defer_end()\n@endcode\n\n @param world The world\n @param multi_threaded Whether to enable readonly/multi threaded mode.\n @return Whether world is in readonly mode."]
    pub fn ecs_readonly_begin(world: *mut ecs_world_t, multi_threaded: bool) -> bool;
}
extern "C" {
    #[doc = " End readonly mode.\n This operation ends readonly mode, and must be called after\n ecs_readonly_begin(). Operations that were deferred while the world was in\n readonly mode will be flushed.\n\n @param world The world"]
    pub fn ecs_readonly_end(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Merge world or stage.\n When automatic merging is disabled, an application can call this\n operation on either an individual stage, or on the world which will merge\n all stages. This operation may only be called when staging is not enabled\n (either after ecs_progress() or after ecs_readonly_end()).\n\n This operation may be called on an already merged stage or world.\n\n @param world The world."]
    pub fn ecs_merge(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Defer operations until end of frame.\n When this operation is invoked while iterating, operations inbetween the\n ecs_defer_begin() and ecs_defer_end() operations are executed at the end\n of the frame.\n\n This operation is thread safe.\n\n @param world The world.\n @return true if world changed from non-deferred mode to deferred mode.\n\n @see ecs_defer_end()\n @see ecs_is_deferred()\n @see ecs_defer_resume()\n @see ecs_defer_suspend()"]
    pub fn ecs_defer_begin(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Test if deferring is enabled for current stage.\n\n @param world The world.\n @return True if deferred, false if not.\n\n @see ecs_defer_begin()\n @see ecs_defer_end()\n @see ecs_defer_resume()\n @see ecs_defer_suspend()"]
    pub fn ecs_is_deferred(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " End block of operations to defer.\n See ecs_defer_begin().\n\n This operation is thread safe.\n\n @param world The world.\n @return true if world changed from deferred mode to non-deferred mode.\n\n @see ecs_defer_begin()\n @see ecs_defer_is_deferred()\n @see ecs_defer_resume()\n @see ecs_defer_suspend()"]
    pub fn ecs_defer_end(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Suspend deferring but do not flush queue.\n This operation can be used to do an undeferred operation while not flushing\n the operations in the queue.\n\n An application should invoke ecs_defer_resume() before ecs_defer_end() is called.\n The operation may only be called when deferring is enabled.\n\n @param world The world.\n\n @see ecs_defer_begin()\n @see ecs_defer_end()\n @see ecs_defer_is_deferred()\n @see ecs_defer_resume()"]
    pub fn ecs_defer_suspend(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Resume deferring.\n See ecs_defer_suspend().\n\n @param world The world.\n\n @see ecs_defer_begin()\n @see ecs_defer_end()\n @see ecs_defer_is_deferred()\n @see ecs_defer_suspend()"]
    pub fn ecs_defer_resume(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Configure world to have N stages.\n This initializes N stages, which allows applications to defer operations to\n multiple isolated defer queues. This is typically used for applications with\n multiple threads, where each thread gets its own queue, and commands are\n merged when threads are synchronized.\n\n Note that the ecs_set_threads() function already creates the appropriate\n number of stages. The ecs_set_stage_count() operation is useful for applications\n that want to manage their own stages and/or threads.\n\n @param world The world.\n @param stages The number of stages."]
    pub fn ecs_set_stage_count(world: *mut ecs_world_t, stages: i32);
}
extern "C" {
    #[doc = " Get number of configured stages.\n Return number of stages set by ecs_set_stage_count().\n\n @param world The world.\n @return The number of stages used for threading."]
    pub fn ecs_get_stage_count(world: *const ecs_world_t) -> i32;
}
extern "C" {
    #[doc = " Get stage-specific world pointer.\n Flecs threads can safely invoke the API as long as they have a private\n context to write to, also referred to as the stage. This function returns a\n pointer to a stage, disguised as a world pointer.\n\n Note that this function does not(!) create a new world. It simply wraps the\n existing world in a thread-specific context, which the API knows how to\n unwrap. The reason the stage is returned as an ecs_world_t is so that it\n can be passed transparently to the existing API functions, vs. having to\n create a dedicated API for threading.\n\n @param world The world.\n @param stage_id The index of the stage to retrieve.\n @return A thread-specific pointer to the world."]
    pub fn ecs_get_stage(world: *const ecs_world_t, stage_id: i32) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Test whether the current world is readonly.\n This function allows the code to test whether the currently used world\n is readonly or whether it allows for writing.\n\n @param world A pointer to a stage or the world.\n @return True if the world or stage is readonly."]
    pub fn ecs_stage_is_readonly(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Create unmanaged stage.\n Create a stage whose lifecycle is not managed by the world. Must be freed\n with ecs_stage_free().\n\n @param world The world.\n @return The stage."]
    pub fn ecs_stage_new(world: *mut ecs_world_t) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Free unmanaged stage.\n\n @param stage The stage to free."]
    pub fn ecs_stage_free(stage: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Get stage id.\n The stage id can be used by an application to learn about which stage it is\n using, which typically corresponds with the worker thread id.\n\n @param world The world.\n @return The stage id."]
    pub fn ecs_stage_get_id(world: *const ecs_world_t) -> i32;
}
extern "C" {
    #[doc = " Set a world context.\n This operation allows an application to register custom data with a world\n that can be accessed anywhere where the application has the world.\n\n @param world The world.\n @param ctx A pointer to a user defined structure.\n @param ctx_free A function that is invoked with ctx when the world is freed."]
    pub fn ecs_set_ctx(
        world: *mut ecs_world_t,
        ctx: *mut ::std::os::raw::c_void,
        ctx_free: ecs_ctx_free_t,
    );
}
extern "C" {
    #[doc = " Set a world binding context.\n Same as ecs_set_ctx() but for binding context. A binding context is intended\n specifically for language bindings to store binding specific data.\n\n @param world The world.\n @param ctx A pointer to a user defined structure.\n @param ctx_free A function that is invoked with ctx when the world is freed."]
    pub fn ecs_set_binding_ctx(
        world: *mut ecs_world_t,
        ctx: *mut ::std::os::raw::c_void,
        ctx_free: ecs_ctx_free_t,
    );
}
extern "C" {
    #[doc = " Get the world context.\n This operation retrieves a previously set world context.\n\n @param world The world.\n @return The context set with ecs_set_ctx(). If no context was set, the\n         function returns NULL."]
    pub fn ecs_get_ctx(world: *const ecs_world_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the world binding context.\n This operation retrieves a previously set world binding context.\n\n @param world The world.\n @return The context set with ecs_set_binding_ctx(). If no context was set, the\n         function returns NULL."]
    pub fn ecs_get_binding_ctx(world: *const ecs_world_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get build info.\n  Returns information about the current Flecs build.\n\n @return A struct with information about the current Flecs build."]
    pub fn ecs_get_build_info() -> *const ecs_build_info_t;
}
extern "C" {
    #[doc = " Get world info.\n\n @param world The world.\n @return Pointer to the world info. Valid for as long as the world exists."]
    pub fn ecs_get_world_info(world: *const ecs_world_t) -> *const ecs_world_info_t;
}
extern "C" {
    #[doc = " Dimension the world for a specified number of entities.\n This operation will preallocate memory in the world for the specified number\n of entities. Specifying a number lower than the current number of entities in\n the world will have no effect.\n\n @param world The world.\n @param entity_count The number of entities to preallocate."]
    pub fn ecs_dim(world: *mut ecs_world_t, entity_count: i32);
}
extern "C" {
    #[doc = " Set a range for issuing new entity ids.\n This function constrains the entity identifiers returned by ecs_new_w() to the\n specified range. This operation can be used to ensure that multiple processes\n can run in the same simulation without requiring a central service that\n coordinates issuing identifiers.\n\n If `id_end` is set to 0, the range is infinite. If `id_end` is set to a non-zero\n value, it has to be larger than `id_start`. If `id_end` is set and ecs_new() is\n invoked after an id is issued that is equal to `id_end`, the application will\n abort.\n\n @param world The world.\n @param id_start The start of the range.\n @param id_end The end of the range."]
    pub fn ecs_set_entity_range(
        world: *mut ecs_world_t,
        id_start: ecs_entity_t,
        id_end: ecs_entity_t,
    );
}
extern "C" {
    #[doc = " Enable/disable range limits.\n When an application is both a receiver of range-limited entities and a\n producer of range-limited entities, range checking needs to be temporarily\n disabled when inserting received entities. Range checking is disabled on a\n stage, so setting this value is thread safe.\n\n @param world The world.\n @param enable True if range checking should be enabled, false to disable.\n @return The previous value."]
    pub fn ecs_enable_range_check(world: *mut ecs_world_t, enable: bool) -> bool;
}
extern "C" {
    #[doc = " Get the largest issued entity id (not counting generation).\n\n @param world The world.\n @return The largest issued entity id."]
    pub fn ecs_get_max_id(world: *const ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Force aperiodic actions.\n The world may delay certain operations until they are necessary for the\n application to function correctly. This may cause observable side effects\n such as delayed triggering of events, which can be inconvenient when for\n example running a test suite.\n\n The flags parameter specifies which aperiodic actions to run. Specify 0 to\n run all actions. Supported flags start with 'EcsAperiodic'. Flags identify\n internal mechanisms and may change unannounced.\n\n @param world The world.\n @param flags The flags specifying which actions to run."]
    pub fn ecs_run_aperiodic(world: *mut ecs_world_t, flags: ecs_flags32_t);
}
extern "C" {
    #[doc = " Cleanup empty tables.\n This operation cleans up empty tables that meet certain conditions. Having\n large amounts of empty tables does not negatively impact performance of the\n ECS, but can take up considerable amounts of memory, especially in\n applications with many components, and many components per entity.\n\n The generation specifies the minimum number of times this operation has\n to be called before an empty table is cleaned up. If a table becomes non\n empty, the generation is reset.\n\n The operation allows for both a \"clear\" generation and a \"delete\"\n generation. When the clear generation is reached, the table's\n resources are freed (like component arrays) but the table itself is not\n deleted. When the delete generation is reached, the empty table is deleted.\n\n By specifying a non-zero id the cleanup logic can be limited to tables with\n a specific (component) id. The operation will only increase the generation\n count of matching tables.\n\n The min_id_count specifies a lower bound for the number of components a table\n should have. Often the more components a table has, the more specific it is\n and therefore less likely to be reused.\n\n The time budget specifies how long the operation should take at most.\n\n @param world The world.\n @param id Optional component filter for the tables to evaluate.\n @param clear_generation Free table data when generation > clear_generation.\n @param delete_generation Delete table when generation > delete_generation.\n @param min_id_count Minimum number of component ids the table should have.\n @param time_budget_seconds Amount of time operation is allowed to spend.\n @return Number of deleted tables."]
    pub fn ecs_delete_empty_tables(
        world: *mut ecs_world_t,
        id: ecs_id_t,
        clear_generation: u16,
        delete_generation: u16,
        min_id_count: i32,
        time_budget_seconds: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " Get world from poly.\n\n @param poly A pointer to a poly object.\n @return The world."]
    pub fn ecs_get_world(poly: *const ecs_poly_t) -> *const ecs_world_t;
}
extern "C" {
    #[doc = " Get entity from poly.\n\n @param poly A pointer to a poly object.\n @return Entity associated with the poly object."]
    pub fn ecs_get_entity(poly: *const ecs_poly_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Test if pointer is of specified type.\n Usage:\n\n @code\n flecs_poly_is(ptr, ecs_world_t)\n @endcode\n\n This operation only works for poly types.\n\n @param object The object to test.\n @param type The id of the type.\n @return True if the pointer is of the specified type."]
    pub fn flecs_poly_is_(object: *const ecs_poly_t, type_: i32) -> bool;
}
extern "C" {
    #[doc = " Make a pair id.\n This function is equivalent to using the ecs_pair() macro, and is added for\n convenience to make it easier for non C/C++ bindings to work with pairs.\n\n @param first The first element of the pair of the pair.\n @param second The target of the pair.\n @return A pair id."]
    pub fn ecs_make_pair(first: ecs_entity_t, second: ecs_entity_t) -> ecs_id_t;
}
extern "C" {
    #[doc = " Create new entity id.\n This operation returns an unused entity id. This operation is guaranteed to\n return an empty entity as it does not use values set by ecs_set_scope() or\n ecs_set_with().\n\n @param world The world.\n @return The new entity id."]
    pub fn ecs_new(world: *mut ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Create new low id.\n This operation returns a new low id. Entity ids start after the\n FLECS_HI_COMPONENT_ID constant. This reserves a range of low ids for things\n like components, and allows parts of the code to optimize operations.\n\n Note that FLECS_HI_COMPONENT_ID does not represent the maximum number of\n components that can be created, only the maximum number of components that\n can take advantage of these optimizations.\n\n This operation is guaranteed to return an empty entity as it does not use\n values set by ecs_set_scope() or ecs_set_with().\n\n This operation does not recycle ids.\n\n @param world The world.\n @return The new component id."]
    pub fn ecs_new_low_id(world: *mut ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Create new entity with (component) id.\n This operation creates a new entity with an optional (component) id. When 0\n is passed to the id parameter, no component is added to the new entity.\n\n @param world The world.\n @param id The component id to initialize the new entity with.\n @return The new entity."]
    pub fn ecs_new_w_id(world: *mut ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Create new entity in table.\n This operation creates a new entity in the specified table.\n\n @param world The world.\n @param table The table to which to add the new entity.\n @return The new entity."]
    pub fn ecs_new_w_table(world: *mut ecs_world_t, table: *mut ecs_table_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Find or create an entity.\n This operation creates a new entity, or modifies an existing one. When a name\n is set in the ecs_entity_desc_t::name field and ecs_entity_desc_t::entity is\n not set, the operation will first attempt to find an existing entity by that\n name. If no entity with that name can be found, it will be created.\n\n If both a name and entity handle are provided, the operation will check if\n the entity name matches with the provided name. If the names do not match,\n the function will fail and return 0.\n\n If an id to a non-existing entity is provided, that entity id become alive.\n\n See the documentation of ecs_entity_desc_t for more details.\n\n @param world The world.\n @param desc Entity init parameters.\n @return A handle to the new or existing entity, or 0 if failed."]
    pub fn ecs_entity_init(world: *mut ecs_world_t, desc: *const ecs_entity_desc_t)
        -> ecs_entity_t;
}
extern "C" {
    #[doc = " Bulk create/populate new entities.\n This operation bulk inserts a list of new or predefined entities into a\n single table.\n\n The operation does not take ownership of component arrays provided by the\n application. Components that are non-trivially copyable will be moved into\n the storage.\n\n The operation will emit OnAdd events for each added id, and OnSet events for\n each component that has been set.\n\n If no entity ids are provided by the application, the returned array of ids\n points to an internal data structure which changes when new entities are\n created/deleted.\n\n If as a result of the operation triggers are invoked that deletes\n entities and no entity ids were provided by the application, the returned\n array of identifiers may be incorrect. To avoid this problem, an application\n can first call ecs_bulk_init() to create empty entities, copy the array to one\n that is owned by the application, and then use this array to populate the\n entities.\n\n @param world The world.\n @param desc Bulk creation parameters.\n @return Array with the list of entity ids created/populated."]
    pub fn ecs_bulk_init(
        world: *mut ecs_world_t,
        desc: *const ecs_bulk_desc_t,
    ) -> *const ecs_entity_t;
}
extern "C" {
    #[doc = " Create N new entities.\n This operation is the same as ecs_new_w_id(), but creates N entities\n instead of one.\n\n @param world The world.\n @param id The component id to create the entities with.\n @param count The number of entities to create.\n @return The first entity id of the newly created entities."]
    pub fn ecs_bulk_new_w_id(
        world: *mut ecs_world_t,
        id: ecs_id_t,
        count: i32,
    ) -> *const ecs_entity_t;
}
extern "C" {
    #[doc = " Clone an entity\n This operation clones the components of one entity into another entity. If\n no destination entity is provided, a new entity will be created. Component\n values are not copied unless copy_value is true.\n\n If the source entity has a name, it will not be copied to the destination\n entity. This is to prevent having two entities with the same name under the\n same parent, which is not allowed.\n\n @param world The world.\n @param dst The entity to copy the components to.\n @param src The entity to copy the components from.\n @param copy_value If true, the value of components will be copied to dst.\n @return The destination entity."]
    pub fn ecs_clone(
        world: *mut ecs_world_t,
        dst: ecs_entity_t,
        src: ecs_entity_t,
        copy_value: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Delete an entity.\n This operation will delete an entity and all of its components. The entity id\n will be made available for recycling. If the entity passed to ecs_delete() is\n not alive, the operation will have no side effects.\n\n @param world The world.\n @param entity The entity."]
    pub fn ecs_delete(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Delete all entities with the specified id.\n This will delete all entities (tables) that have the specified id. The id\n may be a wildcard and/or a pair.\n\n @param world The world.\n @param id The id."]
    pub fn ecs_delete_with(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Add a (component) id to an entity.\n This operation adds a single (component) id to an entity. If the entity\n already has the id, this operation will have no side effects.\n\n @param world The world.\n @param entity The entity.\n @param id The id to add."]
    pub fn ecs_add_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Remove a (component) id from an entity.\n This operation removes a single (component) id to an entity. If the entity\n does not have the id, this operation will have no side effects.\n\n @param world The world.\n @param entity The entity.\n @param id The id to remove."]
    pub fn ecs_remove_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Add auto override for (component) id.\n An auto override is a component that is automatically added to an entity when\n it is instantiated from a prefab. Auto overrides are added to the entity that\n is inherited from (usually a prefab). For example:\n\n @code\n ecs_entity_t prefab = ecs_insert(world,\n   ecs_value(Position, {10, 20}),\n   ecs_value(Mass, {100}));\n\n ecs_auto_override(world, prefab, Position);\n\n ecs_entity_t inst = ecs_new_w_pair(world, EcsIsA, prefab);\n assert(ecs_owns(world, inst, Position)); // true\n assert(ecs_owns(world, inst, Mass)); // false\n @endcode\n\n An auto override is equivalent to a manual override:\n\n @code\n ecs_entity_t prefab = ecs_insert(world,\n   ecs_value(Position, {10, 20}),\n   ecs_value(Mass, {100}));\n\n ecs_entity_t inst = ecs_new_w_pair(world, EcsIsA, prefab);\n assert(ecs_owns(world, inst, Position)); // false\n ecs_add(world, inst, Position); // manual override\n assert(ecs_owns(world, inst, Position)); // true\n assert(ecs_owns(world, inst, Mass)); // false\n @endcode\n\n This operation is equivalent to manually adding the id with the AUTO_OVERRIDE\n bit applied:\n\n @code\n ecs_add_id(world, entity, ECS_AUTO_OVERRIDE | id);\n @endcode\n\n When a component is overridden and inherited from a prefab, the value from\n the prefab component is copied to the instance. When the component is not\n inherited from a prefab, it is added to the instance as if using ecs_add_id().\n\n Overriding is the default behavior on prefab instantiation. Auto overriding\n is only useful for components with the `(OnInstantiate, Inherit)` trait.\n When a component has the `(OnInstantiate, DontInherit)` trait and is overridden\n the component is added, but the value from the prefab will not be copied.\n\n @param world The world.\n @param entity The entity.\n @param id The (component) id to auto override."]
    pub fn ecs_auto_override_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Clear all components.\n This operation will remove all components from an entity.\n\n @param world The world.\n @param entity The entity."]
    pub fn ecs_clear(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Remove all instances of the specified (component) id.\n This will remove the specified id from all entities (tables). The id may be\n a wildcard and/or a pair.\n\n @param world The world.\n @param id The id."]
    pub fn ecs_remove_all(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Set current with id.\n New entities are automatically created with the specified id.\n\n @param world The world.\n @param id The id.\n @return The previous id."]
    pub fn ecs_set_with(world: *mut ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get current with id.\n Get the id set with ecs_set_with().\n\n @param world The world.\n @return The last id provided to ecs_set_with()."]
    pub fn ecs_get_with(world: *const ecs_world_t) -> ecs_id_t;
}
extern "C" {
    #[doc = " Enable or disable entity.\n This operation enables or disables an entity by adding or removing the\n #EcsDisabled tag. A disabled entity will not be matched with any systems,\n unless the system explicitly specifies the #EcsDisabled tag.\n\n @param world The world.\n @param entity The entity to enable or disable.\n @param enabled true to enable the entity, false to disable."]
    pub fn ecs_enable(world: *mut ecs_world_t, entity: ecs_entity_t, enabled: bool);
}
extern "C" {
    #[doc = " Enable or disable component.\n Enabling or disabling a component does not add or remove a component from an\n entity, but prevents it from being matched with queries. This operation can\n be useful when a component must be temporarily disabled without destroying\n its value. It is also a more performant operation for when an application\n needs to add/remove components at high frequency, as enabling/disabling is\n cheaper than a regular add or remove.\n\n @param world The world.\n @param entity The entity.\n @param id The component.\n @param enable True to enable the component, false to disable."]
    pub fn ecs_enable_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t, enable: bool);
}
extern "C" {
    #[doc = " Test if component is enabled.\n Test whether a component is currently enabled or disabled. This operation\n will return true when the entity has the component and if it has not been\n disabled by ecs_enable_component().\n\n @param world The world.\n @param entity The entity.\n @param id The component.\n @return True if the component is enabled, otherwise false."]
    pub fn ecs_is_enabled_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t)
        -> bool;
}
extern "C" {
    #[doc = " Get an immutable pointer to a component.\n This operation obtains a const pointer to the requested component. The\n operation accepts the component entity id.\n\n This operation can return inherited components reachable through an `IsA`\n relationship.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to get.\n @return The component pointer, NULL if the entity does not have the component.\n\n @see ecs_get_mut_id()"]
    pub fn ecs_get_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get a mutable pointer to a component.\n This operation obtains a mutable pointer to the requested component. The\n operation accepts the component entity id.\n\n Unlike ecs_get_id(), this operation does not return inherited components.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to get.\n @return The component pointer, NULL if the entity does not have the component."]
    pub fn ecs_get_mut_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get a mutable pointer to a component.\n This operation returns a mutable pointer to a component. If the component did\n not yet exist, it will be added.\n\n If ensure is called when the world is in deferred/readonly mode, the\n function will:\n - return a pointer to a temp storage if the component does not yet exist, or\n - return a pointer to the existing component if it exists\n\n @param world The world.\n @param entity The entity.\n @param id The entity id of the component to obtain.\n @return The component pointer.\n\n @see ecs_ensure_modified_id()\n @see ecs_emplace_id()"]
    pub fn ecs_ensure_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Combines ensure + modified in single operation.\n This operation is a more efficient alternative to calling ecs_ensure_id() and\n ecs_modified_id() separately. This operation is only valid when the world is in\n deferred mode, which ensures that the Modified event is not emitted before\n the modification takes place.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to obtain.\n @return The component pointer."]
    pub fn ecs_ensure_modified_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Create a component ref.\n A ref is a handle to an entity + component which caches a small amount of\n data to reduce overhead of repeatedly accessing the component. Use\n ecs_ref_get() to get the component data.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component.\n @return The reference."]
    pub fn ecs_ref_init_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> ecs_ref_t;
}
extern "C" {
    #[doc = " Get component from ref.\n Get component pointer from ref. The ref must be created with ecs_ref_init().\n\n @param world The world.\n @param ref The ref.\n @param id The component id.\n @return The component pointer, NULL if the entity does not have the component."]
    pub fn ecs_ref_get_id(
        world: *const ecs_world_t,
        ref_: *mut ecs_ref_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Update ref.\n Ensures contents of ref are up to date. Same as ecs_ref_get_id(), but does not\n return pointer to component id.\n\n @param world The world.\n @param ref The ref."]
    pub fn ecs_ref_update(world: *const ecs_world_t, ref_: *mut ecs_ref_t);
}
extern "C" {
    #[doc = " Find record for entity.\n An entity record contains the table and row for the entity.\n\n @param world The world.\n @param entity The entity.\n @return The record, NULL if the entity does not exist."]
    pub fn ecs_record_find(world: *const ecs_world_t, entity: ecs_entity_t) -> *mut ecs_record_t;
}
extern "C" {
    #[doc = " Begin exclusive write access to entity.\n This operation provides safe exclusive access to the components of an entity\n without the overhead of deferring operations.\n\n When this operation is called simultaneously for the same entity more than\n once it will throw an assert. Note that for this to happen, asserts must be\n enabled. It is up to the application to ensure that access is exclusive, for\n example by using a read-write mutex.\n\n Exclusive access is enforced at the table level, so only one entity can be\n exclusively accessed per table. The exclusive access check is thread safe.\n\n This operation must be followed up with ecs_write_end().\n\n @param world The world.\n @param entity The entity.\n @return A record to the entity."]
    pub fn ecs_write_begin(world: *mut ecs_world_t, entity: ecs_entity_t) -> *mut ecs_record_t;
}
extern "C" {
    #[doc = " End exclusive write access to entity.\n This operation ends exclusive access, and must be called after\n ecs_write_begin().\n\n @param record Record to the entity."]
    pub fn ecs_write_end(record: *mut ecs_record_t);
}
extern "C" {
    #[doc = " Begin read access to entity.\n This operation provides safe read access to the components of an entity.\n Multiple simultaneous reads are allowed per entity.\n\n This operation ensures that code attempting to mutate the entity's table will\n throw an assert. Note that for this to happen, asserts must be enabled. It is\n up to the application to ensure that this does not happen, for example by\n using a read-write mutex.\n\n This operation does *not* provide the same guarantees as a read-write mutex,\n as it is possible to call ecs_read_begin() after calling ecs_write_begin(). It is\n up to application has to ensure that this does not happen.\n\n This operation must be followed up with ecs_read_end().\n\n @param world The world.\n @param entity The entity.\n @return A record to the entity."]
    pub fn ecs_read_begin(world: *mut ecs_world_t, entity: ecs_entity_t) -> *const ecs_record_t;
}
extern "C" {
    #[doc = " End read access to entity.\n This operation ends read access, and must be called after ecs_read_begin().\n\n @param record Record to the entity."]
    pub fn ecs_read_end(record: *const ecs_record_t);
}
extern "C" {
    #[doc = " Get entity corresponding with record.\n This operation only works for entities that are not empty.\n\n @param record The record for which to obtain the entity id.\n @return The entity id for the record."]
    pub fn ecs_record_get_entity(record: *const ecs_record_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get component from entity record.\n This operation returns a pointer to a component for the entity\n associated with the provided record. For safe access to the component, obtain\n the record with ecs_read_begin() or ecs_write_begin().\n\n Obtaining a component from a record is faster than obtaining it from the\n entity handle, as it reduces the number of lookups required.\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id.\n @return Pointer to component, or NULL if entity does not have the component.\n\n @see ecs_record_ensure_id()"]
    pub fn ecs_record_get_id(
        world: *const ecs_world_t,
        record: *const ecs_record_t,
        id: ecs_id_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Same as ecs_record_get_id(), but returns a mutable pointer.\n For safe access to the component, obtain the record with ecs_write_begin().\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id.\n @return Pointer to component, or NULL if entity does not have the component."]
    pub fn ecs_record_ensure_id(
        world: *mut ecs_world_t,
        record: *mut ecs_record_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Test if entity for record has a (component) id.\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id.\n @return Whether the entity has the component."]
    pub fn ecs_record_has_id(
        world: *mut ecs_world_t,
        record: *const ecs_record_t,
        id: ecs_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Get component pointer from column/record.\n This returns a pointer to the component using a table column index. The\n table's column index can be found with ecs_table_get_column_index().\n\n Usage:\n @code\n ecs_record_t *r = ecs_record_find(world, entity);\n int32_t column = ecs_table_get_column_index(world, table, ecs_id(Position));\n Position *ptr = ecs_record_get_by_column(r, column, sizeof(Position));\n @endcode\n\n @param record The record.\n @param column The column index in the entity's table.\n @param size The component size.\n @return The component pointer."]
    pub fn ecs_record_get_by_column(
        record: *const ecs_record_t,
        column: i32,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Emplace a component.\n Emplace is similar to ecs_ensure_id() except that the component constructor\n is not invoked for the returned pointer, allowing the component to be\n constructed directly in the storage.\n\n When the `is_new` parameter is not provided, the operation will assert when the\n component already exists. When the `is_new` parameter is provided, it will\n indicate whether the returned storage has been constructed.\n\n When `is_new` indicates that the storage has not yet been constructed, it must\n be constructed by the code invoking this operation. Not constructing the\n component will result in undefined behavior.\n\n @param world The world.\n @param entity The entity.\n @param id The component to obtain.\n @param is_new Whether this is an existing or new component.\n @return The (uninitialized) component pointer."]
    pub fn ecs_emplace_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
        is_new: *mut bool,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Signal that a component has been modified.\n This operation is usually used after modifying a component value obtained by\n ecs_ensure_id(). The operation will mark the component as dirty, and invoke\n OnSet observers and hooks.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component that was modified."]
    pub fn ecs_modified_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Set the value of a component.\n This operation allows an application to set the value of a component. The\n operation is equivalent to calling ecs_ensure_id() followed by\n ecs_modified_id(). The operation will not modify the value of the passed in\n component. If the component has a copy hook registered, it will be used to\n copy in the component.\n\n If the provided entity is 0, a new entity will be created.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to set.\n @param size The size of the pointed-to value.\n @param ptr The pointer to the value."]
    pub fn ecs_set_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
        size: usize,
        ptr: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Test whether an entity is valid.\n Entities that are valid can be used with API functions. Using invalid\n entities with API operations will cause the function to panic.\n\n An entity is valid if it is not 0 and if it is alive.\n\n ecs_is_valid() will return true for ids that don't exist (alive or not alive). This\n allows for using ids that have never been created by ecs_new_w() or similar. In\n this the function differs from ecs_is_alive(), which will return false for\n entities that do not yet exist.\n\n The operation will return false for an id that exists and is not alive, as\n using this id with an API operation would cause it to assert.\n\n @param world The world.\n @param e The entity.\n @return True if the entity is valid, false if the entity is not valid."]
    pub fn ecs_is_valid(world: *const ecs_world_t, e: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = " Test whether an entity is alive.\n Entities are alive after they are created, and become not alive when they are\n deleted. Operations that return alive ids are (amongst others) ecs_new(),\n ecs_new_low_id() and ecs_entity_init(). Ids can be made alive with the ecs_make_alive()\n function.\n\n After an id is deleted it can be recycled. Recycled ids are different from\n the original id in that they have a different generation count. This makes it\n possible for the API to distinguish between the two. An example:\n\n @code\n ecs_entity_t e1 = ecs_new(world);\n ecs_is_alive(world, e1);             // true\n ecs_delete(world, e1);\n ecs_is_alive(world, e1);             // false\n\n ecs_entity_t e2 = ecs_new(world);    // recycles e1\n ecs_is_alive(world, e2);             // true\n ecs_is_alive(world, e1);             // false\n @endcode\n\n @param world The world.\n @param e The entity.\n @return True if the entity is alive, false if the entity is not alive."]
    pub fn ecs_is_alive(world: *const ecs_world_t, e: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = " Remove generation from entity id.\n\n @param e The entity id.\n @return The entity id without the generation count."]
    pub fn ecs_strip_generation(e: ecs_entity_t) -> ecs_id_t;
}
extern "C" {
    #[doc = " Get alive identifier.\n In some cases an application may need to work with identifiers from which\n the generation has been stripped. A typical scenario in which this happens is\n when iterating relationships in an entity type.\n\n For example, when obtaining the parent id from a `ChildOf` relationship, the parent\n (second element of the pair) will have been stored in a 32 bit value, which\n cannot store the entity generation. This function can retrieve the identifier\n with the current generation for that id.\n\n If the provided identifier is not alive, the function will return 0.\n\n @param world The world.\n @param e The for which to obtain the current alive entity id.\n @return The alive entity id if there is one, or 0 if the id is not alive."]
    pub fn ecs_get_alive(world: *const ecs_world_t, e: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure id is alive.\n This operation ensures that the provided id is alive. This is useful in\n scenarios where an application has an existing id that has not been created\n with ecs_new_w() (such as a global constant or an id from a remote application).\n\n When this operation is successful it guarantees that the provided id exists,\n is valid and is alive.\n\n Before this operation the id must either not be alive or have a generation\n that is equal to the passed in entity.\n\n If the provided id has a non-zero generation count and the id does not exist\n in the world, the id will be created with the specified generation.\n\n If the provided id is alive and has a generation count that does not match\n the provided id, the operation will fail.\n\n @param world The world.\n @param entity The entity id to make alive.\n\n @see ecs_make_alive_id()"]
    pub fn ecs_make_alive(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Same as ecs_make_alive(), but for (component) ids.\n An id can be an entity or pair, and can contain id flags. This operation\n ensures that the entity (or entities, for a pair) are alive.\n\n When this operation is successful it guarantees that the provided id can be\n used in operations that accept an id.\n\n Since entities in a pair do not encode their generation ids, this operation\n will not fail when an entity with non-zero generation count already exists in\n the world.\n\n This is different from ecs_make_alive(), which will fail if attempted with an id\n that has generation 0 and an entity with a non-zero generation is currently\n alive.\n\n @param world The world.\n @param id The id to make alive."]
    pub fn ecs_make_alive_id(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Test whether an entity exists.\n Similar as ecs_is_alive(), but ignores entity generation count.\n\n @param world The world.\n @param entity The entity.\n @return True if the entity exists, false if the entity does not exist."]
    pub fn ecs_exists(world: *const ecs_world_t, entity: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = " Override the generation of an entity.\n The generation count of an entity is increased each time an entity is deleted\n and is used to test whether an entity id is alive.\n\n This operation overrides the current generation of an entity with the\n specified generation, which can be useful if an entity is externally managed,\n like for external pools, savefiles or netcode.\n\n This operation is similar to ecs_make_alive(), except that it will also\n override the generation of an alive entity.\n\n @param world The world.\n @param entity Entity for which to set the generation with the new generation."]
    pub fn ecs_set_version(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Get the type of an entity.\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no components."]
    pub fn ecs_get_type(world: *const ecs_world_t, entity: ecs_entity_t) -> *const ecs_type_t;
}
extern "C" {
    #[doc = " Get the table of an entity.\n\n @param world The world.\n @param entity The entity.\n @return The table of the entity, NULL if the entity has no components/tags."]
    pub fn ecs_get_table(world: *const ecs_world_t, entity: ecs_entity_t) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Convert type to string.\n The result of this operation must be freed with ecs_os_free().\n\n @param world The world.\n @param type The type.\n @return The stringified type."]
    pub fn ecs_type_str(
        world: *const ecs_world_t,
        type_: *const ecs_type_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert table to string.\n Same as `ecs_type_str(world, ecs_table_get_type(table))`. The result of this\n operation must be freed with ecs_os_free().\n\n @param world The world.\n @param table The table.\n @return The stringified table type.\n\n @see ecs_table_get_type()\n @see ecs_type_str()"]
    pub fn ecs_table_str(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert entity to string.\n Same as combining:\n - ecs_get_path(world, entity)\n - ecs_type_str(world, ecs_get_type(world, entity))\n\n The result of this operation must be freed with ecs_os_free().\n\n @param world The world.\n @param entity The entity.\n @return The entity path with stringified type.\n\n @see ecs_get_path()\n @see ecs_type_str()"]
    pub fn ecs_entity_str(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Test if an entity has an id.\n This operation returns true if the entity has or inherits the specified id.\n\n @param world The world.\n @param entity The entity.\n @param id The id to test for.\n @return True if the entity has the id, false if not.\n\n @see ecs_owns_id()"]
    pub fn ecs_has_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Test if an entity owns an id.\n This operation returns true if the entity has the specified id. The operation\n behaves the same as ecs_has_id(), except that it will return false for\n components that are inherited through an `IsA` relationship.\n\n @param world The world.\n @param entity The entity.\n @param id The id to test for.\n @return True if the entity has the id, false if not."]
    pub fn ecs_owns_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Get the target of a relationship.\n This will return a target (second element of a pair) of the entity for the\n specified relationship. The index allows for iterating through the targets,\n if a single entity has multiple targets for the same relationship.\n\n If the index is larger than the total number of instances the entity has for\n the relationship, the operation will return 0.\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship between the entity and the target.\n @param index The index of the relationship instance.\n @return The target for the relationship at the specified index."]
    pub fn ecs_get_target(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        rel: ecs_entity_t,
        index: i32,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get parent (target of `ChildOf` relationship) for entity.\n This operation is the same as calling:\n\n @code\n ecs_get_target(world, entity, EcsChildOf, 0);\n @endcode\n\n @param world The world.\n @param entity The entity.\n @return The parent of the entity, 0 if the entity has no parent.\n\n @see ecs_get_target()"]
    pub fn ecs_get_parent(world: *const ecs_world_t, entity: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get the target of a relationship for a given id.\n This operation returns the first entity that has the provided id by following\n the specified relationship. If the entity itself has the id then entity will\n be returned. If the id cannot be found on the entity or by following the\n relationship, the operation will return 0.\n\n This operation can be used to lookup, for example, which prefab is providing\n a component by specifying the `IsA` relationship:\n\n @code\n // Is Position provided by the entity or one of its base entities?\n ecs_get_target_for_id(world, entity, EcsIsA, ecs_id(Position))\n @endcode\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship to follow.\n @param id The id to lookup.\n @return The entity for which the target has been found."]
    pub fn ecs_get_target_for_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        rel: ecs_entity_t,
        id: ecs_id_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Return depth for entity in tree for the specified relationship.\n Depth is determined by counting the number of targets encountered while\n traversing up the relationship tree for rel. Only acyclic relationships are\n supported.\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship.\n @return The depth of the entity in the tree."]
    pub fn ecs_get_depth(world: *const ecs_world_t, entity: ecs_entity_t, rel: ecs_entity_t)
        -> i32;
}
extern "C" {
    #[doc = " Count entities that have the specified id.\n Returns the number of entities that have the specified id.\n\n @param world The world.\n @param entity The id to search for.\n @return The number of entities that have the id."]
    pub fn ecs_count_id(world: *const ecs_world_t, entity: ecs_id_t) -> i32;
}
extern "C" {
    #[doc = " Get the name of an entity.\n This will return the name stored in `(EcsIdentifier, EcsName)`.\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no name.\n\n @see ecs_set_name()"]
    pub fn ecs_get_name(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the symbol of an entity.\n This will return the symbol stored in `(EcsIdentifier, EcsSymbol)`.\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no name.\n\n @see ecs_set_symbol()"]
    pub fn ecs_get_symbol(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the name of an entity.\n This will set or overwrite the name of an entity. If no entity is provided,\n a new entity will be created.\n\n The name is stored in `(EcsIdentifier, EcsName)`.\n\n @param world The world.\n @param entity The entity.\n @param name The name.\n @return The provided entity, or a new entity if 0 was provided.\n\n @see ecs_get_name()"]
    pub fn ecs_set_name(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set the symbol of an entity.\n This will set or overwrite the symbol of an entity. If no entity is provided,\n a new entity will be created.\n\n The symbol is stored in (EcsIdentifier, EcsSymbol).\n\n @param world The world.\n @param entity The entity.\n @param symbol The symbol.\n @return The provided entity, or a new entity if 0 was provided.\n\n @see ecs_get_symbol()"]
    pub fn ecs_set_symbol(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        symbol: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set alias for entity.\n An entity can be looked up using its alias from the root scope without\n providing the fully qualified name if its parent. An entity can only have\n a single alias.\n\n The symbol is stored in `(EcsIdentifier, EcsAlias)`.\n\n @param world The world.\n @param entity The entity.\n @param alias The alias."]
    pub fn ecs_set_alias(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        alias: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Lookup an entity by it's path.\n This operation is equivalent to calling:\n\n @code\n ecs_lookup_path_w_sep(world, 0, path, \".\", NULL, true);\n @endcode\n\n @param world The world.\n @param path The entity path.\n @return The entity with the specified path, or 0 if no entity was found.\n\n @see ecs_lookup_child()\n @see ecs_lookup_path_w_sep()\n @see ecs_lookup_symbol()"]
    pub fn ecs_lookup(
        world: *const ecs_world_t,
        path: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Lookup a child entity by name.\n Returns an entity that matches the specified name. Only looks for entities in\n the provided parent. If no parent is provided, look in the current scope (\n root if no scope is provided).\n\n @param world The world.\n @param parent The parent for which to lookup the child.\n @param name The entity name.\n @return The entity with the specified name, or 0 if no entity was found.\n\n @see ecs_lookup()\n @see ecs_lookup_path_w_sep()\n @see ecs_lookup_symbol()"]
    pub fn ecs_lookup_child(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Lookup an entity from a path.\n Lookup an entity from a provided path, relative to the provided parent. The\n operation will use the provided separator to tokenize the path expression. If\n the provided path contains the prefix, the search will start from the root.\n\n If the entity is not found in the provided parent, the operation will\n continue to search in the parent of the parent, until the root is reached. If\n the entity is still not found, the lookup will search in the flecs.core\n scope. If the entity is not found there either, the function returns 0.\n\n @param world The world.\n @param parent The entity from which to resolve the path.\n @param path The path to resolve.\n @param sep The path separator.\n @param prefix The path prefix.\n @param recursive Recursively traverse up the tree until entity is found.\n @return The entity if found, else 0.\n\n @see ecs_lookup()\n @see ecs_lookup_child()\n @see ecs_lookup_symbol()"]
    pub fn ecs_lookup_path_w_sep(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
        recursive: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Lookup an entity by its symbol name.\n This looks up an entity by symbol stored in `(EcsIdentifier, EcsSymbol)`. The\n operation does not take into account hierarchies.\n\n This operation can be useful to resolve, for example, a type by its C\n identifier, which does not include the Flecs namespacing.\n\n @param world The world.\n @param symbol The symbol.\n @param lookup_as_path If not found as a symbol, lookup as path.\n @param recursive If looking up as path, recursively traverse up the tree.\n @return The entity if found, else 0.\n\n @see ecs_lookup()\n @see ecs_lookup_child()\n @see ecs_lookup_path_w_sep()"]
    pub fn ecs_lookup_symbol(
        world: *const ecs_world_t,
        symbol: *const ::std::os::raw::c_char,
        lookup_as_path: bool,
        recursive: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get a path identifier for an entity.\n This operation creates a path that contains the names of the entities from\n the specified parent to the provided entity, separated by the provided\n separator. If no parent is provided the path will be relative to the root. If\n a prefix is provided, the path will be prefixed by the prefix.\n\n If the parent is equal to the provided child, the operation will return an\n empty string. If a nonzero component is provided, the path will be created by\n looking for parents with that component.\n\n The returned path should be freed by the application.\n\n @param world The world.\n @param parent The entity from which to create the path.\n @param child The entity to which to create the path.\n @param sep The separator to use between path elements.\n @param prefix The initial character to use for root elements.\n @return The relative entity path.\n\n @see ecs_get_path_w_sep_buf()"]
    pub fn ecs_get_path_w_sep(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        child: ecs_entity_t,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write path identifier to buffer.\n Same as ecs_get_path_w_sep(), but writes result to an ecs_strbuf_t.\n\n @param world The world.\n @param parent The entity from which to create the path.\n @param child The entity to which to create the path.\n @param sep The separator to use between path elements.\n @param prefix The initial character to use for root elements.\n @param buf The buffer to write to.\n\n @see ecs_get_path_w_sep()"]
    pub fn ecs_get_path_w_sep_buf(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        child: ecs_entity_t,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
        buf: *mut ecs_strbuf_t,
    );
}
extern "C" {
    #[doc = " Find or create entity from path.\n This operation will find or create an entity from a path, and will create any\n intermediate entities if required. If the entity already exists, no entities\n will be created.\n\n If the path starts with the prefix, then the entity will be created from the\n root scope.\n\n @param world The world.\n @param parent The entity relative to which the entity should be created.\n @param path The path to create the entity for.\n @param sep The separator used in the path.\n @param prefix The prefix used in the path.\n @return The entity."]
    pub fn ecs_new_from_path_w_sep(
        world: *mut ecs_world_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Add specified path to entity.\n This operation is similar to ecs_new_from_path(), but will instead add the path\n to an existing entity.\n\n If an entity already exists for the path, it will be returned instead.\n\n @param world The world.\n @param entity The entity to which to add the path.\n @param parent The entity relative to which the entity should be created.\n @param path The path to create the entity for.\n @param sep The separator used in the path.\n @param prefix The prefix used in the path.\n @return The entity."]
    pub fn ecs_add_path_w_sep(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set the current scope.\n This operation sets the scope of the current stage to the provided entity.\n As a result new entities will be created in this scope, and lookups will be\n relative to the provided scope.\n\n It is considered good practice to restore the scope to the old value.\n\n @param world The world.\n @param scope The entity to use as scope.\n @return The previous scope.\n\n @see ecs_get_scope()"]
    pub fn ecs_set_scope(world: *mut ecs_world_t, scope: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get the current scope.\n Get the scope set by ecs_set_scope(). If no scope is set, this operation will\n return 0.\n\n @param world The world.\n @return The current scope."]
    pub fn ecs_get_scope(world: *const ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set a name prefix for newly created entities.\n This is a utility that lets C modules use prefixed names for C types and\n C functions, while using names for the entity names that do not have the\n prefix. The name prefix is currently only used by ECS_COMPONENT.\n\n @param world The world.\n @param prefix The name prefix to use.\n @return The previous prefix."]
    pub fn ecs_set_name_prefix(
        world: *mut ecs_world_t,
        prefix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set search path for lookup operations.\n This operation accepts an array of entity ids that will be used as search\n scopes by lookup operations. The operation returns the current search path.\n It is good practice to restore the old search path.\n\n The search path will be evaluated starting from the last element.\n\n The default search path includes flecs.core. When a custom search path is\n provided it overwrites the existing search path. Operations that rely on\n looking up names from flecs.core without providing the namespace may fail if\n the custom search path does not include flecs.core (EcsFlecsCore).\n\n The search path array is not copied into managed memory. The application must\n ensure that the provided array is valid for as long as it is used as the\n search path.\n\n The provided array must be terminated with a 0 element. This enables an\n application to push/pop elements to an existing array without invoking the\n ecs_set_lookup_path() operation again.\n\n @param world The world.\n @param lookup_path 0-terminated array with entity ids for the lookup path.\n @return Current lookup path array.\n\n @see ecs_get_lookup_path()"]
    pub fn ecs_set_lookup_path(
        world: *mut ecs_world_t,
        lookup_path: *const ecs_entity_t,
    ) -> *mut ecs_entity_t;
}
extern "C" {
    #[doc = " Get current lookup path.\n Returns value set by ecs_set_lookup_path().\n\n @param world The world.\n @return The current lookup path."]
    pub fn ecs_get_lookup_path(world: *const ecs_world_t) -> *mut ecs_entity_t;
}
extern "C" {
    #[doc = " Find or create a component.\n This operation creates a new component, or finds an existing one. The find or\n create behavior is the same as ecs_entity_init().\n\n When an existing component is found, the size and alignment are verified with\n the provided values. If the values do not match, the operation will fail.\n\n See the documentation of ecs_component_desc_t for more details.\n\n @param world The world.\n @param desc Component init parameters.\n @return A handle to the new or existing component, or 0 if failed."]
    pub fn ecs_component_init(
        world: *mut ecs_world_t,
        desc: *const ecs_component_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get the type for an id.\n This function returns the type information for an id. The specified id can be\n any valid id. For the rules on how type information is determined based on\n id, see ecs_get_typeid().\n\n @param world The world.\n @param id The id.\n @return The type information of the id."]
    pub fn ecs_get_type_info(world: *const ecs_world_t, id: ecs_id_t) -> *const ecs_type_info_t;
}
extern "C" {
    #[doc = " Register hooks for component.\n Hooks allow for the execution of user code when components are constructed,\n copied, moved, destructed, added, removed or set. Hooks can be assigned as\n as long as a component has not yet been used (added to an entity).\n\n The hooks that are currently set can be accessed with ecs_get_type_info().\n\n @param world The world.\n @param id The component id for which to register the actions\n @param hooks Type that contains the component actions."]
    pub fn ecs_set_hooks_id(
        world: *mut ecs_world_t,
        id: ecs_entity_t,
        hooks: *const ecs_type_hooks_t,
    );
}
extern "C" {
    #[doc = " Get hooks for component.\n\n @param world The world.\n @param id The component id for which to retrieve the hooks.\n @return The hooks for the component, or NULL if not registered."]
    pub fn ecs_get_hooks_id(world: *const ecs_world_t, id: ecs_entity_t)
        -> *const ecs_type_hooks_t;
}
extern "C" {
    #[doc = " Returns whether specified id a tag.\n This operation returns whether the specified type is a tag (a component\n without data/size).\n\n An id is a tag when:\n - it is an entity without the EcsComponent component\n - it has an EcsComponent with size member set to 0\n - it is a pair where both elements are a tag\n - it is a pair where the first element has the #EcsPairIsTag tag\n\n @param world The world.\n @param id The id.\n @return Whether the provided id is a tag."]
    pub fn ecs_id_is_tag(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Returns whether specified id is in use.\n This operation returns whether an id is in use in the world. An id is in use\n if it has been added to one or more tables.\n\n @param world The world.\n @param id The id.\n @return Whether the id is in use."]
    pub fn ecs_id_in_use(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Get the type for an id.\n This operation returns the component id for an id, if the id is associated\n with a type. For a regular component with a non-zero size (an entity with the\n EcsComponent component) the operation will return the entity itself.\n\n For an entity that does not have the EcsComponent component, or with an\n EcsComponent value with size 0, the operation will return 0.\n\n For a pair id the operation will return the type associated with the pair, by\n applying the following queries in order:\n - The first pair element is returned if it is a component\n - 0 is returned if the relationship entity has the Tag property\n - The second pair element is returned if it is a component\n - 0 is returned.\n\n @param world The world.\n @param id The id.\n @return The type id of the id."]
    pub fn ecs_get_typeid(world: *const ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Utility to match an id with a pattern.\n This operation returns true if the provided pattern matches the provided\n id. The pattern may contain a wildcard (or wildcards, when a pair).\n\n @param id The id.\n @param pattern The pattern to compare with.\n @return Whether the id matches the pattern."]
    pub fn ecs_id_match(id: ecs_id_t, pattern: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Utility to check if id is a pair.\n\n @param id The id.\n @return True if id is a pair."]
    pub fn ecs_id_is_pair(id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Utility to check if id is a wildcard.\n\n @param id The id.\n @return True if id is a wildcard or a pair containing a wildcard."]
    pub fn ecs_id_is_wildcard(id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Utility to check if id is valid.\n A valid id is an id that can be added to an entity. Invalid ids are:\n - ids that contain wildcards\n - ids that contain invalid entities\n - ids that are 0 or contain 0 entities\n\n Note that the same rules apply to removing from an entity, with the exception\n of wildcards.\n\n @param world The world.\n @param id The id.\n @return True if the id is valid."]
    pub fn ecs_id_is_valid(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Get flags associated with id.\n This operation returns the internal flags (see api_flags.h) that are\n associated with the provided id.\n\n @param world The world.\n @param id The id.\n @return Flags associated with the id, or 0 if the id is not in use."]
    pub fn ecs_id_get_flags(world: *const ecs_world_t, id: ecs_id_t) -> ecs_flags32_t;
}
extern "C" {
    #[doc = " Convert id flag to string.\n This operation converts an id flag to a string.\n\n @param id_flags The id flag.\n @return The id flag string, or NULL if no valid id is provided."]
    pub fn ecs_id_flag_str(id_flags: ecs_id_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert id to string.\n This operation interprets the structure of an id and converts it to a string.\n\n @param world The world.\n @param id The id to convert to a string.\n @return The id converted to a string."]
    pub fn ecs_id_str(world: *const ecs_world_t, id: ecs_id_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write id string to buffer.\n Same as ecs_id_str() but writes result to ecs_strbuf_t.\n\n @param world The world.\n @param id The id to convert to a string.\n @param buf The buffer to write to."]
    pub fn ecs_id_str_buf(world: *const ecs_world_t, id: ecs_id_t, buf: *mut ecs_strbuf_t);
}
extern "C" {
    #[doc = " Test whether term id is set.\n\n @param id The term id.\n @return True when set, false when not set."]
    pub fn ecs_term_ref_is_set(id: *const ecs_term_ref_t) -> bool;
}
extern "C" {
    #[doc = " Test whether a term is set.\n This operation can be used to test whether a term has been initialized with\n values or whether it is empty.\n\n An application generally does not need to invoke this operation. It is useful\n when initializing a 0-initialized array of terms (like in ecs_term_desc_t) as\n this operation can be used to find the last initialized element.\n\n @param term The term.\n @return True when set, false when not set."]
    pub fn ecs_term_is_initialized(term: *const ecs_term_t) -> bool;
}
extern "C" {
    #[doc = " Is term matched on $this variable.\n This operation checks whether a term is matched on the $this variable, which\n is the default source for queries.\n\n A term has a $this source when:\n - ecs_term_t::src::id is EcsThis\n - ecs_term_t::src::flags is EcsIsVariable\n\n If ecs_term_t::src is not populated, it will be automatically initialized to\n the $this source for the created query.\n\n @param term The term.\n @return True if term matches $this, false if not."]
    pub fn ecs_term_match_this(term: *const ecs_term_t) -> bool;
}
extern "C" {
    #[doc = " Is term matched on 0 source.\n This operation checks whether a term is matched on a 0 source. A 0 source is\n a term that isn't matched against anything, and can be used just to pass\n (component) ids to a query iterator.\n\n A term has a 0 source when:\n - ecs_term_t::src::id is 0\n - ecs_term_t::src::flags has EcsIsEntity set\n\n @param term The term.\n @return True if term has 0 source, false if not."]
    pub fn ecs_term_match_0(term: *const ecs_term_t) -> bool;
}
extern "C" {
    #[doc = " Convert term to string expression.\n Convert term to a string expression. The resulting expression is equivalent\n to the same term, with the exception of And & Or operators.\n\n @param world The world.\n @param term The term.\n @return The term converted to a string."]
    pub fn ecs_term_str(
        world: *const ecs_world_t,
        term: *const ecs_term_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert query to string expression.\n Convert query to a string expression. The resulting expression can be\n parsed to create the same query.\n\n @param query The query.\n @return The query converted to a string."]
    pub fn ecs_query_str(query: *const ecs_query_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Iterate all entities with specified (component id).\n This returns an iterator that yields all entities with a single specified\n component. This is a much lighter weight operation than creating and\n iterating a query.\n\n Usage:\n @code\n ecs_iter_t it = ecs_each(world, Player);\n while (ecs_each_next(&it)) {\n   for (int i = 0; i < it.count; i ++) {\n     // Iterate as usual.\n   }\n }\n @endcode\n\n If the specified id is a component, it is possible to access the component\n pointer with ecs_field just like with regular queries:\n\n @code\n ecs_iter_t it = ecs_each(world, Position);\n while (ecs_each_next(&it)) {\n   Position *p = ecs_field(&it, Position, 0);\n   for (int i = 0; i < it.count; i ++) {\n     // Iterate as usual.\n   }\n }\n @endcode\n\n @param world The world.\n @param id The (component) id to iterate.\n @return An iterator that iterates all entities with the (component) id."]
    pub fn ecs_each_id(world: *const ecs_world_t, id: ecs_id_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress an iterator created with ecs_each_id().\n\n @param it The iterator.\n @return True if the iterator has more results, false if not."]
    pub fn ecs_each_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Iterate children of parent.\n Equivalent to:\n @code\n ecs_iter_t it = ecs_each_id(world, ecs_pair(EcsChildOf, parent));\n @endcode\n\n @param world The world.\n @param parent The parent.\n @return An iterator that iterates all children of the parent.\n\n @see ecs_each_id()"]
    pub fn ecs_children(world: *const ecs_world_t, parent: ecs_entity_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress an iterator created with ecs_children().\n\n @param it The iterator.\n @return True if the iterator has more results, false if not."]
    pub fn ecs_children_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Create a query.\n\n @param world The world.\n @param desc The descriptor (see ecs_query_desc_t)\n @return The query."]
    pub fn ecs_query_init(
        world: *mut ecs_world_t,
        desc: *const ecs_query_desc_t,
    ) -> *mut ecs_query_t;
}
extern "C" {
    #[doc = " Delete a query.\n\n @param query The query."]
    pub fn ecs_query_fini(query: *mut ecs_query_t);
}
extern "C" {
    #[doc = " Find variable index.\n This operation looks up the index of a variable in the query. This index can\n be used in operations like ecs_iter_set_var() and ecs_iter_get_var().\n\n @param query The query.\n @param name The variable name.\n @return The variable index."]
    pub fn ecs_query_find_var(
        query: *const ecs_query_t,
        name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Get variable name.\n This operation returns the variable name for an index.\n\n @param query The query.\n @param var_id The variable index.\n @return The variable name."]
    pub fn ecs_query_var_name(
        query: *const ecs_query_t,
        var_id: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Test if variable is an entity.\n Internally the query engine has entity variables and table variables. When\n iterating through query variables (by using ecs_query_variable_count()) only\n the values for entity variables are accessible. This operation enables an\n application to check if a variable is an entity variable.\n\n @param query The query.\n @param var_id The variable id.\n @return Whether the variable is an entity variable."]
    pub fn ecs_query_var_is_entity(query: *const ecs_query_t, var_id: i32) -> bool;
}
extern "C" {
    #[doc = " Create a query iterator.\n Use an iterator to iterate through the entities that match an entity. Queries\n can return multiple results, and have to be iterated by repeatedly calling\n ecs_query_next() until the operation returns false.\n\n Depending on the query, a single result can contain an entire table, a range\n of entities in a table, or a single entity. Iteration code has an inner and\n an outer loop. The outer loop loops through the query results, and typically\n corresponds with a table. The inner loop loops entities in the result.\n\n Example:\n @code\n ecs_iter_t it = ecs_query_iter(world, q);\n\n while (ecs_query_next(&it)) {\n   Position *p = ecs_field(&it, Position, 0);\n   Velocity *v = ecs_field(&it, Velocity, 1);\n\n   for (int i = 0; i < it.count; i ++) {\n     p[i].x += v[i].x;\n     p[i].y += v[i].y;\n   }\n }\n @endcode\n\n The world passed into the operation must be either the actual world or the\n current stage, when iterating from a system. The stage is accessible through\n the it.world member.\n\n Example:\n @code\n void MySystem(ecs_iter_t *it) {\n   ecs_query_t *q = it->ctx; // Query passed as system context\n\n   // Create query iterator from system stage\n   ecs_iter_t qit = ecs_query_iter(it->world, q);\n   while (ecs_query_next(&qit)) {\n     // Iterate as usual\n   }\n }\n @endcode\n\n If query iteration is stopped without the last call to ecs_query_next()\n returning false, iterator resources need to be cleaned up explicitly\n with ecs_iter_fini().\n\n Example:\n @code\n ecs_iter_t it = ecs_query_iter(world, q);\n\n while (ecs_query_next(&it)) {\n   if (!ecs_field_is_set(&it, 0)) {\n     ecs_iter_fini(&it); // Free iterator resources\n     break;\n   }\n\n   for (int i = 0; i < it.count; i ++) {\n     // ...\n   }\n }\n @endcode\n\n @param world The world.\n @param query The query.\n @return An iterator.\n\n @see ecs_query_next()"]
    pub fn ecs_query_iter(world: *const ecs_world_t, query: *const ecs_query_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress query iterator.\n\n @param it The iterator.\n @return True if the iterator has more results, false if not.\n\n @see ecs_query_iter()"]
    pub fn ecs_query_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Match entity with query.\n This operation matches an entity with a query and returns the result of the\n match in the \"it\" out parameter. An application should free the iterator\n resources with ecs_iter_fini() if this function returns true.\n\n Usage:\n @code\n ecs_iter_t it;\n if (ecs_query_has(q, e, &it)) {\n   ecs_iter_fini(&it);\n }\n @endcode\n\n @param query The query.\n @param entity The entity to match\n @param it The iterator with matched data.\n @return True if entity matches the query, false if not."]
    pub fn ecs_query_has(
        query: *mut ecs_query_t,
        entity: ecs_entity_t,
        it: *mut ecs_iter_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Match table with query.\n This operation matches a table with a query and returns the result of the\n match in the \"it\" out parameter. An application should free the iterator\n resources with ecs_iter_fini() if this function returns true.\n\n Usage:\n @code\n ecs_iter_t it;\n if (ecs_query_has_table(q, t, &it)) {\n   ecs_iter_fini(&it);\n }\n @endcode\n\n @param query The query.\n @param table The table to match\n @param it The iterator with matched data.\n @return True if table matches the query, false if not."]
    pub fn ecs_query_has_table(
        query: *mut ecs_query_t,
        table: *mut ecs_table_t,
        it: *mut ecs_iter_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Match range with query.\n This operation matches a range with a query and returns the result of the\n match in the \"it\" out parameter. An application should free the iterator\n resources with ecs_iter_fini() if this function returns true.\n\n The entire range must match the query for the operation to return true.\n\n Usage:\n @code\n ecs_table_range_t range = {\n   .table = table,\n   .offset = 1,\n   .count = 2\n };\n\n ecs_iter_t it;\n if (ecs_query_has_range(q, &range, &it)) {\n   ecs_iter_fini(&it);\n }\n @endcode\n\n @param query The query.\n @param range The range to match\n @param it The iterator with matched data.\n @return True if range matches the query, false if not."]
    pub fn ecs_query_has_range(
        query: *mut ecs_query_t,
        range: *mut ecs_table_range_t,
        it: *mut ecs_iter_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns how often a match event happened for a cached query.\n This operation can be used to determine whether the query cache has been\n updated with new tables.\n\n @param query The query.\n @return The number of match events happened."]
    pub fn ecs_query_match_count(query: *const ecs_query_t) -> i32;
}
extern "C" {
    #[doc = " Convert query to a string.\n This will convert the query program to a string which can aid in debugging\n the behavior of a query.\n\n The returned string must be freed with ecs_os_free().\n\n @param query The query.\n @return The query plan."]
    pub fn ecs_query_plan(query: *const ecs_query_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert query to string with profile.\n To use this you must set the EcsIterProfile flag on an iterator before\n starting iteration:\n\n @code\n   it.flags |= EcsIterProfile\n @endcode\n\n The returned string must be freed with ecs_os_free().\n\n @param query The query.\n @param it The iterator with profile data.\n @return The query plan with profile data."]
    pub fn ecs_query_plan_w_profile(
        query: *const ecs_query_t,
        it: *const ecs_iter_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Populate variables from key-value string.\n Convenience function to set query variables from a key-value string separated\n by comma's. The string must have the following format:\n\n @code\n   var_a: value, var_b: value\n @endcode\n\n The key-value list may optionally be enclosed in parenthesis.\n\n This function uses the script addon.\n\n @param query The query.\n @param it The iterator for which to set the variables.\n @param expr The key-value expression.\n @return Pointer to the next character after the last parsed one."]
    pub fn ecs_query_args_parse(
        query: *mut ecs_query_t,
        it: *mut ecs_iter_t,
        expr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns whether the query data changed since the last iteration.\n The operation will return true after:\n - new entities have been matched with\n - new tables have been matched/unmatched with\n - matched entities were deleted\n - matched components were changed\n\n The operation will not return true after a write-only (EcsOut) or filter\n (EcsInOutNone) term has changed, when a term is not matched with the\n current table (This subject) or for tag terms.\n\n The changed state of a table is reset after it is iterated. If an iterator was\n not iterated until completion, tables may still be marked as changed.\n\n If no iterator is provided the operation will return the changed state of the\n all matched tables of the query.\n\n If an iterator is provided, the operation will return the changed state of\n the currently returned iterator result. The following preconditions must be\n met before using an iterator with change detection:\n\n - The iterator is a query iterator (created with ecs_query_iter())\n - The iterator must be valid (ecs_query_next() must have returned true)\n\n @param query The query (optional if 'it' is provided).\n @return true if entities changed, otherwise false."]
    pub fn ecs_query_changed(query: *mut ecs_query_t) -> bool;
}
extern "C" {
    #[doc = " Skip a table while iterating.\n This operation lets the query iterator know that a table was skipped while\n iterating. A skipped table will not reset its changed state, and the query\n will not update the dirty flags of the table for its out columns.\n\n Only valid iterators must be provided (next has to be called at least once &\n return true) and the iterator must be a query iterator.\n\n @param it The iterator result to skip."]
    pub fn ecs_iter_skip(it: *mut ecs_iter_t);
}
extern "C" {
    #[doc = " Set group to iterate for query iterator.\n This operation limits the results returned by the query to only the selected\n group id. The query must have a group_by function, and the iterator must\n be a query iterator.\n\n Groups are sets of tables that are stored together in the query cache based\n on a group id, which is calculated per table by the group_by function. To\n iterate a group, an iterator only needs to know the first and last cache node\n for that group, which can both be found in a fast O(1) operation.\n\n As a result, group iteration is one of the most efficient mechanisms to\n filter out large numbers of entities, even if those entities are distributed\n across many tables. This makes it a good fit for things like dividing up\n a world into cells, and only iterating cells close to a player.\n\n The group to iterate must be set before the first call to ecs_query_next(). No\n operations that can add/remove components should be invoked between calling\n ecs_iter_set_group() and ecs_query_next().\n\n @param it The query iterator.\n @param group_id The group to iterate."]
    pub fn ecs_iter_set_group(it: *mut ecs_iter_t, group_id: u64);
}
extern "C" {
    #[doc = " Get context of query group.\n This operation returns the context of a query group as returned by the\n on_group_create callback.\n\n @param query The query.\n @param group_id The group for which to obtain the context.\n @return The group context, NULL if the group doesn't exist."]
    pub fn ecs_query_get_group_ctx(
        query: *const ecs_query_t,
        group_id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get information about query group.\n This operation returns information about a query group, including the group\n context returned by the on_group_create callback.\n\n @param query The query.\n @param group_id The group for which to obtain the group info.\n @return The group info, NULL if the group doesn't exist."]
    pub fn ecs_query_get_group_info(
        query: *const ecs_query_t,
        group_id: u64,
    ) -> *const ecs_query_group_info_t;
}
#[doc = " Struct returned by ecs_query_count()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_count_t {
    #[doc = "< Number of results returned by query."]
    pub results: i32,
    #[doc = "< Number of entities returned by query."]
    pub entities: i32,
    #[doc = "< Number of tables returned by query."]
    pub tables: i32,
    #[doc = "< Number of empty tables returned by query."]
    pub empty_tables: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_count_t"][::std::mem::size_of::<ecs_query_count_t>() - 16usize];
    ["Alignment of ecs_query_count_t"][::std::mem::align_of::<ecs_query_count_t>() - 4usize];
    ["Offset of field: ecs_query_count_t::results"]
        [::std::mem::offset_of!(ecs_query_count_t, results) - 0usize];
    ["Offset of field: ecs_query_count_t::entities"]
        [::std::mem::offset_of!(ecs_query_count_t, entities) - 4usize];
    ["Offset of field: ecs_query_count_t::tables"]
        [::std::mem::offset_of!(ecs_query_count_t, tables) - 8usize];
    ["Offset of field: ecs_query_count_t::empty_tables"]
        [::std::mem::offset_of!(ecs_query_count_t, empty_tables) - 12usize];
};
extern "C" {
    #[doc = " Returns number of entities and results the query matches with.\n Only entities matching the $this variable as source are counted.\n\n @param query The query.\n @return The number of matched entities."]
    pub fn ecs_query_count(query: *const ecs_query_t) -> ecs_query_count_t;
}
extern "C" {
    #[doc = " Does query return one or more results.\n\n @param query The query.\n @return True if query matches anything, false if not."]
    pub fn ecs_query_is_true(query: *const ecs_query_t) -> bool;
}
extern "C" {
    #[doc = " Send event.\n This sends an event to matching triggers & is the mechanism used by flecs\n itself to send `OnAdd`, `OnRemove`, etc events.\n\n Applications can use this function to send custom events, where a custom\n event can be any regular entity.\n\n Applications should not send builtin flecs events, as this may violate\n assumptions the code makes about the conditions under which those events are\n sent.\n\n Triggers are invoked synchronously. It is therefore safe to use stack-based\n data as event context, which can be set in the \"param\" member.\n\n @param world The world.\n @param desc Event parameters.\n\n @see ecs_enqueue()"]
    pub fn ecs_emit(world: *mut ecs_world_t, desc: *mut ecs_event_desc_t);
}
extern "C" {
    #[doc = " Enqueue event.\n Same as ecs_emit(), but enqueues an event in the command queue instead. The\n event will be emitted when ecs_defer_end() is called.\n\n If this operation is called when the provided world is not in deferred mode\n it behaves just like ecs_emit().\n\n @param world The world.\n @param desc Event parameters."]
    pub fn ecs_enqueue(world: *mut ecs_world_t, desc: *mut ecs_event_desc_t);
}
extern "C" {
    #[doc = " Create observer.\n Observers are like triggers, but can subscribe for multiple terms. An\n observer only triggers when the source of the event meets all terms.\n\n See the documentation for ecs_observer_desc_t for more details.\n\n @param world The world.\n @param desc The observer creation parameters.\n @return The observer, or 0 if the operation failed."]
    pub fn ecs_observer_init(
        world: *mut ecs_world_t,
        desc: *const ecs_observer_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get observer object.\n Returns the observer object. Can be used to access various information about\n the observer, like the query and context.\n\n @param world The world.\n @param observer The observer.\n @return The observer object."]
    pub fn ecs_observer_get(
        world: *const ecs_world_t,
        observer: ecs_entity_t,
    ) -> *const ecs_observer_t;
}
extern "C" {
    #[doc = " Progress any iterator.\n This operation is useful in combination with iterators for which it is not\n known what created them. Example use cases are functions that should accept\n any kind of iterator (such as serializers) or iterators created from poly\n objects.\n\n This operation is slightly slower than using a type-specific iterator (e.g.\n ecs_query_next, ecs_query_next) as it has to call a function pointer which\n introduces a level of indirection.\n\n @param it The iterator.\n @return True if iterator has more results, false if not."]
    pub fn ecs_iter_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Cleanup iterator resources.\n This operation cleans up any resources associated with the iterator.\n\n This operation should only be used when an iterator is not iterated until\n completion (next has not yet returned false). When an iterator is iterated\n until completion, resources are automatically freed.\n\n @param it The iterator."]
    pub fn ecs_iter_fini(it: *mut ecs_iter_t);
}
extern "C" {
    #[doc = " Count number of matched entities in query.\n This operation returns the number of matched entities. If a query contains no\n matched entities but still yields results (e.g. it has no terms with This\n sources) the operation will return 0.\n\n To determine the number of matched entities, the operation iterates the\n iterator until it yields no more results.\n\n @param it The iterator.\n @return True if iterator has more results, false if not."]
    pub fn ecs_iter_count(it: *mut ecs_iter_t) -> i32;
}
extern "C" {
    #[doc = " Test if iterator is true.\n This operation will return true if the iterator returns at least one result.\n This is especially useful in combination with fact-checking queries (see the\n queries addon).\n\n The operation requires a valid iterator. After the operation is invoked, the\n application should no longer invoke next on the iterator and should treat it\n as if the iterator is iterated until completion.\n\n @param it The iterator.\n @return true if the iterator returns at least one result."]
    pub fn ecs_iter_is_true(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Get first matching entity from iterator.\n After this operation the application should treat the iterator as if it has\n been iterated until completion.\n\n @param it The iterator.\n @return The first matching entity, or 0 if no entities were matched."]
    pub fn ecs_iter_first(it: *mut ecs_iter_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set value for iterator variable.\n This constrains the iterator to return only results for which the variable\n equals the specified value. The default value for all variables is\n EcsWildcard, which means the variable can assume any value.\n\n Example:\n\n @code\n // Query that matches (Eats, *)\n ecs_query_t *q = ecs_query(world, {\n   .terms = {\n     { .first.id = Eats, .second.name = \"$food\" }\n   }\n });\n\n int food_var = ecs_query_find_var(r, \"food\");\n\n // Set Food to Apples, so we're only matching (Eats, Apples)\n ecs_iter_t it = ecs_query_iter(world, q);\n ecs_iter_set_var(&it, food_var, Apples);\n\n while (ecs_query_next(&it)) {\n   for (int i = 0; i < it.count; i ++) {\n     // iterate as usual\n   }\n }\n @endcode\n\n The variable must be initialized after creating the iterator and before the\n first call to next.\n\n @param it The iterator.\n @param var_id The variable index.\n @param entity The entity variable value.\n\n @see ecs_iter_set_var_as_range()\n @see ecs_iter_set_var_as_table()"]
    pub fn ecs_iter_set_var(it: *mut ecs_iter_t, var_id: i32, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Same as ecs_iter_set_var(), but for a table.\n This constrains the variable to all entities in a table.\n\n @param it The iterator.\n @param var_id The variable index.\n @param table The table variable value.\n\n @see ecs_iter_set_var()\n @see ecs_iter_set_var_as_range()"]
    pub fn ecs_iter_set_var_as_table(it: *mut ecs_iter_t, var_id: i32, table: *const ecs_table_t);
}
extern "C" {
    #[doc = " Same as ecs_iter_set_var(), but for a range of entities\n This constrains the variable to a range of entities in a table.\n\n @param it The iterator.\n @param var_id The variable index.\n @param range The range variable value.\n\n @see ecs_iter_set_var()\n @see ecs_iter_set_var_as_table()"]
    pub fn ecs_iter_set_var_as_range(
        it: *mut ecs_iter_t,
        var_id: i32,
        range: *const ecs_table_range_t,
    );
}
extern "C" {
    #[doc = " Get value of iterator variable as entity.\n A variable can be interpreted as entity if it is set to an entity, or if it\n is set to a table range with count 1.\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index.\n @return The variable value."]
    pub fn ecs_iter_get_var(it: *mut ecs_iter_t, var_id: i32) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get value of iterator variable as table.\n A variable can be interpreted as table if it is set as table range with\n both offset and count set to 0, or if offset is 0 and count matches the\n number of elements in the table.\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index.\n @return The variable value."]
    pub fn ecs_iter_get_var_as_table(it: *mut ecs_iter_t, var_id: i32) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Get value of iterator variable as table range.\n A value can be interpreted as table range if it is set as table range, or if\n it is set to an entity with a non-empty type (the entity must have at least\n one component, tag or relationship in its type).\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index.\n @return The variable value."]
    pub fn ecs_iter_get_var_as_range(it: *mut ecs_iter_t, var_id: i32) -> ecs_table_range_t;
}
extern "C" {
    #[doc = " Returns whether variable is constrained.\n This operation returns true for variables set by one of the ecs_iter_set_var*\n operations.\n\n A constrained variable is guaranteed not to change values while results are\n being iterated.\n\n @param it The iterator.\n @param var_id The variable index.\n @return Whether the variable is constrained to a specified value."]
    pub fn ecs_iter_var_is_constrained(it: *mut ecs_iter_t, var_id: i32) -> bool;
}
extern "C" {
    #[doc = " Returns whether current iterator result has changed.\n This operation must be used in combination with a query that supports change\n detection (e.g. is cached). The operation returns whether the currently\n iterated result has changed since the last time it was iterated by the query.\n\n Change detection works on a per-table basis. Changes to individual entities\n cannot be detected this way.\n\n @param it The iterator.\n @return True if the result changed, false if it didn't."]
    pub fn ecs_iter_changed(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Convert iterator to string.\n Prints the contents of an iterator to a string. Useful for debugging and/or\n testing the output of an iterator.\n\n The function only converts the currently iterated data to a string. To\n convert all data, the application has to manually call the next function and\n call ecs_iter_str() on each result.\n\n @param it The iterator.\n @return A string representing the contents of the iterator."]
    pub fn ecs_iter_str(it: *const ecs_iter_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a paged iterator.\n Paged iterators limit the results to those starting from 'offset', and will\n return at most 'limit' results.\n\n The iterator must be iterated with ecs_page_next().\n\n A paged iterator acts as a passthrough for data exposed by the parent\n iterator, so that any data provided by the parent will also be provided by\n the paged iterator.\n\n @param it The source iterator.\n @param offset The number of entities to skip.\n @param limit The maximum number of entities to iterate.\n @return A page iterator."]
    pub fn ecs_page_iter(it: *const ecs_iter_t, offset: i32, limit: i32) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress a paged iterator.\n Progresses an iterator created by ecs_page_iter().\n\n @param it The iterator.\n @return true if iterator has more results, false if not."]
    pub fn ecs_page_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Create a worker iterator.\n Worker iterators can be used to equally divide the number of matched entities\n across N resources (usually threads). Each resource will process the total\n number of matched entities divided by 'count'.\n\n Entities are distributed across resources such that the distribution is\n stable between queries. Two queries that match the same table are guaranteed\n to match the same entities in that table.\n\n The iterator must be iterated with ecs_worker_next().\n\n A worker iterator acts as a passthrough for data exposed by the parent\n iterator, so that any data provided by the parent will also be provided by\n the worker iterator.\n\n @param it The source iterator.\n @param index The index of the current resource.\n @param count The total number of resources to divide entities between.\n @return A worker iterator."]
    pub fn ecs_worker_iter(it: *const ecs_iter_t, index: i32, count: i32) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress a worker iterator.\n Progresses an iterator created by ecs_worker_iter().\n\n @param it The iterator.\n @return true if iterator has more results, false if not."]
    pub fn ecs_worker_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Get data for field.\n This operation retrieves a pointer to an array of data that belongs to the\n term in the query. The index refers to the location of the term in the query,\n and starts counting from zero.\n\n For example, the query `\"Position, Velocity\"` will return the `Position` array\n for index 0, and the `Velocity` array for index 1.\n\n When the specified field is not owned by the entity this function returns a\n pointer instead of an array. This happens when the source of a field is not\n the entity being iterated, such as a shared component (from a prefab), a\n component from a parent, or another entity. The ecs_field_is_self() operation\n can be used to test dynamically if a field is owned.\n\n When a field contains a sparse component, use the ecs_field_at function. When\n a field is guaranteed to be set and owned, the ecs_field_self() function can be\n used. ecs_field_self() has slightly better performance, and provides stricter\n validity checking.\n\n The provided size must be either 0 or must match the size of the type\n of the returned array. If the size does not match, the operation may assert.\n The size can be dynamically obtained with ecs_field_size().\n\n An example:\n\n @code\n while (ecs_query_next(&it)) {\n   Position *p = ecs_field(&it, Position, 0);\n   Velocity *v = ecs_field(&it, Velocity, 1);\n   for (int32_t i = 0; i < it->count; i ++) {\n     p[i].x += v[i].x;\n     p[i].y += v[i].y;\n   }\n }\n @endcode\n\n @param it The iterator.\n @param size The size of the field type.\n @param index The index of the field.\n @return A pointer to the data of the field."]
    pub fn ecs_field_w_size(
        it: *const ecs_iter_t,
        size: usize,
        index: i8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get data for field at specified row.\n This operation should be used instead of ecs_field_w_size for sparse\n component fields. This operation should be called for each returned row in a\n result. In the following example the Velocity component is sparse:\n\n @code\n while (ecs_query_next(&it)) {\n   Position *p = ecs_field(&it, Position, 0);\n   for (int32_t i = 0; i < it->count; i ++) {\n     Velocity *v = ecs_field_at(&it, Velocity, 1);\n     p[i].x += v->x;\n     p[i].y += v->y;\n   }\n }\n @endcode\n\n @param it the iterator.\n @param size The size of the field type.\n @param index The index of the field.\n @return A pointer to the data of the field."]
    pub fn ecs_field_at_w_size(
        it: *const ecs_iter_t,
        size: usize,
        index: i8,
        row: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Test whether the field is readonly.\n This operation returns whether the field is readonly. Readonly fields are\n annotated with [in], or are added as a const type in the C++ API.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is readonly."]
    pub fn ecs_field_is_readonly(it: *const ecs_iter_t, index: i8) -> bool;
}
extern "C" {
    #[doc = " Test whether the field is writeonly.\n This operation returns whether this is a writeonly field. Writeonly terms are\n annotated with [out].\n\n Serializers are not required to serialize the values of a writeonly field.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is writeonly."]
    pub fn ecs_field_is_writeonly(it: *const ecs_iter_t, index: i8) -> bool;
}
extern "C" {
    #[doc = " Test whether field is set.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is set."]
    pub fn ecs_field_is_set(it: *const ecs_iter_t, index: i8) -> bool;
}
extern "C" {
    #[doc = " Return id matched for field.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The id matched for the field."]
    pub fn ecs_field_id(it: *const ecs_iter_t, index: i8) -> ecs_id_t;
}
extern "C" {
    #[doc = " Return index of matched table column.\n This function only returns column indices for fields that have been matched\n on the $this variable. Fields matched on other tables will return -1.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The index of the matched column, -1 if not matched."]
    pub fn ecs_field_column(it: *const ecs_iter_t, index: i8) -> i32;
}
extern "C" {
    #[doc = " Return field source.\n The field source is the entity on which the field was matched.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The source for the field."]
    pub fn ecs_field_src(it: *const ecs_iter_t, index: i8) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Return field type size.\n Return type size of the field. Returns 0 if the field has no data.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The type size for the field."]
    pub fn ecs_field_size(it: *const ecs_iter_t, index: i8) -> usize;
}
extern "C" {
    #[doc = " Test whether the field is matched on self.\n This operation returns whether the field is matched on the currently iterated\n entity. This function will return false when the field is owned by another\n entity, such as a parent or a prefab.\n\n When this operation returns false, the field must be accessed as a single\n value instead of an array. Fields for which this operation returns true\n return arrays with it->count values.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is matched on self."]
    pub fn ecs_field_is_self(it: *const ecs_iter_t, index: i8) -> bool;
}
extern "C" {
    #[doc = " Get type for table.\n The table type is a vector that contains all component, tag and pair ids.\n\n @param table The table.\n @return The type of the table."]
    pub fn ecs_table_get_type(table: *const ecs_table_t) -> *const ecs_type_t;
}
extern "C" {
    #[doc = " Get type index for id.\n This operation returns the index for an id in the table's type.\n\n @param world The world.\n @param table The table.\n @param id The id.\n @return The index of the id in the table type, or -1 if not found.\n\n @see ecs_table_has_id()"]
    pub fn ecs_table_get_type_index(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Get column index for id.\n This operation returns the column index for an id in the table's type. If the\n id is not a component, the function will return -1.\n\n @param world The world.\n @param table The table.\n @param id The component id.\n @return The column index of the id, or -1 if not found/not a component."]
    pub fn ecs_table_get_column_index(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Return number of columns in table.\n Similar to `ecs_table_get_type(table)->count`, except that the column count\n only counts the number of components in a table.\n\n @param table The table.\n @return The number of columns in the table."]
    pub fn ecs_table_column_count(table: *const ecs_table_t) -> i32;
}
extern "C" {
    #[doc = " Convert type index to column index.\n Tables have an array of columns for each component in the table. This array\n does not include elements for tags, which means that the index for a\n component in the table type is not necessarily the same as the index in the\n column array. This operation converts from an index in the table type to an\n index in the column array.\n\n @param table The table.\n @param index The index in the table type.\n @return The index in the table column array.\n\n @see ecs_table_column_to_type_index()"]
    pub fn ecs_table_type_to_column_index(table: *const ecs_table_t, index: i32) -> i32;
}
extern "C" {
    #[doc = " Convert column index to type index.\n Same as ecs_table_type_to_column_index(), but converts from an index in the\n column array to an index in the table type.\n\n @param table The table.\n @param index The column index.\n @return The index in the table type."]
    pub fn ecs_table_column_to_type_index(table: *const ecs_table_t, index: i32) -> i32;
}
extern "C" {
    #[doc = " Get column from table by column index.\n This operation returns the component array for the provided index.\n\n @param table The table.\n @param index The column index.\n @param offset The index of the first row to return (0 for entire column).\n @return The component array, or NULL if the index is not a component."]
    pub fn ecs_table_get_column(
        table: *const ecs_table_t,
        index: i32,
        offset: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get column from table by component id.\n This operation returns the component array for the provided component  id.\n\n @param world The world.\n @param table The table.\n @param id The component id for the column.\n @param offset The index of the first row to return (0 for entire column).\n @return The component array, or NULL if the index is not a component."]
    pub fn ecs_table_get_id(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
        offset: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get column size from table.\n This operation returns the component size for the provided index.\n\n @param table The table.\n @param index The column index.\n @return The component size, or 0 if the index is not a component."]
    pub fn ecs_table_get_column_size(table: *const ecs_table_t, index: i32) -> usize;
}
extern "C" {
    #[doc = " Returns the number of entities in the table.\n This operation returns the number of entities in the table.\n\n @param table The table.\n @return The number of entities in the table."]
    pub fn ecs_table_count(table: *const ecs_table_t) -> i32;
}
extern "C" {
    #[doc = " Returns allocated size of table.\n This operation returns the number of elements allocated in the table\n per column.\n\n @param table The table.\n @return The number of allocated elements in the table."]
    pub fn ecs_table_size(table: *const ecs_table_t) -> i32;
}
extern "C" {
    #[doc = " Returns array with entity ids for table.\n The size of the returned array is the result of ecs_table_count().\n\n @param table The table.\n @return Array with entity ids for table."]
    pub fn ecs_table_entities(table: *const ecs_table_t) -> *const ecs_entity_t;
}
extern "C" {
    #[doc = " Test if table has id.\n Same as `ecs_table_get_type_index(world, table, id) != -1`.\n\n @param world The world.\n @param table The table.\n @param id The id.\n @return True if the table has the id, false if the table doesn't.\n\n @see ecs_table_get_type_index()"]
    pub fn ecs_table_has_id(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Return depth for table in tree for relationship rel.\n Depth is determined by counting the number of targets encountered while\n traversing up the relationship tree for rel. Only acyclic relationships are\n supported.\n\n @param world The world.\n @param table The table.\n @param rel The relationship.\n @return The depth of the table in the tree."]
    pub fn ecs_table_get_depth(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        rel: ecs_entity_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Get table that has all components of current table plus the specified id.\n If the provided table already has the provided id, the operation will return\n the provided table.\n\n @param world The world.\n @param table The table.\n @param id The id to add.\n @result The resulting table."]
    pub fn ecs_table_add_id(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        id: ecs_id_t,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Find table from id array.\n This operation finds or creates a table with the specified array of\n (component) ids. The ids in the array must be sorted, and it may not contain\n duplicate elements.\n\n @param world The world.\n @param ids The id array.\n @param id_count The number of elements in the id array.\n @return The table with the specified (component) ids."]
    pub fn ecs_table_find(
        world: *mut ecs_world_t,
        ids: *const ecs_id_t,
        id_count: i32,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Get table that has all components of current table minus the specified id.\n If the provided table doesn't have the provided id, the operation will return\n the provided table.\n\n @param world The world.\n @param table The table.\n @param id The id to remove.\n @result The resulting table."]
    pub fn ecs_table_remove_id(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        id: ecs_id_t,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Lock a table.\n When a table is locked, modifications to it will throw an assert. When the\n table is locked recursively, it will take an equal amount of unlock\n operations to actually unlock the table.\n\n Table locks can be used to build safe iterators where it is guaranteed that\n the contents of a table are not modified while it is being iterated.\n\n The operation only works when called on the world, and has no side effects\n when called on a stage. The assumption is that when called on a stage,\n operations are deferred already.\n\n @param world The world.\n @param table The table to lock."]
    pub fn ecs_table_lock(world: *mut ecs_world_t, table: *mut ecs_table_t);
}
extern "C" {
    #[doc = " Unlock a table.\n Must be called after calling ecs_table_lock().\n\n @param world The world.\n @param table The table to unlock."]
    pub fn ecs_table_unlock(world: *mut ecs_world_t, table: *mut ecs_table_t);
}
extern "C" {
    #[doc = " Test table for flags.\n Test if table has all of the provided flags. See\n include/flecs/private/api_flags.h for a list of table flags that can be used\n with this function.\n\n @param table The table.\n @param flags The flags to test for.\n @return Whether the specified flags are set for the table."]
    pub fn ecs_table_has_flags(table: *mut ecs_table_t, flags: ecs_flags32_t) -> bool;
}
extern "C" {
    #[doc = " Swaps two elements inside the table. This is useful for implementing custom\n table sorting algorithms.\n @param world The world\n @param table The table to swap elements in\n @param row_1 Table element to swap with row_2\n @param row_2 Table element to swap with row_1"]
    pub fn ecs_table_swap_rows(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        row_1: i32,
        row_2: i32,
    );
}
extern "C" {
    #[doc = " Commit (move) entity to a table.\n This operation moves an entity from its current table to the specified\n table. This may cause the following actions:\n - Ctor for each component in the target table\n - Move for each overlapping component\n - Dtor for each component in the source table.\n - `OnAdd` triggers for non-overlapping components in the target table\n - `OnRemove` triggers for non-overlapping components in the source table.\n\n This operation is a faster than adding/removing components individually.\n\n The application must explicitly provide the difference in components between\n tables as the added/removed parameters. This can usually be derived directly\n from the result of ecs_table_add_id() and ecs_table_remove_id(). These arrays are\n required to properly execute `OnAdd`/`OnRemove` triggers.\n\n @param world The world.\n @param entity The entity to commit.\n @param record The entity's record (optional, providing it saves a lookup).\n @param table The table to commit the entity to.\n @return True if the entity got moved, false otherwise."]
    pub fn ecs_commit(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        record: *mut ecs_record_t,
        table: *mut ecs_table_t,
        added: *const ecs_type_t,
        removed: *const ecs_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Search for component id in table type.\n This operation returns the index of first occurrence of the id in the table\n type. The id may be a wildcard.\n\n When id_out is provided, the function will assign it with the found id. The\n found id may be different from the provided id if it is a wildcard.\n\n This is a constant time operation.\n\n @param world The world.\n @param table The table.\n @param id The id to search for.\n @param id_out If provided, it will be set to the found id (optional).\n @return The index of the id in the table type.\n\n @see ecs_search_offset()\n @see ecs_search_relation()"]
    pub fn ecs_search(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
        id_out: *mut ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Search for component id in table type starting from an offset.\n This operation is the same as ecs_search(), but starts searching from an offset\n in the table type.\n\n This operation is typically called in a loop where the resulting index is\n used in the next iteration as offset:\n\n @code\n int32_t index = -1;\n while ((index = ecs_search_offset(world, table, offset, id, NULL))) {\n   // do stuff\n }\n @endcode\n\n Depending on how the operation is used it is either linear or constant time.\n When the id has the form `(id)` or `(rel, *)` and the operation is invoked as\n in the above example, it is guaranteed to be constant time.\n\n If the provided id has the form `(*, tgt)` the operation takes linear time. The\n reason for this is that ids for an target are not packed together, as they\n are sorted relationship first.\n\n If the id at the offset does not match the provided id, the operation will do\n a linear search to find a matching id.\n\n @param world The world.\n @param table The table.\n @param offset Offset from where to start searching.\n @param id The id to search for.\n @param id_out If provided, it will be set to the found id (optional).\n @return The index of the id in the table type.\n\n @see ecs_search()\n @see ecs_search_relation()"]
    pub fn ecs_search_offset(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        offset: i32,
        id: ecs_id_t,
        id_out: *mut ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Search for component/relationship id in table type starting from an offset.\n This operation is the same as ecs_search_offset(), but has the additional\n capability of traversing relationships to find a component. For example, if\n an application wants to find a component for either the provided table or a\n prefab (using the `IsA` relationship) of that table, it could use the operation\n like this:\n\n @code\n int32_t index = ecs_search_relation(\n   world,            // the world\n   table,            // the table\n   0,                // offset 0\n   ecs_id(Position), // the component id\n   EcsIsA,           // the relationship to traverse\n   0,                // start at depth 0 (the table itself)\n   0,                // no depth limit\n   NULL,             // (optional) entity on which component was found\n   NULL,             // see above\n   NULL);            // internal type with information about matched id\n @endcode\n\n The operation searches depth first. If a table type has 2 `IsA` relationships, the\n operation will first search the `IsA` tree of the first relationship.\n\n When choosing between ecs_search(), ecs_search_offset() and ecs_search_relation(),\n the simpler the function the better its performance.\n\n @param world The world.\n @param table The table.\n @param offset Offset from where to start searching.\n @param id The id to search for.\n @param rel The relationship to traverse (optional).\n @param flags Whether to search EcsSelf and/or EcsUp.\n @param subject_out If provided, it will be set to the matched entity.\n @param id_out If provided, it will be set to the found id (optional).\n @param tr_out Internal datatype.\n @return The index of the id in the table type.\n\n @see ecs_search()\n @see ecs_search_offset()"]
    pub fn ecs_search_relation(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        offset: i32,
        id: ecs_id_t,
        rel: ecs_entity_t,
        flags: ecs_flags64_t,
        subject_out: *mut ecs_entity_t,
        id_out: *mut ecs_id_t,
        tr_out: *mut *mut ecs_table_record_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Construct a value in existing storage\n\n @param world The world.\n @param type The type of the value to create.\n @param ptr Pointer to a value of type 'type'\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_init(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a value in existing storage\n\n @param world The world.\n @param ti The type info of the type to create.\n @param ptr Pointer to a value of type 'type'\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_init_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a value in new storage\n\n @param world The world.\n @param type The type of the value to create.\n @return Pointer to type if success, NULL if failed."]
    pub fn ecs_value_new(
        world: *mut ecs_world_t,
        type_: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Construct a value in new storage\n\n @param world The world.\n @param ti The type info of the type to create.\n @return Pointer to type if success, NULL if failed."]
    pub fn ecs_value_new_w_type_info(
        world: *mut ecs_world_t,
        ti: *const ecs_type_info_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Destruct a value\n\n @param world The world.\n @param ti Type info of the value to destruct.\n @param ptr Pointer to constructed value of type 'type'.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_fini_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destruct a value\n\n @param world The world.\n @param type The type of the value to destruct.\n @param ptr Pointer to constructed value of type 'type'.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_fini(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destruct a value, free storage\n\n @param world The world.\n @param type The type of the value to destruct.\n @param ptr A pointer to the value.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_free(
        world: *mut ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy value.\n\n @param world The world.\n @param ti Type info of the value to copy.\n @param dst Pointer to the storage to copy to.\n @param src Pointer to the value to copy.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_copy_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy value.\n\n @param world The world.\n @param type The type of the value to copy.\n @param dst Pointer to the storage to copy to.\n @param src Pointer to the value to copy.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_copy(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move value.\n\n @param world The world.\n @param ti Type info of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move value.\n\n @param world The world.\n @param type The type of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move construct value.\n\n @param world The world.\n @param ti Type info of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_ctor_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move construct value.\n\n @param world The world.\n @param type The type of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_ctor(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const ecs_journal_kind_t_EcsJournalNew: ecs_journal_kind_t = 0;
pub const ecs_journal_kind_t_EcsJournalMove: ecs_journal_kind_t = 1;
pub const ecs_journal_kind_t_EcsJournalClear: ecs_journal_kind_t = 2;
pub const ecs_journal_kind_t_EcsJournalDelete: ecs_journal_kind_t = 3;
pub const ecs_journal_kind_t_EcsJournalDeleteWith: ecs_journal_kind_t = 4;
pub const ecs_journal_kind_t_EcsJournalRemoveAll: ecs_journal_kind_t = 5;
pub const ecs_journal_kind_t_EcsJournalTableEvents: ecs_journal_kind_t = 6;
pub type ecs_journal_kind_t = ::std::os::raw::c_int;
extern "C" {
    pub fn flecs_journal_begin(
        world: *mut ecs_world_t,
        kind: ecs_journal_kind_t,
        entity: ecs_entity_t,
        add: *mut ecs_type_t,
        remove: *mut ecs_type_t,
    );
}
extern "C" {
    pub fn flecs_journal_end();
}
extern "C" {
    #[doc = " Log message indicating an operation is deprecated."]
    pub fn ecs_deprecated_(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Increase log stack.\n This operation increases the indent_ value of the OS API and can be useful to\n make nested behavior more visible.\n\n @param level The log level."]
    pub fn ecs_log_push_(level: i32);
}
extern "C" {
    #[doc = " Decrease log stack.\n This operation decreases the indent_ value of the OS API and can be useful to\n make nested behavior more visible.\n\n @param level The log level."]
    pub fn ecs_log_pop_(level: i32);
}
extern "C" {
    #[doc = " Should current level be logged.\n This operation returns true when the specified log level should be logged\n with the current log level.\n\n @param level The log level to check for.\n @return Whether logging is enabled for the current level."]
    pub fn ecs_should_log(level: i32) -> bool;
}
extern "C" {
    #[doc = " Get description for error code"]
    pub fn ecs_strerror(error_code: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n Logging functions (do nothing when logging is enabled)\n"]
    pub fn ecs_print_(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_printv_(
        level: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn ecs_log_(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_logv_(
        level: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn ecs_abort_(
        error_code: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_assert_log_(
        error_code: i32,
        condition_str: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_parser_error_(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        column: i64,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_parser_errorv_(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        column: i64,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    #[doc = " Enable or disable log.\n This will enable builtin log. For log to work, it will have to be\n compiled in which requires defining one of the following macros:\n\n FLECS_LOG_0 - All log is disabled\n FLECS_LOG_1 - Enable log level 1\n FLECS_LOG_2 - Enable log level 2 and below\n FLECS_LOG_3 - Enable log level 3 and below\n\n If no log level is defined and this is a debug build, FLECS_LOG_3 will\n have been automatically defined.\n\n The provided level corresponds with the log level. If -1 is provided as\n value, warnings are disabled. If -2 is provided, errors are disabled as well.\n\n @param level Desired tracing level.\n @return Previous log level."]
    pub fn ecs_log_set_level(level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current log level.\n\n @return Previous log level."]
    pub fn ecs_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/disable tracing with colors.\n By default colors are enabled.\n\n @param enabled Whether to enable tracing with colors.\n @return Previous color setting."]
    pub fn ecs_log_enable_colors(enabled: bool) -> bool;
}
extern "C" {
    #[doc = " Enable/disable logging timestamp.\n By default timestamps are disabled. Note that enabling timestamps introduces\n overhead as the logging code will need to obtain the current time.\n\n @param enabled Whether to enable tracing with timestamps.\n @return Previous timestamp setting."]
    pub fn ecs_log_enable_timestamp(enabled: bool) -> bool;
}
extern "C" {
    #[doc = " Enable/disable logging time since last log.\n By default deltatime is disabled. Note that enabling timestamps introduces\n overhead as the logging code will need to obtain the current time.\n\n When enabled, this logs the amount of time in seconds passed since the last\n log, when this amount is non-zero. The format is a '+' character followed by\n the number of seconds:\n\n     +1 trace: log message\n\n @param enabled Whether to enable tracing with timestamps.\n @return Previous timestamp setting."]
    pub fn ecs_log_enable_timedelta(enabled: bool) -> bool;
}
extern "C" {
    #[doc = " Get last logged error code.\n Calling this operation resets the error code.\n\n @return Last error, 0 if none was logged since last call to last_error."]
    pub fn ecs_log_last_error() -> ::std::os::raw::c_int;
}
#[doc = " Callback type for init action."]
pub type ecs_app_init_action_t =
    ::std::option::Option<unsafe extern "C" fn(world: *mut ecs_world_t) -> ::std::os::raw::c_int>;
#[doc = " Used with ecs_app_run()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_app_desc_t {
    #[doc = "< Target FPS."]
    pub target_fps: f32,
    #[doc = "< Frame time increment (0 for measured values)"]
    pub delta_time: f32,
    #[doc = "< Number of threads."]
    pub threads: i32,
    #[doc = "< Number of frames to run (0 for infinite)"]
    pub frames: i32,
    #[doc = "< Enables ECS access over HTTP, necessary for explorer"]
    pub enable_rest: bool,
    #[doc = "< Periodically collect statistics"]
    pub enable_stats: bool,
    #[doc = "< HTTP port used by REST API"]
    pub port: u16,
    #[doc = "< If set, function is ran before starting the\n main loop."]
    pub init: ecs_app_init_action_t,
    #[doc = "< Reserved for custom run/frame actions"]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_app_desc_t"][::std::mem::size_of::<ecs_app_desc_t>() - 40usize];
    ["Alignment of ecs_app_desc_t"][::std::mem::align_of::<ecs_app_desc_t>() - 8usize];
    ["Offset of field: ecs_app_desc_t::target_fps"]
        [::std::mem::offset_of!(ecs_app_desc_t, target_fps) - 0usize];
    ["Offset of field: ecs_app_desc_t::delta_time"]
        [::std::mem::offset_of!(ecs_app_desc_t, delta_time) - 4usize];
    ["Offset of field: ecs_app_desc_t::threads"]
        [::std::mem::offset_of!(ecs_app_desc_t, threads) - 8usize];
    ["Offset of field: ecs_app_desc_t::frames"]
        [::std::mem::offset_of!(ecs_app_desc_t, frames) - 12usize];
    ["Offset of field: ecs_app_desc_t::enable_rest"]
        [::std::mem::offset_of!(ecs_app_desc_t, enable_rest) - 16usize];
    ["Offset of field: ecs_app_desc_t::enable_stats"]
        [::std::mem::offset_of!(ecs_app_desc_t, enable_stats) - 17usize];
    ["Offset of field: ecs_app_desc_t::port"]
        [::std::mem::offset_of!(ecs_app_desc_t, port) - 18usize];
    ["Offset of field: ecs_app_desc_t::init"]
        [::std::mem::offset_of!(ecs_app_desc_t, init) - 24usize];
    ["Offset of field: ecs_app_desc_t::ctx"][::std::mem::offset_of!(ecs_app_desc_t, ctx) - 32usize];
};
#[doc = " Callback type for run action."]
pub type ecs_app_run_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        desc: *mut ecs_app_desc_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback type for frame action."]
pub type ecs_app_frame_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        desc: *const ecs_app_desc_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Run application.\n This will run the application with the parameters specified in desc. After\n the application quits (ecs_quit() is called) the world will be cleaned up.\n\n If a custom run action is set, it will be invoked by this operation. The\n default run action calls the frame action in a loop until it returns a\n non-zero value.\n\n @param world The world.\n @param desc Application parameters."]
    pub fn ecs_app_run(world: *mut ecs_world_t, desc: *mut ecs_app_desc_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Default frame callback.\n This operation will run a single frame. By default this operation will invoke\n ecs_progress() directly, unless a custom frame action is set.\n\n @param world The world.\n @param desc The desc struct passed to ecs_app_run().\n @return value returned by ecs_progress()"]
    pub fn ecs_app_run_frame(
        world: *mut ecs_world_t,
        desc: *const ecs_app_desc_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set custom run action.\n See ecs_app_run().\n\n @param callback The run action."]
    pub fn ecs_app_set_run_action(callback: ecs_app_run_action_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set custom frame action.\n See ecs_app_run_frame().\n\n @param callback The frame action."]
    pub fn ecs_app_set_frame_action(callback: ecs_app_frame_action_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_server_t {
    _unused: [u8; 0],
}
#[doc = " A connection manages communication with the remote host."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_connection_t {
    pub id: u64,
    pub server: *mut ecs_http_server_t,
    pub host: [::std::os::raw::c_char; 128usize],
    pub port: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_http_connection_t"][::std::mem::size_of::<ecs_http_connection_t>() - 160usize];
    ["Alignment of ecs_http_connection_t"]
        [::std::mem::align_of::<ecs_http_connection_t>() - 8usize];
    ["Offset of field: ecs_http_connection_t::id"]
        [::std::mem::offset_of!(ecs_http_connection_t, id) - 0usize];
    ["Offset of field: ecs_http_connection_t::server"]
        [::std::mem::offset_of!(ecs_http_connection_t, server) - 8usize];
    ["Offset of field: ecs_http_connection_t::host"]
        [::std::mem::offset_of!(ecs_http_connection_t, host) - 16usize];
    ["Offset of field: ecs_http_connection_t::port"]
        [::std::mem::offset_of!(ecs_http_connection_t, port) - 144usize];
};
#[doc = " Helper type used for headers & URL query parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_key_value_t {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_http_key_value_t"][::std::mem::size_of::<ecs_http_key_value_t>() - 16usize];
    ["Alignment of ecs_http_key_value_t"][::std::mem::align_of::<ecs_http_key_value_t>() - 8usize];
    ["Offset of field: ecs_http_key_value_t::key"]
        [::std::mem::offset_of!(ecs_http_key_value_t, key) - 0usize];
    ["Offset of field: ecs_http_key_value_t::value"]
        [::std::mem::offset_of!(ecs_http_key_value_t, value) - 8usize];
};
pub const ecs_http_method_t_EcsHttpGet: ecs_http_method_t = 0;
pub const ecs_http_method_t_EcsHttpPost: ecs_http_method_t = 1;
pub const ecs_http_method_t_EcsHttpPut: ecs_http_method_t = 2;
pub const ecs_http_method_t_EcsHttpDelete: ecs_http_method_t = 3;
pub const ecs_http_method_t_EcsHttpOptions: ecs_http_method_t = 4;
pub const ecs_http_method_t_EcsHttpMethodUnsupported: ecs_http_method_t = 5;
#[doc = " Supported request methods."]
pub type ecs_http_method_t = ::std::os::raw::c_int;
#[doc = " An HTTP request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_request_t {
    pub id: u64,
    pub method: ecs_http_method_t,
    pub path: *mut ::std::os::raw::c_char,
    pub body: *mut ::std::os::raw::c_char,
    pub headers: [ecs_http_key_value_t; 32usize],
    pub params: [ecs_http_key_value_t; 32usize],
    pub header_count: i32,
    pub param_count: i32,
    pub conn: *mut ecs_http_connection_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_http_request_t"][::std::mem::size_of::<ecs_http_request_t>() - 1072usize];
    ["Alignment of ecs_http_request_t"][::std::mem::align_of::<ecs_http_request_t>() - 8usize];
    ["Offset of field: ecs_http_request_t::id"]
        [::std::mem::offset_of!(ecs_http_request_t, id) - 0usize];
    ["Offset of field: ecs_http_request_t::method"]
        [::std::mem::offset_of!(ecs_http_request_t, method) - 8usize];
    ["Offset of field: ecs_http_request_t::path"]
        [::std::mem::offset_of!(ecs_http_request_t, path) - 16usize];
    ["Offset of field: ecs_http_request_t::body"]
        [::std::mem::offset_of!(ecs_http_request_t, body) - 24usize];
    ["Offset of field: ecs_http_request_t::headers"]
        [::std::mem::offset_of!(ecs_http_request_t, headers) - 32usize];
    ["Offset of field: ecs_http_request_t::params"]
        [::std::mem::offset_of!(ecs_http_request_t, params) - 544usize];
    ["Offset of field: ecs_http_request_t::header_count"]
        [::std::mem::offset_of!(ecs_http_request_t, header_count) - 1056usize];
    ["Offset of field: ecs_http_request_t::param_count"]
        [::std::mem::offset_of!(ecs_http_request_t, param_count) - 1060usize];
    ["Offset of field: ecs_http_request_t::conn"]
        [::std::mem::offset_of!(ecs_http_request_t, conn) - 1064usize];
};
#[doc = " An HTTP reply."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_reply_t {
    #[doc = "< default = 200"]
    pub code: ::std::os::raw::c_int,
    #[doc = "< default = \"\""]
    pub body: ecs_strbuf_t,
    #[doc = "< default = OK"]
    pub status: *const ::std::os::raw::c_char,
    #[doc = "< default = application/json"]
    pub content_type: *const ::std::os::raw::c_char,
    #[doc = "< default = \"\""]
    pub headers: ecs_strbuf_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_http_reply_t"][::std::mem::size_of::<ecs_http_reply_t>() - 2120usize];
    ["Alignment of ecs_http_reply_t"][::std::mem::align_of::<ecs_http_reply_t>() - 8usize];
    ["Offset of field: ecs_http_reply_t::code"]
        [::std::mem::offset_of!(ecs_http_reply_t, code) - 0usize];
    ["Offset of field: ecs_http_reply_t::body"]
        [::std::mem::offset_of!(ecs_http_reply_t, body) - 8usize];
    ["Offset of field: ecs_http_reply_t::status"]
        [::std::mem::offset_of!(ecs_http_reply_t, status) - 1056usize];
    ["Offset of field: ecs_http_reply_t::content_type"]
        [::std::mem::offset_of!(ecs_http_reply_t, content_type) - 1064usize];
    ["Offset of field: ecs_http_reply_t::headers"]
        [::std::mem::offset_of!(ecs_http_reply_t, headers) - 1072usize];
};
extern "C" {
    #[doc = "< Total number of HTTP requests received."]
    pub static mut ecs_http_request_received_count: i64;
}
extern "C" {
    #[doc = "< Total number of invalid HTTP requests."]
    pub static mut ecs_http_request_invalid_count: i64;
}
extern "C" {
    #[doc = "< Total number of successful HTTP requests."]
    pub static mut ecs_http_request_handled_ok_count: i64;
}
extern "C" {
    #[doc = "< Total number of HTTP requests with errors."]
    pub static mut ecs_http_request_handled_error_count: i64;
}
extern "C" {
    #[doc = "< Total number of HTTP requests with an unknown endpoint."]
    pub static mut ecs_http_request_not_handled_count: i64;
}
extern "C" {
    #[doc = "< Total number of preflight HTTP requests received."]
    pub static mut ecs_http_request_preflight_count: i64;
}
extern "C" {
    #[doc = "< Total number of HTTP replies successfully sent."]
    pub static mut ecs_http_send_ok_count: i64;
}
extern "C" {
    #[doc = "< Total number of HTTP replies that failed to send."]
    pub static mut ecs_http_send_error_count: i64;
}
extern "C" {
    #[doc = "< Total number of HTTP busy replies."]
    pub static mut ecs_http_busy_count: i64;
}
#[doc = " Request callback.\n Invoked for each valid request. The function should populate the reply and\n return true. When the function returns false, the server will reply with a\n 404 (Not found) code."]
pub type ecs_http_reply_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const ecs_http_request_t,
        reply: *mut ecs_http_reply_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " Used with ecs_http_server_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_http_server_desc_t {
    #[doc = "< Function called for each request"]
    pub callback: ecs_http_reply_action_t,
    #[doc = "< Passed to callback (optional)"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< HTTP port"]
    pub port: u16,
    #[doc = "< Interface to listen on (optional)"]
    pub ipaddr: *const ::std::os::raw::c_char,
    #[doc = "< Send queue wait time when empty"]
    pub send_queue_wait_ms: i32,
    #[doc = "< Cache invalidation timeout (0 disables caching)"]
    pub cache_timeout: f64,
    #[doc = "< Cache purge timeout (for purging cache entries)"]
    pub cache_purge_timeout: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_http_server_desc_t"][::std::mem::size_of::<ecs_http_server_desc_t>() - 56usize];
    ["Alignment of ecs_http_server_desc_t"]
        [::std::mem::align_of::<ecs_http_server_desc_t>() - 8usize];
    ["Offset of field: ecs_http_server_desc_t::callback"]
        [::std::mem::offset_of!(ecs_http_server_desc_t, callback) - 0usize];
    ["Offset of field: ecs_http_server_desc_t::ctx"]
        [::std::mem::offset_of!(ecs_http_server_desc_t, ctx) - 8usize];
    ["Offset of field: ecs_http_server_desc_t::port"]
        [::std::mem::offset_of!(ecs_http_server_desc_t, port) - 16usize];
    ["Offset of field: ecs_http_server_desc_t::ipaddr"]
        [::std::mem::offset_of!(ecs_http_server_desc_t, ipaddr) - 24usize];
    ["Offset of field: ecs_http_server_desc_t::send_queue_wait_ms"]
        [::std::mem::offset_of!(ecs_http_server_desc_t, send_queue_wait_ms) - 32usize];
    ["Offset of field: ecs_http_server_desc_t::cache_timeout"]
        [::std::mem::offset_of!(ecs_http_server_desc_t, cache_timeout) - 40usize];
    ["Offset of field: ecs_http_server_desc_t::cache_purge_timeout"]
        [::std::mem::offset_of!(ecs_http_server_desc_t, cache_purge_timeout) - 48usize];
};
extern "C" {
    #[doc = " Create server.\n Use ecs_http_server_start() to start receiving requests.\n\n @param desc Server configuration parameters.\n @return The new server, or NULL if creation failed."]
    pub fn ecs_http_server_init(desc: *const ecs_http_server_desc_t) -> *mut ecs_http_server_t;
}
extern "C" {
    #[doc = " Destroy server.\n This operation will stop the server if it was still running.\n\n @param server The server to destroy."]
    pub fn ecs_http_server_fini(server: *mut ecs_http_server_t);
}
extern "C" {
    #[doc = " Start server.\n After this operation the server will be able to accept requests.\n\n @param server The server to start.\n @return Zero if successful, non-zero if failed."]
    pub fn ecs_http_server_start(server: *mut ecs_http_server_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Process server requests.\n This operation invokes the reply callback for each received request. No new\n requests will be enqueued while processing requests.\n\n @param server The server for which to process requests."]
    pub fn ecs_http_server_dequeue(server: *mut ecs_http_server_t, delta_time: f32);
}
extern "C" {
    #[doc = " Stop server.\n After this operation no new requests can be received.\n\n @param server The server."]
    pub fn ecs_http_server_stop(server: *mut ecs_http_server_t);
}
extern "C" {
    #[doc = " Emulate a request.\n The request string must be a valid HTTP request. A minimal example:\n\n     GET /entity/flecs/core/World?label=true HTTP/1.1\n\n @param srv The server.\n @param req The request.\n @param len The length of the request (optional).\n @return The reply."]
    pub fn ecs_http_server_http_request(
        srv: *mut ecs_http_server_t,
        req: *const ::std::os::raw::c_char,
        len: ecs_size_t,
        reply_out: *mut ecs_http_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience wrapper around ecs_http_server_http_request()."]
    pub fn ecs_http_server_request(
        srv: *mut ecs_http_server_t,
        method: *const ::std::os::raw::c_char,
        req: *const ::std::os::raw::c_char,
        reply_out: *mut ecs_http_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get context provided in ecs_http_server_desc_t"]
    pub fn ecs_http_server_ctx(srv: *mut ecs_http_server_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Find header in request.\n\n @param req The request.\n @param name name of the header to find\n @return The header value, or NULL if not found."]
    pub fn ecs_http_get_header(
        req: *const ecs_http_request_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Find query parameter in request.\n\n @param req The request.\n @param name The parameter name.\n @return The decoded parameter value, or NULL if not found."]
    pub fn ecs_http_get_param(
        req: *const ecs_http_request_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Component that instantiates the REST API."]
    pub static FLECS_IDEcsRestID_: ecs_entity_t;
}
#[doc = " Component that creates a REST API server when instantiated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsRest {
    #[doc = "< Port of server (optional, default = 27750)"]
    pub port: u16,
    #[doc = "< Interface address (optional, default = 0.0.0.0)"]
    pub ipaddr: *mut ::std::os::raw::c_char,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsRest"][::std::mem::size_of::<EcsRest>() - 24usize];
    ["Alignment of EcsRest"][::std::mem::align_of::<EcsRest>() - 8usize];
    ["Offset of field: EcsRest::port"][::std::mem::offset_of!(EcsRest, port) - 0usize];
    ["Offset of field: EcsRest::ipaddr"][::std::mem::offset_of!(EcsRest, ipaddr) - 8usize];
    ["Offset of field: EcsRest::impl_"][::std::mem::offset_of!(EcsRest, impl_) - 16usize];
};
extern "C" {
    #[doc = " Create HTTP server for REST API.\n This allows for the creation of a REST server that can be managed by the\n application without using Flecs systems.\n\n @param world The world.\n @param desc The HTTP server descriptor.\n @return The HTTP server, or NULL if failed."]
    pub fn ecs_rest_server_init(
        world: *mut ecs_world_t,
        desc: *const ecs_http_server_desc_t,
    ) -> *mut ecs_http_server_t;
}
extern "C" {
    #[doc = " Cleanup REST HTTP server.\n The server must have been created with ecs_rest_server_init()."]
    pub fn ecs_rest_server_fini(srv: *mut ecs_http_server_t);
}
extern "C" {
    #[doc = " Rest module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsRest)\n @endcode\n\n @param world The world."]
    pub fn FlecsRestImport(world: *mut ecs_world_t);
}
#[doc = " Component used for one shot/interval timer functionality"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsTimer {
    #[doc = "< Timer timeout period"]
    pub timeout: f32,
    #[doc = "< Incrementing time value"]
    pub time: f32,
    #[doc = "< Used to correct returned interval time"]
    pub overshoot: f32,
    #[doc = "< Number of times ticked"]
    pub fired_count: i32,
    #[doc = "< Is the timer active or not"]
    pub active: bool,
    #[doc = "< Is this a single shot timer"]
    pub single_shot: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsTimer"][::std::mem::size_of::<EcsTimer>() - 20usize];
    ["Alignment of EcsTimer"][::std::mem::align_of::<EcsTimer>() - 4usize];
    ["Offset of field: EcsTimer::timeout"][::std::mem::offset_of!(EcsTimer, timeout) - 0usize];
    ["Offset of field: EcsTimer::time"][::std::mem::offset_of!(EcsTimer, time) - 4usize];
    ["Offset of field: EcsTimer::overshoot"][::std::mem::offset_of!(EcsTimer, overshoot) - 8usize];
    ["Offset of field: EcsTimer::fired_count"]
        [::std::mem::offset_of!(EcsTimer, fired_count) - 12usize];
    ["Offset of field: EcsTimer::active"][::std::mem::offset_of!(EcsTimer, active) - 16usize];
    ["Offset of field: EcsTimer::single_shot"]
        [::std::mem::offset_of!(EcsTimer, single_shot) - 17usize];
};
#[doc = " Apply a rate filter to a tick source"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsRateFilter {
    #[doc = "< Source of the rate filter"]
    pub src: ecs_entity_t,
    #[doc = "< Rate of the rate filter"]
    pub rate: i32,
    #[doc = "< Number of times the rate filter ticked"]
    pub tick_count: i32,
    #[doc = "< Time elapsed since last tick"]
    pub time_elapsed: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsRateFilter"][::std::mem::size_of::<EcsRateFilter>() - 24usize];
    ["Alignment of EcsRateFilter"][::std::mem::align_of::<EcsRateFilter>() - 8usize];
    ["Offset of field: EcsRateFilter::src"][::std::mem::offset_of!(EcsRateFilter, src) - 0usize];
    ["Offset of field: EcsRateFilter::rate"][::std::mem::offset_of!(EcsRateFilter, rate) - 8usize];
    ["Offset of field: EcsRateFilter::tick_count"]
        [::std::mem::offset_of!(EcsRateFilter, tick_count) - 12usize];
    ["Offset of field: EcsRateFilter::time_elapsed"]
        [::std::mem::offset_of!(EcsRateFilter, time_elapsed) - 16usize];
};
extern "C" {
    #[doc = " Set timer timeout.\n This operation executes any systems associated with the timer after the\n specified timeout value. If the entity contains an existing timer, the\n timeout value will be reset. The timer can be started and stopped with\n ecs_start_timer() and ecs_stop_timer().\n\n The timer is synchronous, and is incremented each frame by delta_time.\n\n The tick_source entity will be a tick source after this operation. Tick\n sources can be read by getting the EcsTickSource component. If the tick\n source ticked this frame, the 'tick' member will be true. When the tick\n source is a system, the system will tick when the timer ticks.\n\n @param world The world.\n @param tick_source The timer for which to set the timeout (0 to create one).\n @param timeout The timeout value.\n @return The timer entity."]
    pub fn ecs_set_timeout(
        world: *mut ecs_world_t,
        tick_source: ecs_entity_t,
        timeout: f32,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get current timeout value for the specified timer.\n This operation returns the value set by ecs_set_timeout(). If no timer is\n active for this entity, the operation returns 0.\n\n After the timeout expires the EcsTimer component is removed from the entity.\n This means that if ecs_get_timeout() is invoked after the timer is expired, the\n operation will return 0.\n\n The timer is synchronous, and is incremented each frame by delta_time.\n\n The tick_source entity will be a tick source after this operation. Tick\n sources can be read by getting the EcsTickSource component. If the tick\n source ticked this frame, the 'tick' member will be true. When the tick\n source is a system, the system will tick when the timer ticks.\n\n @param world The world.\n @param tick_source The timer.\n @return The current timeout value, or 0 if no timer is active."]
    pub fn ecs_get_timeout(world: *const ecs_world_t, tick_source: ecs_entity_t) -> f32;
}
extern "C" {
    #[doc = " Set timer interval.\n This operation will continuously invoke systems associated with the timer\n after the interval period expires. If the entity contains an existing timer,\n the interval value will be reset.\n\n The timer is synchronous, and is incremented each frame by delta_time.\n\n The tick_source entity will be a tick source after this operation. Tick\n sources can be read by getting the EcsTickSource component. If the tick\n source ticked this frame, the 'tick' member will be true. When the tick\n source is a system, the system will tick when the timer ticks.\n\n @param world The world.\n @param tick_source The timer for which to set the interval (0 to create one).\n @param interval The interval value.\n @return The timer entity."]
    pub fn ecs_set_interval(
        world: *mut ecs_world_t,
        tick_source: ecs_entity_t,
        interval: f32,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get current interval value for the specified timer.\n This operation returns the value set by ecs_set_interval(). If the entity is\n not a timer, the operation will return 0.\n\n @param world The world.\n @param tick_source The timer for which to set the interval.\n @return The current interval value, or 0 if no timer is active."]
    pub fn ecs_get_interval(world: *const ecs_world_t, tick_source: ecs_entity_t) -> f32;
}
extern "C" {
    #[doc = " Start timer.\n This operation resets the timer and starts it with the specified timeout.\n\n @param world The world.\n @param tick_source The timer to start."]
    pub fn ecs_start_timer(world: *mut ecs_world_t, tick_source: ecs_entity_t);
}
extern "C" {
    #[doc = " Stop timer\n This operation stops a timer from triggering.\n\n @param world The world.\n @param tick_source The timer to stop."]
    pub fn ecs_stop_timer(world: *mut ecs_world_t, tick_source: ecs_entity_t);
}
extern "C" {
    #[doc = " Reset time value of timer to 0.\n This operation resets the timer value to 0.\n\n @param world The world.\n @param tick_source The timer to reset."]
    pub fn ecs_reset_timer(world: *mut ecs_world_t, tick_source: ecs_entity_t);
}
extern "C" {
    #[doc = " Enable randomizing initial time value of timers.\n Initializes timers with a random time value, which can improve scheduling as\n systems/timers for the same interval don't all happen on the same tick.\n\n @param world The world."]
    pub fn ecs_randomize_timers(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Set rate filter.\n This operation initializes a rate filter. Rate filters sample tick sources\n and tick at a configurable multiple. A rate filter is a tick source itself,\n which means that rate filters can be chained.\n\n Rate filters enable deterministic system execution which cannot be achieved\n with interval timers alone. For example, if timer A has interval 2.0 and\n timer B has interval 4.0, it is not guaranteed that B will tick at exactly\n twice the multiple of A. This is partly due to the indeterministic nature of\n timers, and partly due to floating point rounding errors.\n\n Rate filters can be combined with timers (or other rate filters) to ensure\n that a system ticks at an exact multiple of a tick source (which can be\n another system). If a rate filter is created with a rate of 1 it will tick\n at the exact same time as its source.\n\n If no tick source is provided, the rate filter will use the frame tick as\n source, which corresponds with the number of times ecs_progress() is called.\n\n The tick_source entity will be a tick source after this operation. Tick\n sources can be read by getting the EcsTickSource component. If the tick\n source ticked this frame, the 'tick' member will be true. When the tick\n source is a system, the system will tick when the timer ticks.\n\n @param world The world.\n @param tick_source The rate filter entity (0 to create one).\n @param rate The rate to apply.\n @param source The tick source (0 to use frames)\n @return The filter entity."]
    pub fn ecs_set_rate(
        world: *mut ecs_world_t,
        tick_source: ecs_entity_t,
        rate: i32,
        source: ecs_entity_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Assign tick source to system.\n Systems can be their own tick source, which can be any of the tick sources\n (one shot timers, interval times and rate filters). However, in some cases it\n is must be guaranteed that different systems tick on the exact same frame.\n\n This cannot be guaranteed by giving two systems the same interval/rate filter\n as it is possible that one system is (for example) disabled, which would\n cause the systems to go out of sync. To provide these guarantees, systems\n must use the same tick source, which is what this operation enables.\n\n When two systems share the same tick source, it is guaranteed that they tick\n in the same frame. The provided tick source can be any entity that is a tick\n source, including another system. If the provided entity is not a tick source\n the system will not be ran.\n\n To disassociate a tick source from a system, use 0 for the tick_source\n parameter.\n\n @param world The world.\n @param system The system to associate with the timer.\n @param tick_source The tick source to associate with the system."]
    pub fn ecs_set_tick_source(
        world: *mut ecs_world_t,
        system: ecs_entity_t,
        tick_source: ecs_entity_t,
    );
}
extern "C" {
    #[doc = " Timer module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsTimer)\n @endcode\n\n @param world The world."]
    pub fn FlecsTimerImport(world: *mut ecs_world_t);
}
#[doc = " Pipeline descriptor, used with ecs_pipeline_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_pipeline_desc_t {
    #[doc = " Existing entity to associate with pipeline (optional)."]
    pub entity: ecs_entity_t,
    #[doc = " The pipeline query.\n Pipelines are queries that are matched with system entities. Pipeline\n queries are the same as regular queries, which means the same query rules\n apply. A common mistake is to try a pipeline that matches systems in a\n list of phases by specifying all the phases, like:\n   OnUpdate, OnPhysics, OnRender\n\n That however creates a query that matches entities with OnUpdate _and_\n OnPhysics _and_ OnRender tags, which is likely undesired. Instead, a\n query could use the or operator match a system that has one of the\n specified phases:\n   OnUpdate || OnPhysics || OnRender\n\n This will return the correct set of systems, but they likely won't be in\n the correct order. To make sure systems are returned in the correct order\n two query ordering features can be used:\n - group_by\n - order_by\n\n Take a look at the system manual for a more detailed explanation of\n how query features can be applied to pipelines, and how the builtin\n pipeline query works."]
    pub query: ecs_query_desc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_pipeline_desc_t"][::std::mem::size_of::<ecs_pipeline_desc_t>() - 2448usize];
    ["Alignment of ecs_pipeline_desc_t"][::std::mem::align_of::<ecs_pipeline_desc_t>() - 8usize];
    ["Offset of field: ecs_pipeline_desc_t::entity"]
        [::std::mem::offset_of!(ecs_pipeline_desc_t, entity) - 0usize];
    ["Offset of field: ecs_pipeline_desc_t::query"]
        [::std::mem::offset_of!(ecs_pipeline_desc_t, query) - 8usize];
};
extern "C" {
    #[doc = " Create a custom pipeline.\n\n @param world The world.\n @param desc The pipeline descriptor.\n @return The pipeline, 0 if failed."]
    pub fn ecs_pipeline_init(
        world: *mut ecs_world_t,
        desc: *const ecs_pipeline_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set a custom pipeline.\n This operation sets the pipeline to run when ecs_progress() is invoked.\n\n @param world The world.\n @param pipeline The pipeline to set."]
    pub fn ecs_set_pipeline(world: *mut ecs_world_t, pipeline: ecs_entity_t);
}
extern "C" {
    #[doc = " Get the current pipeline.\n This operation gets the current pipeline.\n\n @param world The world.\n @return The current pipeline."]
    pub fn ecs_get_pipeline(world: *const ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Progress a world.\n This operation progresses the world by running all systems that are both\n enabled and periodic on their matching entities.\n\n An application can pass a delta_time into the function, which is the time\n passed since the last frame. This value is passed to systems so they can\n update entity values proportional to the elapsed time since their last\n invocation.\n\n When an application passes 0 to delta_time, ecs_progress() will automatically\n measure the time passed since the last frame. If an application does not uses\n time management, it should pass a non-zero value for delta_time (1.0 is\n recommended). That way, no time will be wasted measuring the time.\n\n @param world The world to progress.\n @param delta_time The time passed since the last frame.\n @return false if ecs_quit() has been called, true otherwise."]
    pub fn ecs_progress(world: *mut ecs_world_t, delta_time: f32) -> bool;
}
extern "C" {
    #[doc = " Set time scale.\n Increase or decrease simulation speed by the provided multiplier.\n\n @param world The world.\n @param scale The scale to apply (default = 1)."]
    pub fn ecs_set_time_scale(world: *mut ecs_world_t, scale: f32);
}
extern "C" {
    #[doc = " Reset world clock.\n Reset the clock that keeps track of the total time passed in the simulation.\n\n @param world The world."]
    pub fn ecs_reset_clock(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Run pipeline.\n This will run all systems in the provided pipeline. This operation may be\n invoked from multiple threads, and only when staging is disabled, as the\n pipeline manages staging and, if necessary, synchronization between threads.\n\n If 0 is provided for the pipeline id, the default pipeline will be ran (this\n is either the builtin pipeline or the pipeline set with set_pipeline()).\n\n When using progress() this operation will be invoked automatically for the\n default pipeline (either the builtin pipeline or the pipeline set with\n set_pipeline()). An application may run additional pipelines.\n\n @param world The world.\n @param pipeline The pipeline to run.\n @param delta_time The delta_time to pass to systems."]
    pub fn ecs_run_pipeline(world: *mut ecs_world_t, pipeline: ecs_entity_t, delta_time: f32);
}
extern "C" {
    #[doc = " Set number of worker threads.\n Setting this value to a value higher than 1 will start as many threads and\n will cause systems to evenly distribute matched entities across threads. The\n operation may be called multiple times to reconfigure the number of threads\n used, but never while running a system / pipeline.\n Calling ecs_set_threads() will also end the use of task threads setup with\n ecs_set_task_threads() and vice-versa.\n\n @param world The world.\n @param threads The number of threads to create."]
    pub fn ecs_set_threads(world: *mut ecs_world_t, threads: i32);
}
extern "C" {
    #[doc = " Set number of worker task threads.\n ecs_set_task_threads() is similar to ecs_set_threads(), except threads are treated\n as short-lived tasks and will be created and joined around each update of the world.\n Creation and joining of these tasks will use the os_api_t tasks APIs rather than the\n the standard thread API functions, although they may be the same if desired.\n This function is useful for multithreading world updates using an external\n asynchronous job system rather than long running threads by providing the APIs\n to create tasks for your job system and then wait on their conclusion.\n The operation may be called multiple times to reconfigure the number of task threads\n used, but never while running a system / pipeline.\n Calling ecs_set_task_threads() will also end the use of threads setup with\n ecs_set_threads() and vice-versa\n\n @param world The world.\n @param task_threads The number of task threads to create."]
    pub fn ecs_set_task_threads(world: *mut ecs_world_t, task_threads: i32);
}
extern "C" {
    #[doc = " Returns true if task thread use have been requested.\n\n @param world The world.\n @result Whether the world is using task threads."]
    pub fn ecs_using_task_threads(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Pipeline module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsPipeline)\n @endcode\n\n @param world The world."]
    pub fn FlecsPipelineImport(world: *mut ecs_world_t);
}
#[doc = " Component used to provide a tick source to systems"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsTickSource {
    #[doc = "< True if providing tick"]
    pub tick: bool,
    #[doc = "< Time elapsed since last tick"]
    pub time_elapsed: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsTickSource"][::std::mem::size_of::<EcsTickSource>() - 8usize];
    ["Alignment of EcsTickSource"][::std::mem::align_of::<EcsTickSource>() - 4usize];
    ["Offset of field: EcsTickSource::tick"][::std::mem::offset_of!(EcsTickSource, tick) - 0usize];
    ["Offset of field: EcsTickSource::time_elapsed"]
        [::std::mem::offset_of!(EcsTickSource, time_elapsed) - 4usize];
};
#[doc = " Use with ecs_system_init() to create or update a system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_system_desc_t {
    pub _canary: i32,
    #[doc = " Existing entity to associate with system (optional)"]
    pub entity: ecs_entity_t,
    #[doc = " System query parameters"]
    pub query: ecs_query_desc_t,
    #[doc = " Callback that is ran for each result returned by the system's query. This\n means that this callback can be invoked multiple times per system per\n frame, typically once for each matching table."]
    pub callback: ecs_iter_action_t,
    #[doc = " Callback that is invoked when a system is ran.\n When left to NULL, the default system runner is used, which calls the\n \"callback\" action for each result returned from the system's query.\n\n It should not be assumed that the input iterator can always be iterated\n with ecs_query_next(). When a system is multithreaded and/or paged, the\n iterator can be either a worker or paged iterator. The correct function\n to use for iteration is ecs_iter_next().\n\n An implementation can test whether the iterator is a query iterator by\n testing whether the it->next value is equal to ecs_query_next()."]
    pub run: ecs_run_action_t,
    #[doc = " Context to be passed to callback (as ecs_iter_t::param)"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free ctx."]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = " Context associated with callback (for language bindings)."]
    pub callback_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free callback ctx."]
    pub callback_ctx_free: ecs_ctx_free_t,
    #[doc = " Context associated with run (for language bindings)."]
    pub run_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free run ctx."]
    pub run_ctx_free: ecs_ctx_free_t,
    #[doc = " Interval in seconds at which the system should run"]
    pub interval: f32,
    #[doc = " Rate at which the system should run"]
    pub rate: i32,
    #[doc = " External tick source that determines when system ticks"]
    pub tick_source: ecs_entity_t,
    #[doc = " If true, system will be ran on multiple threads"]
    pub multi_threaded: bool,
    #[doc = " If true, system will have access to the actual world. Cannot be true at the\n same time as multi_threaded."]
    pub immediate: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_system_desc_t"][::std::mem::size_of::<ecs_system_desc_t>() - 2544usize];
    ["Alignment of ecs_system_desc_t"][::std::mem::align_of::<ecs_system_desc_t>() - 8usize];
    ["Offset of field: ecs_system_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_system_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_system_desc_t::entity"]
        [::std::mem::offset_of!(ecs_system_desc_t, entity) - 8usize];
    ["Offset of field: ecs_system_desc_t::query"]
        [::std::mem::offset_of!(ecs_system_desc_t, query) - 16usize];
    ["Offset of field: ecs_system_desc_t::callback"]
        [::std::mem::offset_of!(ecs_system_desc_t, callback) - 2456usize];
    ["Offset of field: ecs_system_desc_t::run"]
        [::std::mem::offset_of!(ecs_system_desc_t, run) - 2464usize];
    ["Offset of field: ecs_system_desc_t::ctx"]
        [::std::mem::offset_of!(ecs_system_desc_t, ctx) - 2472usize];
    ["Offset of field: ecs_system_desc_t::ctx_free"]
        [::std::mem::offset_of!(ecs_system_desc_t, ctx_free) - 2480usize];
    ["Offset of field: ecs_system_desc_t::callback_ctx"]
        [::std::mem::offset_of!(ecs_system_desc_t, callback_ctx) - 2488usize];
    ["Offset of field: ecs_system_desc_t::callback_ctx_free"]
        [::std::mem::offset_of!(ecs_system_desc_t, callback_ctx_free) - 2496usize];
    ["Offset of field: ecs_system_desc_t::run_ctx"]
        [::std::mem::offset_of!(ecs_system_desc_t, run_ctx) - 2504usize];
    ["Offset of field: ecs_system_desc_t::run_ctx_free"]
        [::std::mem::offset_of!(ecs_system_desc_t, run_ctx_free) - 2512usize];
    ["Offset of field: ecs_system_desc_t::interval"]
        [::std::mem::offset_of!(ecs_system_desc_t, interval) - 2520usize];
    ["Offset of field: ecs_system_desc_t::rate"]
        [::std::mem::offset_of!(ecs_system_desc_t, rate) - 2524usize];
    ["Offset of field: ecs_system_desc_t::tick_source"]
        [::std::mem::offset_of!(ecs_system_desc_t, tick_source) - 2528usize];
    ["Offset of field: ecs_system_desc_t::multi_threaded"]
        [::std::mem::offset_of!(ecs_system_desc_t, multi_threaded) - 2536usize];
    ["Offset of field: ecs_system_desc_t::immediate"]
        [::std::mem::offset_of!(ecs_system_desc_t, immediate) - 2537usize];
};
extern "C" {
    #[doc = " Create a system"]
    pub fn ecs_system_init(world: *mut ecs_world_t, desc: *const ecs_system_desc_t)
        -> ecs_entity_t;
}
#[doc = " System type, get with ecs_system_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_system_t {
    pub hdr: ecs_header_t,
    #[doc = " See ecs_system_desc_t"]
    pub run: ecs_run_action_t,
    #[doc = " See ecs_system_desc_t"]
    pub action: ecs_iter_action_t,
    #[doc = " System query"]
    pub query: *mut ecs_query_t,
    #[doc = " Entity associated with query"]
    pub query_entity: ecs_entity_t,
    #[doc = " Tick source associated with system"]
    pub tick_source: ecs_entity_t,
    #[doc = " Is system multithreaded"]
    pub multi_threaded: bool,
    #[doc = " Is system ran in immediate mode"]
    pub immediate: bool,
    #[doc = " Userdata for system"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback language binding context"]
    pub callback_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Run language binding context"]
    pub run_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free ctx."]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = " Callback to free callback ctx."]
    pub callback_ctx_free: ecs_ctx_free_t,
    #[doc = " Callback to free run ctx."]
    pub run_ctx_free: ecs_ctx_free_t,
    #[doc = " Time spent on running system"]
    pub time_spent: f32,
    #[doc = " Time passed since last invocation"]
    pub time_passed: f32,
    #[doc = " Last frame for which the system was considered"]
    pub last_frame: i64,
    pub world: *mut ecs_world_t,
    pub entity: ecs_entity_t,
    pub dtor: flecs_poly_dtor_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_system_t"][::std::mem::size_of::<ecs_system_t>() - 160usize];
    ["Alignment of ecs_system_t"][::std::mem::align_of::<ecs_system_t>() - 8usize];
    ["Offset of field: ecs_system_t::hdr"][::std::mem::offset_of!(ecs_system_t, hdr) - 0usize];
    ["Offset of field: ecs_system_t::run"][::std::mem::offset_of!(ecs_system_t, run) - 24usize];
    ["Offset of field: ecs_system_t::action"]
        [::std::mem::offset_of!(ecs_system_t, action) - 32usize];
    ["Offset of field: ecs_system_t::query"][::std::mem::offset_of!(ecs_system_t, query) - 40usize];
    ["Offset of field: ecs_system_t::query_entity"]
        [::std::mem::offset_of!(ecs_system_t, query_entity) - 48usize];
    ["Offset of field: ecs_system_t::tick_source"]
        [::std::mem::offset_of!(ecs_system_t, tick_source) - 56usize];
    ["Offset of field: ecs_system_t::multi_threaded"]
        [::std::mem::offset_of!(ecs_system_t, multi_threaded) - 64usize];
    ["Offset of field: ecs_system_t::immediate"]
        [::std::mem::offset_of!(ecs_system_t, immediate) - 65usize];
    ["Offset of field: ecs_system_t::ctx"][::std::mem::offset_of!(ecs_system_t, ctx) - 72usize];
    ["Offset of field: ecs_system_t::callback_ctx"]
        [::std::mem::offset_of!(ecs_system_t, callback_ctx) - 80usize];
    ["Offset of field: ecs_system_t::run_ctx"]
        [::std::mem::offset_of!(ecs_system_t, run_ctx) - 88usize];
    ["Offset of field: ecs_system_t::ctx_free"]
        [::std::mem::offset_of!(ecs_system_t, ctx_free) - 96usize];
    ["Offset of field: ecs_system_t::callback_ctx_free"]
        [::std::mem::offset_of!(ecs_system_t, callback_ctx_free) - 104usize];
    ["Offset of field: ecs_system_t::run_ctx_free"]
        [::std::mem::offset_of!(ecs_system_t, run_ctx_free) - 112usize];
    ["Offset of field: ecs_system_t::time_spent"]
        [::std::mem::offset_of!(ecs_system_t, time_spent) - 120usize];
    ["Offset of field: ecs_system_t::time_passed"]
        [::std::mem::offset_of!(ecs_system_t, time_passed) - 124usize];
    ["Offset of field: ecs_system_t::last_frame"]
        [::std::mem::offset_of!(ecs_system_t, last_frame) - 128usize];
    ["Offset of field: ecs_system_t::world"]
        [::std::mem::offset_of!(ecs_system_t, world) - 136usize];
    ["Offset of field: ecs_system_t::entity"]
        [::std::mem::offset_of!(ecs_system_t, entity) - 144usize];
    ["Offset of field: ecs_system_t::dtor"][::std::mem::offset_of!(ecs_system_t, dtor) - 152usize];
};
extern "C" {
    #[doc = " Get system object.\n Returns the system object. Can be used to access various information about\n the system, like the query and context.\n\n @param world The world.\n @param system The system.\n @return The system object."]
    pub fn ecs_system_get(world: *const ecs_world_t, system: ecs_entity_t) -> *const ecs_system_t;
}
extern "C" {
    #[doc = " Run a specific system manually.\n This operation runs a single system manually. It is an efficient way to\n invoke logic on a set of entities, as manual systems are only matched to\n tables at creation time or after creation time, when a new table is created.\n\n Manual systems are useful to evaluate lists of pre-matched entities at\n application defined times. Because none of the matching logic is evaluated\n before the system is invoked, manual systems are much more efficient than\n manually obtaining a list of entities and retrieving their components.\n\n An application may pass custom data to a system through the param parameter.\n This data can be accessed by the system through the param member in the\n ecs_iter_t value that is passed to the system callback.\n\n Any system may interrupt execution by setting the interrupted_by member in\n the ecs_iter_t value. This is particularly useful for manual systems, where\n the value of interrupted_by is returned by this operation. This, in\n combination with the param argument lets applications use manual systems\n to lookup entities: once the entity has been found its handle is passed to\n interrupted_by, which is then subsequently returned.\n\n @param world The world.\n @param system The system to run.\n @param delta_time The time passed since the last system invocation.\n @param param A user-defined parameter to pass to the system.\n @return handle to last evaluated entity if system was interrupted."]
    pub fn ecs_run(
        world: *mut ecs_world_t,
        system: ecs_entity_t,
        delta_time: f32,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Same as ecs_run(), but subdivides entities across number of provided stages.\n\n @param world The world.\n @param system The system to run.\n @param stage_current The id of the current stage.\n @param stage_count The total number of stages.\n @param delta_time The time passed since the last system invocation.\n @param param A user-defined parameter to pass to the system.\n @return handle to last evaluated entity if system was interrupted."]
    pub fn ecs_run_worker(
        world: *mut ecs_world_t,
        system: ecs_entity_t,
        stage_current: i32,
        stage_count: i32,
        delta_time: f32,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " System module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsSystem)\n @endcode\n\n @param world The world."]
    pub fn FlecsSystemImport(world: *mut ecs_world_t);
}
#[doc = " Simple value that indicates current state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_gauge_t {
    pub avg: [f32; 60usize],
    pub min: [f32; 60usize],
    pub max: [f32; 60usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_gauge_t"][::std::mem::size_of::<ecs_gauge_t>() - 720usize];
    ["Alignment of ecs_gauge_t"][::std::mem::align_of::<ecs_gauge_t>() - 4usize];
    ["Offset of field: ecs_gauge_t::avg"][::std::mem::offset_of!(ecs_gauge_t, avg) - 0usize];
    ["Offset of field: ecs_gauge_t::min"][::std::mem::offset_of!(ecs_gauge_t, min) - 240usize];
    ["Offset of field: ecs_gauge_t::max"][::std::mem::offset_of!(ecs_gauge_t, max) - 480usize];
};
#[doc = " Monotonically increasing counter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_counter_t {
    #[doc = "< Keep track of deltas too"]
    pub rate: ecs_gauge_t,
    pub value: [f64; 60usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_counter_t"][::std::mem::size_of::<ecs_counter_t>() - 1200usize];
    ["Alignment of ecs_counter_t"][::std::mem::align_of::<ecs_counter_t>() - 8usize];
    ["Offset of field: ecs_counter_t::rate"][::std::mem::offset_of!(ecs_counter_t, rate) - 0usize];
    ["Offset of field: ecs_counter_t::value"]
        [::std::mem::offset_of!(ecs_counter_t, value) - 720usize];
};
#[doc = " Make all metrics the same size, so we can iterate over fields"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ecs_metric_t {
    pub gauge: ecs_gauge_t,
    pub counter: ecs_counter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_metric_t"][::std::mem::size_of::<ecs_metric_t>() - 1200usize];
    ["Alignment of ecs_metric_t"][::std::mem::align_of::<ecs_metric_t>() - 8usize];
    ["Offset of field: ecs_metric_t::gauge"][::std::mem::offset_of!(ecs_metric_t, gauge) - 0usize];
    ["Offset of field: ecs_metric_t::counter"]
        [::std::mem::offset_of!(ecs_metric_t, counter) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t {
    pub first_: i64,
    pub entities: ecs_world_stats_t__bindgen_ty_1,
    pub components: ecs_world_stats_t__bindgen_ty_2,
    pub tables: ecs_world_stats_t__bindgen_ty_3,
    pub queries: ecs_world_stats_t__bindgen_ty_4,
    pub commands: ecs_world_stats_t__bindgen_ty_5,
    pub frame: ecs_world_stats_t__bindgen_ty_6,
    pub performance: ecs_world_stats_t__bindgen_ty_7,
    pub memory: ecs_world_stats_t__bindgen_ty_8,
    pub http: ecs_world_stats_t__bindgen_ty_9,
    pub last_: i64,
    #[doc = " Current position in ring buffer"]
    pub t: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_1 {
    #[doc = "< Number of entities"]
    pub count: ecs_metric_t,
    #[doc = "< Number of not alive (recyclable) entity ids"]
    pub not_alive_count: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_1"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_1>() - 2400usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_1"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_1::count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_1, count) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_1::not_alive_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_1, not_alive_count) - 1200usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_2 {
    #[doc = "< Number of tag ids (ids without data)"]
    pub tag_count: ecs_metric_t,
    #[doc = "< Number of components ids (ids with data)"]
    pub component_count: ecs_metric_t,
    #[doc = "< Number of pair ids"]
    pub pair_count: ecs_metric_t,
    #[doc = "< Number of registered types"]
    pub type_count: ecs_metric_t,
    #[doc = "< Number of times id has been created"]
    pub create_count: ecs_metric_t,
    #[doc = "< Number of times id has been deleted"]
    pub delete_count: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_2"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_2>() - 7200usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_2"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_2>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_2::tag_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_2, tag_count) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_2::component_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_2, component_count) - 1200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_2::pair_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_2, pair_count) - 2400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_2::type_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_2, type_count) - 3600usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_2::create_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_2, create_count) - 4800usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_2::delete_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_2, delete_count) - 6000usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_3 {
    #[doc = "< Number of tables"]
    pub count: ecs_metric_t,
    #[doc = "< Number of empty tables"]
    pub empty_count: ecs_metric_t,
    #[doc = "< Number of times table has been created"]
    pub create_count: ecs_metric_t,
    #[doc = "< Number of times table has been deleted"]
    pub delete_count: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_3"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_3>() - 4800usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_3"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_3>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_3::count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_3, count) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_3::empty_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_3, empty_count) - 1200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_3::create_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_3, create_count) - 2400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_3::delete_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_3, delete_count) - 3600usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_4 {
    #[doc = "< Number of queries"]
    pub query_count: ecs_metric_t,
    #[doc = "< Number of observers"]
    pub observer_count: ecs_metric_t,
    #[doc = "< Number of systems"]
    pub system_count: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_4"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_4>() - 3600usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_4"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_4>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_4::query_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_4, query_count) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_4::observer_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_4, observer_count) - 1200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_4::system_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_4, system_count) - 2400usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_5 {
    pub add_count: ecs_metric_t,
    pub remove_count: ecs_metric_t,
    pub delete_count: ecs_metric_t,
    pub clear_count: ecs_metric_t,
    pub set_count: ecs_metric_t,
    pub ensure_count: ecs_metric_t,
    pub modified_count: ecs_metric_t,
    pub other_count: ecs_metric_t,
    pub discard_count: ecs_metric_t,
    pub batched_entity_count: ecs_metric_t,
    pub batched_count: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_5"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_5>() - 13200usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_5"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_5>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::add_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, add_count) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::remove_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, remove_count) - 1200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::delete_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, delete_count) - 2400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::clear_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, clear_count) - 3600usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::set_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, set_count) - 4800usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::ensure_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, ensure_count) - 6000usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::modified_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, modified_count) - 7200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::other_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, other_count) - 8400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::discard_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, discard_count) - 9600usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::batched_entity_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_5,
        batched_entity_count
    ) - 10800usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_5::batched_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_5, batched_count) - 12000usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_6 {
    #[doc = "< Number of frames processed."]
    pub frame_count: ecs_metric_t,
    #[doc = "< Number of merges executed."]
    pub merge_count: ecs_metric_t,
    #[doc = "< Number of query rematches"]
    pub rematch_count: ecs_metric_t,
    #[doc = "< Number of system pipeline rebuilds (occurs when an inactive system becomes active)."]
    pub pipeline_build_count: ecs_metric_t,
    #[doc = "< Number of systems ran."]
    pub systems_ran: ecs_metric_t,
    #[doc = "< Number of times an observer was invoked."]
    pub observers_ran: ecs_metric_t,
    #[doc = "< Number of events emitted"]
    pub event_emit_count: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_6"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_6>() - 8400usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_6"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_6>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_6::frame_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_6, frame_count) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_6::merge_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_6, merge_count) - 1200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_6::rematch_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_6, rematch_count) - 2400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_6::pipeline_build_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_6, pipeline_build_count) - 3600usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_6::systems_ran"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_6, systems_ran) - 4800usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_6::observers_ran"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_6, observers_ran) - 6000usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_6::event_emit_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_6, event_emit_count) - 7200usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_7 {
    #[doc = "< Actual time passed since simulation start (first time progress() is called)"]
    pub world_time_raw: ecs_metric_t,
    #[doc = "< Simulation time passed since simulation start. Takes into account time scaling"]
    pub world_time: ecs_metric_t,
    #[doc = "< Time spent processing a frame. Smaller than world_time_total when load is not 100%"]
    pub frame_time: ecs_metric_t,
    #[doc = "< Time spent on running systems."]
    pub system_time: ecs_metric_t,
    #[doc = "< Time spent on notifying observers."]
    pub emit_time: ecs_metric_t,
    #[doc = "< Time spent on merging commands."]
    pub merge_time: ecs_metric_t,
    #[doc = "< Time spent on rematching."]
    pub rematch_time: ecs_metric_t,
    #[doc = "< Frames per second."]
    pub fps: ecs_metric_t,
    #[doc = "< Delta_time."]
    pub delta_time: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_7"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_7>() - 10800usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_7"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_7>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::world_time_raw"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, world_time_raw) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::world_time"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, world_time) - 1200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::frame_time"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, frame_time) - 2400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::system_time"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, system_time) - 3600usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::emit_time"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, emit_time) - 4800usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::merge_time"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, merge_time) - 6000usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::rematch_time"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, rematch_time) - 7200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::fps"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, fps) - 8400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_7::delta_time"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_7, delta_time) - 9600usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_8 {
    #[doc = "< Allocs per frame"]
    pub alloc_count: ecs_metric_t,
    #[doc = "< Reallocs per frame"]
    pub realloc_count: ecs_metric_t,
    #[doc = "< Frees per frame"]
    pub free_count: ecs_metric_t,
    #[doc = "< Difference between allocs & frees"]
    pub outstanding_alloc_count: ecs_metric_t,
    #[doc = "< Block allocations per frame"]
    pub block_alloc_count: ecs_metric_t,
    #[doc = "< Block frees per frame"]
    pub block_free_count: ecs_metric_t,
    #[doc = "< Difference between allocs & frees"]
    pub block_outstanding_alloc_count: ecs_metric_t,
    #[doc = "< Page allocations per frame"]
    pub stack_alloc_count: ecs_metric_t,
    #[doc = "< Page frees per frame"]
    pub stack_free_count: ecs_metric_t,
    #[doc = "< Difference between allocs & frees"]
    pub stack_outstanding_alloc_count: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_8"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_8>() - 12000usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_8"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_8>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::alloc_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_8, alloc_count) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::realloc_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_8, realloc_count) - 1200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::free_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_8, free_count) - 2400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::outstanding_alloc_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_8,
        outstanding_alloc_count
    ) - 3600usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::block_alloc_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_8, block_alloc_count) - 4800usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::block_free_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_8, block_free_count) - 6000usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::block_outstanding_alloc_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_8,
        block_outstanding_alloc_count
    )
        - 7200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::stack_alloc_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_8, stack_alloc_count) - 8400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::stack_free_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_8, stack_free_count) - 9600usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_8::stack_outstanding_alloc_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_8,
        stack_outstanding_alloc_count
    )
        - 10800usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_world_stats_t__bindgen_ty_9 {
    pub request_received_count: ecs_metric_t,
    pub request_invalid_count: ecs_metric_t,
    pub request_handled_ok_count: ecs_metric_t,
    pub request_handled_error_count: ecs_metric_t,
    pub request_not_handled_count: ecs_metric_t,
    pub request_preflight_count: ecs_metric_t,
    pub send_ok_count: ecs_metric_t,
    pub send_error_count: ecs_metric_t,
    pub busy_count: ecs_metric_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t__bindgen_ty_9"]
        [::std::mem::size_of::<ecs_world_stats_t__bindgen_ty_9>() - 10800usize];
    ["Alignment of ecs_world_stats_t__bindgen_ty_9"]
        [::std::mem::align_of::<ecs_world_stats_t__bindgen_ty_9>() - 8usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::request_received_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_9, request_received_count) - 0usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::request_invalid_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_9,
        request_invalid_count
    ) - 1200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::request_handled_ok_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_9,
        request_handled_ok_count
    ) - 2400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::request_handled_error_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_9,
        request_handled_error_count
    )
        - 3600usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::request_not_handled_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_9,
        request_not_handled_count
    ) - 4800usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::request_preflight_count"][::std::mem::offset_of!(
        ecs_world_stats_t__bindgen_ty_9,
        request_preflight_count
    ) - 6000usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::send_ok_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_9, send_ok_count) - 7200usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::send_error_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_9, send_error_count) - 8400usize];
    ["Offset of field: ecs_world_stats_t__bindgen_ty_9::busy_count"]
        [::std::mem::offset_of!(ecs_world_stats_t__bindgen_ty_9, busy_count) - 9600usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_stats_t"][::std::mem::size_of::<ecs_world_stats_t>() - 73224usize];
    ["Alignment of ecs_world_stats_t"][::std::mem::align_of::<ecs_world_stats_t>() - 8usize];
    ["Offset of field: ecs_world_stats_t::first_"]
        [::std::mem::offset_of!(ecs_world_stats_t, first_) - 0usize];
    ["Offset of field: ecs_world_stats_t::entities"]
        [::std::mem::offset_of!(ecs_world_stats_t, entities) - 8usize];
    ["Offset of field: ecs_world_stats_t::components"]
        [::std::mem::offset_of!(ecs_world_stats_t, components) - 2408usize];
    ["Offset of field: ecs_world_stats_t::tables"]
        [::std::mem::offset_of!(ecs_world_stats_t, tables) - 9608usize];
    ["Offset of field: ecs_world_stats_t::queries"]
        [::std::mem::offset_of!(ecs_world_stats_t, queries) - 14408usize];
    ["Offset of field: ecs_world_stats_t::commands"]
        [::std::mem::offset_of!(ecs_world_stats_t, commands) - 18008usize];
    ["Offset of field: ecs_world_stats_t::frame"]
        [::std::mem::offset_of!(ecs_world_stats_t, frame) - 31208usize];
    ["Offset of field: ecs_world_stats_t::performance"]
        [::std::mem::offset_of!(ecs_world_stats_t, performance) - 39608usize];
    ["Offset of field: ecs_world_stats_t::memory"]
        [::std::mem::offset_of!(ecs_world_stats_t, memory) - 50408usize];
    ["Offset of field: ecs_world_stats_t::http"]
        [::std::mem::offset_of!(ecs_world_stats_t, http) - 62408usize];
    ["Offset of field: ecs_world_stats_t::last_"]
        [::std::mem::offset_of!(ecs_world_stats_t, last_) - 73208usize];
    ["Offset of field: ecs_world_stats_t::t"]
        [::std::mem::offset_of!(ecs_world_stats_t, t) - 73216usize];
};
#[doc = " Statistics for a single query (use ecs_query_cache_stats_get)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_query_stats_t {
    pub first_: i64,
    #[doc = "< Number of query results"]
    pub result_count: ecs_metric_t,
    #[doc = "< Number of matched tables"]
    pub matched_table_count: ecs_metric_t,
    #[doc = "< Number of matched entities"]
    pub matched_entity_count: ecs_metric_t,
    pub last_: i64,
    #[doc = " Current position in ringbuffer"]
    pub t: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_stats_t"][::std::mem::size_of::<ecs_query_stats_t>() - 3624usize];
    ["Alignment of ecs_query_stats_t"][::std::mem::align_of::<ecs_query_stats_t>() - 8usize];
    ["Offset of field: ecs_query_stats_t::first_"]
        [::std::mem::offset_of!(ecs_query_stats_t, first_) - 0usize];
    ["Offset of field: ecs_query_stats_t::result_count"]
        [::std::mem::offset_of!(ecs_query_stats_t, result_count) - 8usize];
    ["Offset of field: ecs_query_stats_t::matched_table_count"]
        [::std::mem::offset_of!(ecs_query_stats_t, matched_table_count) - 1208usize];
    ["Offset of field: ecs_query_stats_t::matched_entity_count"]
        [::std::mem::offset_of!(ecs_query_stats_t, matched_entity_count) - 2408usize];
    ["Offset of field: ecs_query_stats_t::last_"]
        [::std::mem::offset_of!(ecs_query_stats_t, last_) - 3608usize];
    ["Offset of field: ecs_query_stats_t::t"]
        [::std::mem::offset_of!(ecs_query_stats_t, t) - 3616usize];
};
#[doc = " Statistics for a single system (use ecs_system_stats_get())"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_system_stats_t {
    pub first_: i64,
    #[doc = "< Time spent processing a system"]
    pub time_spent: ecs_metric_t,
    pub last_: i64,
    #[doc = "< Is system a task"]
    pub task: bool,
    pub query: ecs_query_stats_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_system_stats_t"][::std::mem::size_of::<ecs_system_stats_t>() - 4848usize];
    ["Alignment of ecs_system_stats_t"][::std::mem::align_of::<ecs_system_stats_t>() - 8usize];
    ["Offset of field: ecs_system_stats_t::first_"]
        [::std::mem::offset_of!(ecs_system_stats_t, first_) - 0usize];
    ["Offset of field: ecs_system_stats_t::time_spent"]
        [::std::mem::offset_of!(ecs_system_stats_t, time_spent) - 8usize];
    ["Offset of field: ecs_system_stats_t::last_"]
        [::std::mem::offset_of!(ecs_system_stats_t, last_) - 1208usize];
    ["Offset of field: ecs_system_stats_t::task"]
        [::std::mem::offset_of!(ecs_system_stats_t, task) - 1216usize];
    ["Offset of field: ecs_system_stats_t::query"]
        [::std::mem::offset_of!(ecs_system_stats_t, query) - 1224usize];
};
#[doc = " Statistics for sync point"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_sync_stats_t {
    pub first_: i64,
    pub time_spent: ecs_metric_t,
    pub commands_enqueued: ecs_metric_t,
    pub last_: i64,
    pub system_count: i32,
    pub multi_threaded: bool,
    pub immediate: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_sync_stats_t"][::std::mem::size_of::<ecs_sync_stats_t>() - 2424usize];
    ["Alignment of ecs_sync_stats_t"][::std::mem::align_of::<ecs_sync_stats_t>() - 8usize];
    ["Offset of field: ecs_sync_stats_t::first_"]
        [::std::mem::offset_of!(ecs_sync_stats_t, first_) - 0usize];
    ["Offset of field: ecs_sync_stats_t::time_spent"]
        [::std::mem::offset_of!(ecs_sync_stats_t, time_spent) - 8usize];
    ["Offset of field: ecs_sync_stats_t::commands_enqueued"]
        [::std::mem::offset_of!(ecs_sync_stats_t, commands_enqueued) - 1208usize];
    ["Offset of field: ecs_sync_stats_t::last_"]
        [::std::mem::offset_of!(ecs_sync_stats_t, last_) - 2408usize];
    ["Offset of field: ecs_sync_stats_t::system_count"]
        [::std::mem::offset_of!(ecs_sync_stats_t, system_count) - 2416usize];
    ["Offset of field: ecs_sync_stats_t::multi_threaded"]
        [::std::mem::offset_of!(ecs_sync_stats_t, multi_threaded) - 2420usize];
    ["Offset of field: ecs_sync_stats_t::immediate"]
        [::std::mem::offset_of!(ecs_sync_stats_t, immediate) - 2421usize];
};
#[doc = " Statistics for all systems in a pipeline."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_pipeline_stats_t {
    pub canary_: i8,
    #[doc = " Vector with system ids of all systems in the pipeline. The systems are\n stored in the order they are executed. Merges are represented by a 0."]
    pub systems: ecs_vec_t,
    #[doc = " Vector with sync point stats"]
    pub sync_points: ecs_vec_t,
    #[doc = " Current position in ring buffer"]
    pub t: i32,
    #[doc = "< Number of systems in pipeline"]
    pub system_count: i32,
    #[doc = "< Number of active systems in pipeline"]
    pub active_system_count: i32,
    #[doc = "< Number of times pipeline has rebuilt"]
    pub rebuild_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_pipeline_stats_t"][::std::mem::size_of::<ecs_pipeline_stats_t>() - 56usize];
    ["Alignment of ecs_pipeline_stats_t"][::std::mem::align_of::<ecs_pipeline_stats_t>() - 8usize];
    ["Offset of field: ecs_pipeline_stats_t::canary_"]
        [::std::mem::offset_of!(ecs_pipeline_stats_t, canary_) - 0usize];
    ["Offset of field: ecs_pipeline_stats_t::systems"]
        [::std::mem::offset_of!(ecs_pipeline_stats_t, systems) - 8usize];
    ["Offset of field: ecs_pipeline_stats_t::sync_points"]
        [::std::mem::offset_of!(ecs_pipeline_stats_t, sync_points) - 24usize];
    ["Offset of field: ecs_pipeline_stats_t::t"]
        [::std::mem::offset_of!(ecs_pipeline_stats_t, t) - 40usize];
    ["Offset of field: ecs_pipeline_stats_t::system_count"]
        [::std::mem::offset_of!(ecs_pipeline_stats_t, system_count) - 44usize];
    ["Offset of field: ecs_pipeline_stats_t::active_system_count"]
        [::std::mem::offset_of!(ecs_pipeline_stats_t, active_system_count) - 48usize];
    ["Offset of field: ecs_pipeline_stats_t::rebuild_count"]
        [::std::mem::offset_of!(ecs_pipeline_stats_t, rebuild_count) - 52usize];
};
extern "C" {
    #[doc = " Get world statistics.\n\n @param world The world.\n @param stats Out parameter for statistics."]
    pub fn ecs_world_stats_get(world: *const ecs_world_t, stats: *mut ecs_world_stats_t);
}
extern "C" {
    #[doc = " Reduce source measurement window into single destination measurement."]
    pub fn ecs_world_stats_reduce(dst: *mut ecs_world_stats_t, src: *const ecs_world_stats_t);
}
extern "C" {
    #[doc = " Reduce last measurement into previous measurement, restore old value."]
    pub fn ecs_world_stats_reduce_last(
        stats: *mut ecs_world_stats_t,
        old: *const ecs_world_stats_t,
        count: i32,
    );
}
extern "C" {
    #[doc = " Repeat last measurement."]
    pub fn ecs_world_stats_repeat_last(stats: *mut ecs_world_stats_t);
}
extern "C" {
    #[doc = " Copy last measurement from source to destination."]
    pub fn ecs_world_stats_copy_last(dst: *mut ecs_world_stats_t, src: *const ecs_world_stats_t);
}
extern "C" {
    pub fn ecs_world_stats_log(world: *const ecs_world_t, stats: *const ecs_world_stats_t);
}
extern "C" {
    #[doc = " Get query statistics.\n Obtain statistics for the provided query.\n\n @param world The world.\n @param query The query.\n @param stats Out parameter for statistics."]
    pub fn ecs_query_stats_get(
        world: *const ecs_world_t,
        query: *const ecs_query_t,
        stats: *mut ecs_query_stats_t,
    );
}
extern "C" {
    #[doc = " Reduce source measurement window into single destination measurement."]
    pub fn ecs_query_cache_stats_reduce(dst: *mut ecs_query_stats_t, src: *const ecs_query_stats_t);
}
extern "C" {
    #[doc = " Reduce last measurement into previous measurement, restore old value."]
    pub fn ecs_query_cache_stats_reduce_last(
        stats: *mut ecs_query_stats_t,
        old: *const ecs_query_stats_t,
        count: i32,
    );
}
extern "C" {
    #[doc = " Repeat last measurement."]
    pub fn ecs_query_cache_stats_repeat_last(stats: *mut ecs_query_stats_t);
}
extern "C" {
    #[doc = " Copy last measurement from source to destination."]
    pub fn ecs_query_cache_stats_copy_last(
        dst: *mut ecs_query_stats_t,
        src: *const ecs_query_stats_t,
    );
}
extern "C" {
    #[doc = " Get system statistics.\n Obtain statistics for the provided system.\n\n @param world The world.\n @param system The system.\n @param stats Out parameter for statistics.\n @return true if success, false if not a system."]
    pub fn ecs_system_stats_get(
        world: *const ecs_world_t,
        system: ecs_entity_t,
        stats: *mut ecs_system_stats_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Reduce source measurement window into single destination measurement"]
    pub fn ecs_system_stats_reduce(dst: *mut ecs_system_stats_t, src: *const ecs_system_stats_t);
}
extern "C" {
    #[doc = " Reduce last measurement into previous measurement, restore old value."]
    pub fn ecs_system_stats_reduce_last(
        stats: *mut ecs_system_stats_t,
        old: *const ecs_system_stats_t,
        count: i32,
    );
}
extern "C" {
    #[doc = " Repeat last measurement."]
    pub fn ecs_system_stats_repeat_last(stats: *mut ecs_system_stats_t);
}
extern "C" {
    #[doc = " Copy last measurement from source to destination."]
    pub fn ecs_system_stats_copy_last(dst: *mut ecs_system_stats_t, src: *const ecs_system_stats_t);
}
extern "C" {
    #[doc = " Get pipeline statistics.\n Obtain statistics for the provided pipeline.\n\n @param world The world.\n @param pipeline The pipeline.\n @param stats Out parameter for statistics.\n @return true if success, false if not a pipeline."]
    pub fn ecs_pipeline_stats_get(
        world: *mut ecs_world_t,
        pipeline: ecs_entity_t,
        stats: *mut ecs_pipeline_stats_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Free pipeline stats.\n\n @param stats The stats to free."]
    pub fn ecs_pipeline_stats_fini(stats: *mut ecs_pipeline_stats_t);
}
extern "C" {
    #[doc = " Reduce source measurement window into single destination measurement"]
    pub fn ecs_pipeline_stats_reduce(
        dst: *mut ecs_pipeline_stats_t,
        src: *const ecs_pipeline_stats_t,
    );
}
extern "C" {
    #[doc = " Reduce last measurement into previous measurement, restore old value."]
    pub fn ecs_pipeline_stats_reduce_last(
        stats: *mut ecs_pipeline_stats_t,
        old: *const ecs_pipeline_stats_t,
        count: i32,
    );
}
extern "C" {
    #[doc = " Repeat last measurement."]
    pub fn ecs_pipeline_stats_repeat_last(stats: *mut ecs_pipeline_stats_t);
}
extern "C" {
    #[doc = " Copy last measurement to destination.\n This operation copies the last measurement into the destination. It does not\n modify the cursor.\n\n @param dst The metrics.\n @param src The metrics to copy."]
    pub fn ecs_pipeline_stats_copy_last(
        dst: *mut ecs_pipeline_stats_t,
        src: *const ecs_pipeline_stats_t,
    );
}
extern "C" {
    #[doc = " Reduce all measurements from a window into a single measurement."]
    pub fn ecs_metric_reduce(
        dst: *mut ecs_metric_t,
        src: *const ecs_metric_t,
        t_dst: i32,
        t_src: i32,
    );
}
extern "C" {
    #[doc = " Reduce last measurement into previous measurement"]
    pub fn ecs_metric_reduce_last(m: *mut ecs_metric_t, t: i32, count: i32);
}
extern "C" {
    #[doc = " Copy measurement"]
    pub fn ecs_metric_copy(m: *mut ecs_metric_t, dst: i32, src: i32);
}
extern "C" {
    #[doc = "< Flecs stats module."]
    pub static mut FLECS_IDFlecsStatsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Component id for EcsWorldStats."]
    pub static mut FLECS_IDEcsWorldStatsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Component id for EcsWorldSummary."]
    pub static mut FLECS_IDEcsWorldSummaryID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Component id for EcsSystemStats."]
    pub static mut FLECS_IDEcsSystemStatsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Component id for EcsPipelineStats."]
    pub static mut FLECS_IDEcsPipelineStatsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tag used for metrics collected in last second."]
    pub static mut EcsPeriod1s: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tag used for metrics collected in last minute."]
    pub static mut EcsPeriod1m: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tag used for metrics collected in last hour."]
    pub static mut EcsPeriod1h: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tag used for metrics collected in last day."]
    pub static mut EcsPeriod1d: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tag used for metrics collected in last week."]
    pub static mut EcsPeriod1w: ecs_entity_t;
}
#[doc = " Common data for statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsStatsHeader {
    pub elapsed: f32,
    pub reduce_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsStatsHeader"][::std::mem::size_of::<EcsStatsHeader>() - 8usize];
    ["Alignment of EcsStatsHeader"][::std::mem::align_of::<EcsStatsHeader>() - 4usize];
    ["Offset of field: EcsStatsHeader::elapsed"]
        [::std::mem::offset_of!(EcsStatsHeader, elapsed) - 0usize];
    ["Offset of field: EcsStatsHeader::reduce_count"]
        [::std::mem::offset_of!(EcsStatsHeader, reduce_count) - 4usize];
};
#[doc = " Component that stores world statistics."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EcsWorldStats {
    pub hdr: EcsStatsHeader,
    pub stats: ecs_world_stats_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsWorldStats"][::std::mem::size_of::<EcsWorldStats>() - 73232usize];
    ["Alignment of EcsWorldStats"][::std::mem::align_of::<EcsWorldStats>() - 8usize];
    ["Offset of field: EcsWorldStats::hdr"][::std::mem::offset_of!(EcsWorldStats, hdr) - 0usize];
    ["Offset of field: EcsWorldStats::stats"]
        [::std::mem::offset_of!(EcsWorldStats, stats) - 8usize];
};
#[doc = " Component that stores system statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsSystemStats {
    pub hdr: EcsStatsHeader,
    pub stats: ecs_map_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsSystemStats"][::std::mem::size_of::<EcsSystemStats>() - 48usize];
    ["Alignment of EcsSystemStats"][::std::mem::align_of::<EcsSystemStats>() - 8usize];
    ["Offset of field: EcsSystemStats::hdr"][::std::mem::offset_of!(EcsSystemStats, hdr) - 0usize];
    ["Offset of field: EcsSystemStats::stats"]
        [::std::mem::offset_of!(EcsSystemStats, stats) - 8usize];
};
#[doc = " Component that stores pipeline statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsPipelineStats {
    pub hdr: EcsStatsHeader,
    pub stats: ecs_map_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsPipelineStats"][::std::mem::size_of::<EcsPipelineStats>() - 48usize];
    ["Alignment of EcsPipelineStats"][::std::mem::align_of::<EcsPipelineStats>() - 8usize];
    ["Offset of field: EcsPipelineStats::hdr"]
        [::std::mem::offset_of!(EcsPipelineStats, hdr) - 0usize];
    ["Offset of field: EcsPipelineStats::stats"]
        [::std::mem::offset_of!(EcsPipelineStats, stats) - 8usize];
};
#[doc = " Component that stores a summary of world statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsWorldSummary {
    #[doc = "< Target FPS"]
    pub target_fps: f64,
    #[doc = "< Simulation time scale"]
    pub time_scale: f64,
    #[doc = "< Total time spent processing a frame"]
    pub frame_time_total: f64,
    #[doc = "< Total time spent in systems"]
    pub system_time_total: f64,
    #[doc = "< Total time spent in merges"]
    pub merge_time_total: f64,
    #[doc = "< Time spent processing a frame"]
    pub frame_time_last: f64,
    #[doc = "< Time spent in systems"]
    pub system_time_last: f64,
    #[doc = "< Time spent in merges"]
    pub merge_time_last: f64,
    #[doc = "< Number of frames processed"]
    pub frame_count: i64,
    #[doc = "< Number of commands processed"]
    pub command_count: i64,
    #[doc = "< Build info"]
    pub build_info: ecs_build_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsWorldSummary"][::std::mem::size_of::<EcsWorldSummary>() - 120usize];
    ["Alignment of EcsWorldSummary"][::std::mem::align_of::<EcsWorldSummary>() - 8usize];
    ["Offset of field: EcsWorldSummary::target_fps"]
        [::std::mem::offset_of!(EcsWorldSummary, target_fps) - 0usize];
    ["Offset of field: EcsWorldSummary::time_scale"]
        [::std::mem::offset_of!(EcsWorldSummary, time_scale) - 8usize];
    ["Offset of field: EcsWorldSummary::frame_time_total"]
        [::std::mem::offset_of!(EcsWorldSummary, frame_time_total) - 16usize];
    ["Offset of field: EcsWorldSummary::system_time_total"]
        [::std::mem::offset_of!(EcsWorldSummary, system_time_total) - 24usize];
    ["Offset of field: EcsWorldSummary::merge_time_total"]
        [::std::mem::offset_of!(EcsWorldSummary, merge_time_total) - 32usize];
    ["Offset of field: EcsWorldSummary::frame_time_last"]
        [::std::mem::offset_of!(EcsWorldSummary, frame_time_last) - 40usize];
    ["Offset of field: EcsWorldSummary::system_time_last"]
        [::std::mem::offset_of!(EcsWorldSummary, system_time_last) - 48usize];
    ["Offset of field: EcsWorldSummary::merge_time_last"]
        [::std::mem::offset_of!(EcsWorldSummary, merge_time_last) - 56usize];
    ["Offset of field: EcsWorldSummary::frame_count"]
        [::std::mem::offset_of!(EcsWorldSummary, frame_count) - 64usize];
    ["Offset of field: EcsWorldSummary::command_count"]
        [::std::mem::offset_of!(EcsWorldSummary, command_count) - 72usize];
    ["Offset of field: EcsWorldSummary::build_info"]
        [::std::mem::offset_of!(EcsWorldSummary, build_info) - 80usize];
};
extern "C" {
    #[doc = " Stats module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsStats)\n @endcode\n\n @param world The world."]
    pub fn FlecsStatsImport(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Flecs metrics module."]
    pub static mut FLECS_IDFlecsMetricsID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to metrics, and used as first element of metric kind pair."]
    pub static mut EcsMetric: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to metrics, and used as first element of metric kind pair."]
    pub static mut FLECS_IDEcsMetricID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Metric that has monotonically increasing value."]
    pub static mut EcsCounter: ecs_entity_t;
}
extern "C" {
    #[doc = " Metric that has monotonically increasing value."]
    pub static mut FLECS_IDEcsCounterID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Counter metric that is auto-incremented by source value."]
    pub static mut EcsCounterIncrement: ecs_entity_t;
}
extern "C" {
    #[doc = " Counter metric that is auto-incremented by source value."]
    pub static mut FLECS_IDEcsCounterIncrementID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Counter metric that counts the number of entities with an id."]
    pub static mut EcsCounterId: ecs_entity_t;
}
extern "C" {
    #[doc = " Counter metric that counts the number of entities with an id."]
    pub static mut FLECS_IDEcsCounterIdID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Metric that represents current value."]
    pub static mut EcsGauge: ecs_entity_t;
}
extern "C" {
    #[doc = " Metric that represents current value."]
    pub static mut FLECS_IDEcsGaugeID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to metric instances."]
    pub static mut EcsMetricInstance: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to metric instances."]
    pub static mut FLECS_IDEcsMetricInstanceID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Component with metric instance value."]
    pub static mut FLECS_IDEcsMetricValueID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Component with entity source of metric instance."]
    pub static mut FLECS_IDEcsMetricSourceID_: ecs_entity_t;
}
#[doc = " Component that stores metric value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMetricValue {
    pub value: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsMetricValue"][::std::mem::size_of::<EcsMetricValue>() - 8usize];
    ["Alignment of EcsMetricValue"][::std::mem::align_of::<EcsMetricValue>() - 8usize];
    ["Offset of field: EcsMetricValue::value"]
        [::std::mem::offset_of!(EcsMetricValue, value) - 0usize];
};
#[doc = " Component that stores metric source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMetricSource {
    pub entity: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsMetricSource"][::std::mem::size_of::<EcsMetricSource>() - 8usize];
    ["Alignment of EcsMetricSource"][::std::mem::align_of::<EcsMetricSource>() - 8usize];
    ["Offset of field: EcsMetricSource::entity"]
        [::std::mem::offset_of!(EcsMetricSource, entity) - 0usize];
};
#[doc = " Used with ecs_metric_init to create metric."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_metric_desc_t {
    pub _canary: i32,
    #[doc = " Entity associated with metric"]
    pub entity: ecs_entity_t,
    #[doc = " Entity associated with member that stores metric value. Must not be set\n at the same time as id. Cannot be combined with EcsCounterId."]
    pub member: ecs_entity_t,
    pub dotmember: *const ::std::os::raw::c_char,
    #[doc = " Tracks whether entities have the specified component id. Must not be set\n at the same time as member."]
    pub id: ecs_id_t,
    #[doc = " If id is a (R, *) wildcard and relationship R has the OneOf property,\n setting this value to true will track individual targets.\n If the kind is EcsCountId and the id is a (R, *) wildcard, this value\n will create a metric per target."]
    pub targets: bool,
    #[doc = " Must be EcsGauge, EcsCounter, EcsCounterIncrement or EcsCounterId"]
    pub kind: ecs_entity_t,
    #[doc = " Description of metric. Will only be set if FLECS_DOC addon is enabled"]
    pub brief: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_metric_desc_t"][::std::mem::size_of::<ecs_metric_desc_t>() - 64usize];
    ["Alignment of ecs_metric_desc_t"][::std::mem::align_of::<ecs_metric_desc_t>() - 8usize];
    ["Offset of field: ecs_metric_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_metric_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_metric_desc_t::entity"]
        [::std::mem::offset_of!(ecs_metric_desc_t, entity) - 8usize];
    ["Offset of field: ecs_metric_desc_t::member"]
        [::std::mem::offset_of!(ecs_metric_desc_t, member) - 16usize];
    ["Offset of field: ecs_metric_desc_t::dotmember"]
        [::std::mem::offset_of!(ecs_metric_desc_t, dotmember) - 24usize];
    ["Offset of field: ecs_metric_desc_t::id"]
        [::std::mem::offset_of!(ecs_metric_desc_t, id) - 32usize];
    ["Offset of field: ecs_metric_desc_t::targets"]
        [::std::mem::offset_of!(ecs_metric_desc_t, targets) - 40usize];
    ["Offset of field: ecs_metric_desc_t::kind"]
        [::std::mem::offset_of!(ecs_metric_desc_t, kind) - 48usize];
    ["Offset of field: ecs_metric_desc_t::brief"]
        [::std::mem::offset_of!(ecs_metric_desc_t, brief) - 56usize];
};
extern "C" {
    #[doc = " Create a new metric.\n Metrics are entities that store values measured from a range of different\n properties in the ECS storage. Metrics provide a single unified interface to\n discovering and reading these values, which can be useful for monitoring\n utilities, or for debugging.\n\n Examples of properties that can be measured by metrics are:\n  - Component member values\n  - How long an entity has had a specific component\n  - How long an entity has had a specific target for a relationship\n  - How many entities have a specific component\n\n Metrics can either be created as a \"gauge\" or \"counter\". A gauge is a metric\n that represents the value of something at a specific point in time, for\n example \"velocity\". A counter metric represents a value that is monotonically\n increasing, for example \"miles driven\".\n\n There are three different kinds of counter metric kinds:\n - EcsCounter\n   When combined with a member, this will store the actual value of the member\n   in the metric. This is useful for values that are already counters, such as\n   a MilesDriven component.\n   This kind creates a metric per entity that has the member/id.\n\n - EcsCounterIncrement\n   When combined with a member, this will increment the value of the metric by\n   the value of the member * delta_time. This is useful for values that are\n   not counters, such as a Velocity component.\n   This kind creates a metric per entity that has the member.\n\n - EcsCounterId\n   This metric kind will count the number of entities with a specific\n   (component) id. This kind creates a single metric instance for regular ids,\n   and a metric instance per target for wildcard ids when targets is set.\n\n @param world The world.\n @param desc Metric description.\n @return The metric entity."]
    pub fn ecs_metric_init(world: *mut ecs_world_t, desc: *const ecs_metric_desc_t)
        -> ecs_entity_t;
}
extern "C" {
    #[doc = " Metrics module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsMetrics)\n @endcode\n\n @param world The world."]
    pub fn FlecsMetricsImport(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Module id."]
    pub static mut FLECS_IDFlecsAlertsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Component added to alert, and used as first element of alert severity pair."]
    pub static mut FLECS_IDEcsAlertID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Component added to alert instance."]
    pub static mut FLECS_IDEcsAlertInstanceID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Component added to alert source which tracks how many active alerts there are."]
    pub static mut FLECS_IDEcsAlertsActiveID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Component added to alert which tracks how long an alert has been inactive."]
    pub static mut FLECS_IDEcsAlertTimeoutID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Info alert severity."]
    pub static mut EcsAlertInfo: ecs_entity_t;
}
extern "C" {
    #[doc = "< Info alert severity."]
    pub static mut FLECS_IDEcsAlertInfoID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Warning alert severity."]
    pub static mut EcsAlertWarning: ecs_entity_t;
}
extern "C" {
    #[doc = "< Warning alert severity."]
    pub static mut FLECS_IDEcsAlertWarningID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Error alert severity."]
    pub static mut EcsAlertError: ecs_entity_t;
}
extern "C" {
    #[doc = "< Error alert severity."]
    pub static mut FLECS_IDEcsAlertErrorID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Critical alert severity."]
    pub static mut EcsAlertCritical: ecs_entity_t;
}
extern "C" {
    #[doc = "< Critical alert severity."]
    pub static mut FLECS_IDEcsAlertCriticalID_: ecs_entity_t;
}
#[doc = " Component added to alert instance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsAlertInstance {
    #[doc = "< Generated alert message"]
    pub message: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsAlertInstance"][::std::mem::size_of::<EcsAlertInstance>() - 8usize];
    ["Alignment of EcsAlertInstance"][::std::mem::align_of::<EcsAlertInstance>() - 8usize];
    ["Offset of field: EcsAlertInstance::message"]
        [::std::mem::offset_of!(EcsAlertInstance, message) - 0usize];
};
#[doc = " Map with active alerts for entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsAlertsActive {
    #[doc = "< Number of alerts for source with info severity"]
    pub info_count: i32,
    #[doc = "< Number of alerts for source with warning severity"]
    pub warning_count: i32,
    #[doc = "< Number of alerts for source with error severity"]
    pub error_count: i32,
    pub alerts: ecs_map_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsAlertsActive"][::std::mem::size_of::<EcsAlertsActive>() - 56usize];
    ["Alignment of EcsAlertsActive"][::std::mem::align_of::<EcsAlertsActive>() - 8usize];
    ["Offset of field: EcsAlertsActive::info_count"]
        [::std::mem::offset_of!(EcsAlertsActive, info_count) - 0usize];
    ["Offset of field: EcsAlertsActive::warning_count"]
        [::std::mem::offset_of!(EcsAlertsActive, warning_count) - 4usize];
    ["Offset of field: EcsAlertsActive::error_count"]
        [::std::mem::offset_of!(EcsAlertsActive, error_count) - 8usize];
    ["Offset of field: EcsAlertsActive::alerts"]
        [::std::mem::offset_of!(EcsAlertsActive, alerts) - 16usize];
};
#[doc = " Alert severity filter.\n A severity filter can adjust the severity of an alert based on whether an\n entity in the alert query has a specific component. For example, a filter\n could check if an entity has the \"Production\" tag, and increase the default\n severity of an alert from Warning to Error."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_alert_severity_filter_t {
    pub severity: ecs_entity_t,
    pub with: ecs_id_t,
    pub var: *const ::std::os::raw::c_char,
    pub _var_index: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_alert_severity_filter_t"]
        [::std::mem::size_of::<ecs_alert_severity_filter_t>() - 32usize];
    ["Alignment of ecs_alert_severity_filter_t"]
        [::std::mem::align_of::<ecs_alert_severity_filter_t>() - 8usize];
    ["Offset of field: ecs_alert_severity_filter_t::severity"]
        [::std::mem::offset_of!(ecs_alert_severity_filter_t, severity) - 0usize];
    ["Offset of field: ecs_alert_severity_filter_t::with"]
        [::std::mem::offset_of!(ecs_alert_severity_filter_t, with) - 8usize];
    ["Offset of field: ecs_alert_severity_filter_t::var"]
        [::std::mem::offset_of!(ecs_alert_severity_filter_t, var) - 16usize];
    ["Offset of field: ecs_alert_severity_filter_t::_var_index"]
        [::std::mem::offset_of!(ecs_alert_severity_filter_t, _var_index) - 24usize];
};
#[doc = " Alert descriptor, used with ecs_alert_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_alert_desc_t {
    pub _canary: i32,
    #[doc = " Entity associated with alert"]
    pub entity: ecs_entity_t,
    #[doc = " Alert query. An alert will be created for each entity that matches the\n specified query. The query must have at least one term that uses the\n $this variable (default)."]
    pub query: ecs_query_desc_t,
    #[doc = " Template for alert message. This string is used to generate the alert\n message and may refer to variables in the query result. The format for\n the template expressions is as specified by ecs_script_string_interpolate().\n\n Examples:\n\n     \"$this has Position but not Velocity\"\n     \"$this has a parent entity $parent without Position\""]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " User friendly name. Will only be set if FLECS_DOC addon is enabled."]
    pub doc_name: *const ::std::os::raw::c_char,
    #[doc = " Description of alert. Will only be set if FLECS_DOC addon is enabled"]
    pub brief: *const ::std::os::raw::c_char,
    #[doc = " Metric kind. Must be EcsAlertInfo, EcsAlertWarning, EcsAlertError or\n EcsAlertCritical. Defaults to EcsAlertError."]
    pub severity: ecs_entity_t,
    #[doc = " Severity filters can be used to assign different severities to the same\n alert. This prevents having to create multiple alerts, and allows\n entities to transition between severities without resetting the\n alert duration (optional)."]
    pub severity_filters: [ecs_alert_severity_filter_t; 4usize],
    #[doc = " The retain period specifies how long an alert must be inactive before it\n is cleared. This makes it easier to track noisy alerts. While an alert is\n inactive its duration won't increase.\n When the retain period is 0, the alert will clear immediately after it no\n longer matches the alert query."]
    pub retain_period: f32,
    #[doc = " Alert when member value is out of range. Uses the warning/error ranges\n assigned to the member in the MemberRanges component (optional)."]
    pub member: ecs_entity_t,
    #[doc = " (Component) id of member to monitor. If left to 0 this will be set to\n the parent entity of the member (optional)."]
    pub id: ecs_id_t,
    #[doc = " Variable from which to fetch the member (optional). When left to NULL\n 'id' will be obtained from $this."]
    pub var: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_alert_desc_t"][::std::mem::size_of::<ecs_alert_desc_t>() - 2648usize];
    ["Alignment of ecs_alert_desc_t"][::std::mem::align_of::<ecs_alert_desc_t>() - 8usize];
    ["Offset of field: ecs_alert_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_alert_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_alert_desc_t::entity"]
        [::std::mem::offset_of!(ecs_alert_desc_t, entity) - 8usize];
    ["Offset of field: ecs_alert_desc_t::query"]
        [::std::mem::offset_of!(ecs_alert_desc_t, query) - 16usize];
    ["Offset of field: ecs_alert_desc_t::message"]
        [::std::mem::offset_of!(ecs_alert_desc_t, message) - 2456usize];
    ["Offset of field: ecs_alert_desc_t::doc_name"]
        [::std::mem::offset_of!(ecs_alert_desc_t, doc_name) - 2464usize];
    ["Offset of field: ecs_alert_desc_t::brief"]
        [::std::mem::offset_of!(ecs_alert_desc_t, brief) - 2472usize];
    ["Offset of field: ecs_alert_desc_t::severity"]
        [::std::mem::offset_of!(ecs_alert_desc_t, severity) - 2480usize];
    ["Offset of field: ecs_alert_desc_t::severity_filters"]
        [::std::mem::offset_of!(ecs_alert_desc_t, severity_filters) - 2488usize];
    ["Offset of field: ecs_alert_desc_t::retain_period"]
        [::std::mem::offset_of!(ecs_alert_desc_t, retain_period) - 2616usize];
    ["Offset of field: ecs_alert_desc_t::member"]
        [::std::mem::offset_of!(ecs_alert_desc_t, member) - 2624usize];
    ["Offset of field: ecs_alert_desc_t::id"]
        [::std::mem::offset_of!(ecs_alert_desc_t, id) - 2632usize];
    ["Offset of field: ecs_alert_desc_t::var"]
        [::std::mem::offset_of!(ecs_alert_desc_t, var) - 2640usize];
};
extern "C" {
    #[doc = " Create a new alert.\n An alert is a query that is evaluated periodically and creates alert\n instances for each entity that matches the query. Alerts can be used to\n automate detection of errors in an application.\n\n Alerts are automatically cleared when a query is no longer true for an alert\n instance. At most one alert instance will be created per matched entity.\n\n Alert instances have three components:\n - AlertInstance: contains the alert message for the instance\n - MetricSource: contains the entity that triggered the alert\n - MetricValue: contains how long the alert has been active\n\n Alerts reuse components from the metrics addon so that alert instances can be\n tracked and discovered as metrics. Just like metrics, alert instances are\n created as children of the alert.\n\n When an entity has active alerts, it will have the EcsAlertsActive component\n which contains a map with active alerts for the entity. This component\n will be automatically removed once all alerts are cleared for the entity.\n\n @param world The world.\n @param desc Alert description.\n @return The alert entity."]
    pub fn ecs_alert_init(world: *mut ecs_world_t, desc: *const ecs_alert_desc_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Return number of active alerts for entity.\n When a valid alert entity is specified for the alert parameter, the operation\n will return whether the specified alert is active for the entity. When no\n alert is specified, the operation will return the total number of active\n alerts for the entity.\n\n @param world The world.\n @param entity The entity.\n @param alert The alert to test for (optional).\n @return The number of active alerts for the entity."]
    pub fn ecs_get_alert_count(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        alert: ecs_entity_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Return alert instance for specified alert.\n This operation returns the alert instance for the specified alert. If the\n alert is not active for the entity, the operation will return 0.\n\n @param world The world.\n @param entity The entity.\n @param alert The alert to test for.\n @return The alert instance for the specified alert."]
    pub fn ecs_get_alert(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        alert: ecs_entity_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Alert module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsAlerts)\n @endcode\n\n @param world The world."]
    pub fn FlecsAlertsImport(world: *mut ecs_world_t);
}
#[doc = " Used with ecs_ptr_from_json(), ecs_entity_from_json()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_from_json_desc_t {
    #[doc = "< Name of expression (used for logging)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Full expression (used for logging)"]
    pub expr: *const ::std::os::raw::c_char,
    #[doc = " Callback that allows for specifying a custom lookup function. The\n default behavior uses ecs_lookup()"]
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ecs_world_t,
            value: *const ::std::os::raw::c_char,
            ctx: *mut ::std::os::raw::c_void,
        ) -> ecs_entity_t,
    >,
    pub lookup_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Require components to be registered with reflection data. When not\n in strict mode, values for components without reflection are ignored."]
    pub strict: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_from_json_desc_t"][::std::mem::size_of::<ecs_from_json_desc_t>() - 40usize];
    ["Alignment of ecs_from_json_desc_t"][::std::mem::align_of::<ecs_from_json_desc_t>() - 8usize];
    ["Offset of field: ecs_from_json_desc_t::name"]
        [::std::mem::offset_of!(ecs_from_json_desc_t, name) - 0usize];
    ["Offset of field: ecs_from_json_desc_t::expr"]
        [::std::mem::offset_of!(ecs_from_json_desc_t, expr) - 8usize];
    ["Offset of field: ecs_from_json_desc_t::lookup_action"]
        [::std::mem::offset_of!(ecs_from_json_desc_t, lookup_action) - 16usize];
    ["Offset of field: ecs_from_json_desc_t::lookup_ctx"]
        [::std::mem::offset_of!(ecs_from_json_desc_t, lookup_ctx) - 24usize];
    ["Offset of field: ecs_from_json_desc_t::strict"]
        [::std::mem::offset_of!(ecs_from_json_desc_t, strict) - 32usize];
};
extern "C" {
    #[doc = " Parse JSON string into value.\n This operation parses a JSON expression into the provided pointer. The\n memory pointed to must be large enough to contain a value of the used type.\n\n @param world The world.\n @param type The type of the expression to parse.\n @param ptr Pointer to the memory to write to.\n @param json The JSON expression to parse.\n @param desc Configuration parameters for deserializer.\n @return Pointer to the character after the last one read, or NULL if failed."]
    pub fn ecs_ptr_from_json(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
        json: *const ::std::os::raw::c_char,
        desc: *const ecs_from_json_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse JSON object with multiple component values into entity. The format\n is the same as the one outputted by ecs_entity_to_json(), but at the moment\n only supports the \"ids\" and \"values\" member.\n\n @param world The world.\n @param entity The entity to serialize to.\n @param json The JSON expression to parse (see entity in JSON format manual).\n @param desc Configuration parameters for deserializer.\n @return Pointer to the character after the last one read, or NULL if failed."]
    pub fn ecs_entity_from_json(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        json: *const ::std::os::raw::c_char,
        desc: *const ecs_from_json_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse JSON object with multiple entities into the world. The format is the\n same as the one outputted by ecs_world_to_json().\n\n @param world The world.\n @param json The JSON expression to parse (see iterator in JSON format manual).\n @param desc Deserialization parameters.\n @return Last deserialized character, NULL if failed."]
    pub fn ecs_world_from_json(
        world: *mut ecs_world_t,
        json: *const ::std::os::raw::c_char,
        desc: *const ecs_from_json_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Same as ecs_world_from_json(), but loads JSON from file.\n\n @param world The world.\n @param filename The file from which to load the JSON.\n @param desc Deserialization parameters.\n @return Last deserialized character, NULL if failed."]
    pub fn ecs_world_from_json_file(
        world: *mut ecs_world_t,
        filename: *const ::std::os::raw::c_char,
        desc: *const ecs_from_json_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize array into JSON string.\n This operation serializes a value of the provided type to a JSON string. The\n memory pointed to must be large enough to contain a value of the used type.\n\n If count is 0, the function will serialize a single value, not wrapped in\n array brackets. If count is >= 1, the operation will serialize values to a\n a comma-separated list inside of array brackets.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param count The number of elements to serialize.\n @return String with JSON expression, or NULL if failed."]
    pub fn ecs_array_to_json(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        count: i32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize array into JSON string buffer.\n Same as ecs_array_to_json(), but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param count The number of elements to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_array_to_json_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        count: i32,
        buf_out: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize value into JSON string.\n Same as ecs_array_to_json(), with count = 0.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @return String with JSON expression, or NULL if failed."]
    pub fn ecs_ptr_to_json(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize value into JSON string buffer.\n Same as ecs_ptr_to_json(), but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_ptr_to_json_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        buf_out: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize type info to JSON.\n This serializes type information to JSON, and can be used to store/transmit\n the structure of a (component) value.\n\n If the provided type does not have reflection data, \"0\" will be returned.\n\n @param world The world.\n @param type The type to serialize to JSON.\n @return A JSON string with the serialized type info, or NULL if failed."]
    pub fn ecs_type_info_to_json(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize type info into JSON string buffer.\n Same as ecs_type_info_to_json(), but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_type_info_to_json_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        buf_out: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Used with ecs_iter_to_json()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_entity_to_json_desc_t {
    #[doc = "< Serialize entity id"]
    pub serialize_entity_id: bool,
    #[doc = "< Serialize doc attributes"]
    pub serialize_doc: bool,
    #[doc = "< Serialize full paths for tags, components and pairs"]
    pub serialize_full_paths: bool,
    #[doc = "< Serialize base components"]
    pub serialize_inherited: bool,
    #[doc = "< Serialize component values"]
    pub serialize_values: bool,
    #[doc = "< Serialize builtin data as components (e.g. \"name\", \"parent\")"]
    pub serialize_builtin: bool,
    #[doc = "< Serialize type info (requires serialize_values)"]
    pub serialize_type_info: bool,
    #[doc = "< Serialize active alerts for entity"]
    pub serialize_alerts: bool,
    #[doc = "< Serialize references (incoming edges) for relationship"]
    pub serialize_refs: ecs_entity_t,
    #[doc = "< Serialize which queries entity matches with"]
    pub serialize_matches: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_entity_to_json_desc_t"]
        [::std::mem::size_of::<ecs_entity_to_json_desc_t>() - 24usize];
    ["Alignment of ecs_entity_to_json_desc_t"]
        [::std::mem::align_of::<ecs_entity_to_json_desc_t>() - 8usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_entity_id"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_entity_id) - 0usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_doc"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_doc) - 1usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_full_paths"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_full_paths) - 2usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_inherited"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_inherited) - 3usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_values"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_values) - 4usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_builtin"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_builtin) - 5usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_type_info"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_type_info) - 6usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_alerts"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_alerts) - 7usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_refs"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_refs) - 8usize];
    ["Offset of field: ecs_entity_to_json_desc_t::serialize_matches"]
        [::std::mem::offset_of!(ecs_entity_to_json_desc_t, serialize_matches) - 16usize];
};
extern "C" {
    #[doc = " Serialize entity into JSON string.\n This creates a JSON object with the entity's (path) name, which components\n and tags the entity has, and the component values.\n\n The operation may fail if the entity contains components with invalid values.\n\n @param world The world.\n @param entity The entity to serialize to JSON.\n @return A JSON string with the serialized entity data, or NULL if failed."]
    pub fn ecs_entity_to_json(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        desc: *const ecs_entity_to_json_desc_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize entity into JSON string buffer.\n Same as ecs_entity_to_json(), but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param entity The entity to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_entity_to_json_buf(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        buf_out: *mut ecs_strbuf_t,
        desc: *const ecs_entity_to_json_desc_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Used with ecs_iter_to_json()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_iter_to_json_desc_t {
    #[doc = "< Serialize entity ids"]
    pub serialize_entity_ids: bool,
    #[doc = "< Serialize component values"]
    pub serialize_values: bool,
    #[doc = "< Serialize builtin data as components (e.g. \"name\", \"parent\")"]
    pub serialize_builtin: bool,
    #[doc = "< Serialize doc attributes"]
    pub serialize_doc: bool,
    #[doc = "< Serialize full paths for tags, components and pairs"]
    pub serialize_full_paths: bool,
    #[doc = "< Serialize field data"]
    pub serialize_fields: bool,
    #[doc = "< Serialize inherited components"]
    pub serialize_inherited: bool,
    #[doc = "< Serialize entire table vs. matched components"]
    pub serialize_table: bool,
    #[doc = "< Serialize type information"]
    pub serialize_type_info: bool,
    #[doc = "< Serialize metadata for fields returned by query"]
    pub serialize_field_info: bool,
    #[doc = "< Serialize query terms"]
    pub serialize_query_info: bool,
    #[doc = "< Serialize query plan"]
    pub serialize_query_plan: bool,
    #[doc = "< Profile query performance"]
    pub serialize_query_profile: bool,
    #[doc = "< If true, query won't be evaluated"]
    pub dont_serialize_results: bool,
    #[doc = "< Serialize active alerts for entity"]
    pub serialize_alerts: bool,
    #[doc = "< Serialize references (incoming edges) for relationship"]
    pub serialize_refs: ecs_entity_t,
    #[doc = "< Serialize which queries entity matches with"]
    pub serialize_matches: bool,
    #[doc = "< Query object (required for serialize_query_[plan|profile])."]
    pub query: *mut ecs_poly_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_to_json_desc_t"][::std::mem::size_of::<ecs_iter_to_json_desc_t>() - 40usize];
    ["Alignment of ecs_iter_to_json_desc_t"]
        [::std::mem::align_of::<ecs_iter_to_json_desc_t>() - 8usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_entity_ids"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_entity_ids) - 0usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_values"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_values) - 1usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_builtin"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_builtin) - 2usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_doc"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_doc) - 3usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_full_paths"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_full_paths) - 4usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_fields"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_fields) - 5usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_inherited"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_inherited) - 6usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_table"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_table) - 7usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_type_info"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_type_info) - 8usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_field_info"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_field_info) - 9usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_query_info"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_query_info) - 10usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_query_plan"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_query_plan) - 11usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_query_profile"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_query_profile) - 12usize];
    ["Offset of field: ecs_iter_to_json_desc_t::dont_serialize_results"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, dont_serialize_results) - 13usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_alerts"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_alerts) - 14usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_refs"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_refs) - 16usize];
    ["Offset of field: ecs_iter_to_json_desc_t::serialize_matches"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, serialize_matches) - 24usize];
    ["Offset of field: ecs_iter_to_json_desc_t::query"]
        [::std::mem::offset_of!(ecs_iter_to_json_desc_t, query) - 32usize];
};
extern "C" {
    #[doc = " Serialize iterator into JSON string.\n This operation will iterate the contents of the iterator and serialize them\n to JSON. The function accepts iterators from any source.\n\n @param iter The iterator to serialize to JSON.\n @return A JSON string with the serialized iterator data, or NULL if failed."]
    pub fn ecs_iter_to_json(
        iter: *mut ecs_iter_t,
        desc: *const ecs_iter_to_json_desc_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize iterator into JSON string buffer.\n Same as ecs_iter_to_json(), but serializes to an ecs_strbuf_t instance.\n\n @param iter The iterator to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_iter_to_json_buf(
        iter: *mut ecs_iter_t,
        buf_out: *mut ecs_strbuf_t,
        desc: *const ecs_iter_to_json_desc_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Used with ecs_iter_to_json()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_to_json_desc_t {
    #[doc = "< Exclude flecs modules & contents"]
    pub serialize_builtin: bool,
    #[doc = "< Exclude modules & contents"]
    pub serialize_modules: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_to_json_desc_t"]
        [::std::mem::size_of::<ecs_world_to_json_desc_t>() - 2usize];
    ["Alignment of ecs_world_to_json_desc_t"]
        [::std::mem::align_of::<ecs_world_to_json_desc_t>() - 1usize];
    ["Offset of field: ecs_world_to_json_desc_t::serialize_builtin"]
        [::std::mem::offset_of!(ecs_world_to_json_desc_t, serialize_builtin) - 0usize];
    ["Offset of field: ecs_world_to_json_desc_t::serialize_modules"]
        [::std::mem::offset_of!(ecs_world_to_json_desc_t, serialize_modules) - 1usize];
};
extern "C" {
    #[doc = " Serialize world into JSON string.\n This operation iterates the contents of the world to JSON. The operation is\n equivalent to the following code:\n\n @code\n ecs_query_t *f = ecs_query(world, {\n   .terms = {{ .id = EcsAny }}\n });\n\n ecs_iter_t it = ecs_query_init(world, &f);\n ecs_iter_to_json_desc_t desc = { .serialize_table = true };\n ecs_iter_to_json(iter, &desc);\n @endcode\n\n @param world The world to serialize.\n @return A JSON string with the serialized iterator data, or NULL if failed."]
    pub fn ecs_world_to_json(
        world: *mut ecs_world_t,
        desc: *const ecs_world_to_json_desc_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize world into JSON string buffer.\n Same as ecs_world_to_json(), but serializes to an ecs_strbuf_t instance.\n\n @param world The world to serialize.\n @param buf_out The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_world_to_json_buf(
        world: *mut ecs_world_t,
        buf_out: *mut ecs_strbuf_t,
        desc: *const ecs_world_to_json_desc_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "< Parent scope for prefixes."]
    pub static mut EcsUnitPrefixes: ecs_entity_t;
}
extern "C" {
    #[doc = "< Parent scope for prefixes."]
    pub static mut FLECS_IDEcsUnitPrefixesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Yocto unit prefix."]
    pub static mut EcsYocto: ecs_entity_t;
}
extern "C" {
    #[doc = "< Yocto unit prefix."]
    pub static mut FLECS_IDEcsYoctoID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Zepto unit prefix."]
    pub static mut EcsZepto: ecs_entity_t;
}
extern "C" {
    #[doc = "< Zepto unit prefix."]
    pub static mut FLECS_IDEcsZeptoID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Atto unit prefix."]
    pub static mut EcsAtto: ecs_entity_t;
}
extern "C" {
    #[doc = "< Atto unit prefix."]
    pub static mut FLECS_IDEcsAttoID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Femto unit prefix."]
    pub static mut EcsFemto: ecs_entity_t;
}
extern "C" {
    #[doc = "< Femto unit prefix."]
    pub static mut FLECS_IDEcsFemtoID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pico unit prefix."]
    pub static mut EcsPico: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pico unit prefix."]
    pub static mut FLECS_IDEcsPicoID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Nano unit prefix."]
    pub static mut EcsNano: ecs_entity_t;
}
extern "C" {
    #[doc = "< Nano unit prefix."]
    pub static mut FLECS_IDEcsNanoID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Micro unit prefix."]
    pub static mut EcsMicro: ecs_entity_t;
}
extern "C" {
    #[doc = "< Micro unit prefix."]
    pub static mut FLECS_IDEcsMicroID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Milli unit prefix."]
    pub static mut EcsMilli: ecs_entity_t;
}
extern "C" {
    #[doc = "< Milli unit prefix."]
    pub static mut FLECS_IDEcsMilliID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Centi unit prefix."]
    pub static mut EcsCenti: ecs_entity_t;
}
extern "C" {
    #[doc = "< Centi unit prefix."]
    pub static mut FLECS_IDEcsCentiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Deci unit prefix."]
    pub static mut EcsDeci: ecs_entity_t;
}
extern "C" {
    #[doc = "< Deci unit prefix."]
    pub static mut FLECS_IDEcsDeciID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Deca unit prefix."]
    pub static mut EcsDeca: ecs_entity_t;
}
extern "C" {
    #[doc = "< Deca unit prefix."]
    pub static mut FLECS_IDEcsDecaID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Hecto unit prefix."]
    pub static mut EcsHecto: ecs_entity_t;
}
extern "C" {
    #[doc = "< Hecto unit prefix."]
    pub static mut FLECS_IDEcsHectoID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Kilo unit prefix."]
    pub static mut EcsKilo: ecs_entity_t;
}
extern "C" {
    #[doc = "< Kilo unit prefix."]
    pub static mut FLECS_IDEcsKiloID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Mega unit prefix."]
    pub static mut EcsMega: ecs_entity_t;
}
extern "C" {
    #[doc = "< Mega unit prefix."]
    pub static mut FLECS_IDEcsMegaID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Giga unit prefix."]
    pub static mut EcsGiga: ecs_entity_t;
}
extern "C" {
    #[doc = "< Giga unit prefix."]
    pub static mut FLECS_IDEcsGigaID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tera unit prefix."]
    pub static mut EcsTera: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tera unit prefix."]
    pub static mut FLECS_IDEcsTeraID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Peta unit prefix."]
    pub static mut EcsPeta: ecs_entity_t;
}
extern "C" {
    #[doc = "< Peta unit prefix."]
    pub static mut FLECS_IDEcsPetaID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Exa unit prefix."]
    pub static mut EcsExa: ecs_entity_t;
}
extern "C" {
    #[doc = "< Exa unit prefix."]
    pub static mut FLECS_IDEcsExaID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Zetta unit prefix."]
    pub static mut EcsZetta: ecs_entity_t;
}
extern "C" {
    #[doc = "< Zetta unit prefix."]
    pub static mut FLECS_IDEcsZettaID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Yotta unit prefix."]
    pub static mut EcsYotta: ecs_entity_t;
}
extern "C" {
    #[doc = "< Yotta unit prefix."]
    pub static mut FLECS_IDEcsYottaID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Kibi unit prefix."]
    pub static mut EcsKibi: ecs_entity_t;
}
extern "C" {
    #[doc = "< Kibi unit prefix."]
    pub static mut FLECS_IDEcsKibiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Mebi unit prefix."]
    pub static mut EcsMebi: ecs_entity_t;
}
extern "C" {
    #[doc = "< Mebi unit prefix."]
    pub static mut FLECS_IDEcsMebiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Gibi unit prefix."]
    pub static mut EcsGibi: ecs_entity_t;
}
extern "C" {
    #[doc = "< Gibi unit prefix."]
    pub static mut FLECS_IDEcsGibiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tebi unit prefix."]
    pub static mut EcsTebi: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tebi unit prefix."]
    pub static mut FLECS_IDEcsTebiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pebi unit prefix."]
    pub static mut EcsPebi: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pebi unit prefix."]
    pub static mut FLECS_IDEcsPebiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Exbi unit prefix."]
    pub static mut EcsExbi: ecs_entity_t;
}
extern "C" {
    #[doc = "< Exbi unit prefix."]
    pub static mut FLECS_IDEcsExbiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Zebi unit prefix."]
    pub static mut EcsZebi: ecs_entity_t;
}
extern "C" {
    #[doc = "< Zebi unit prefix."]
    pub static mut FLECS_IDEcsZebiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Yobi unit prefix."]
    pub static mut EcsYobi: ecs_entity_t;
}
extern "C" {
    #[doc = "< Yobi unit prefix."]
    pub static mut FLECS_IDEcsYobiID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Duration quantity."]
    pub static mut EcsDuration: ecs_entity_t;
}
extern "C" {
    #[doc = "< Duration quantity."]
    pub static mut FLECS_IDEcsDurationID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< PicoSeconds duration unit."]
    pub static mut EcsPicoSeconds: ecs_entity_t;
}
extern "C" {
    #[doc = "< PicoSeconds duration unit."]
    pub static mut FLECS_IDEcsPicoSecondsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< NanoSeconds duration unit."]
    pub static mut EcsNanoSeconds: ecs_entity_t;
}
extern "C" {
    #[doc = "< NanoSeconds duration unit."]
    pub static mut FLECS_IDEcsNanoSecondsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MicroSeconds duration unit."]
    pub static mut EcsMicroSeconds: ecs_entity_t;
}
extern "C" {
    #[doc = "< MicroSeconds duration unit."]
    pub static mut FLECS_IDEcsMicroSecondsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MilliSeconds duration unit."]
    pub static mut EcsMilliSeconds: ecs_entity_t;
}
extern "C" {
    #[doc = "< MilliSeconds duration unit."]
    pub static mut FLECS_IDEcsMilliSecondsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Seconds duration unit."]
    pub static mut EcsSeconds: ecs_entity_t;
}
extern "C" {
    #[doc = "< Seconds duration unit."]
    pub static mut FLECS_IDEcsSecondsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Minutes duration unit."]
    pub static mut EcsMinutes: ecs_entity_t;
}
extern "C" {
    #[doc = "< Minutes duration unit."]
    pub static mut FLECS_IDEcsMinutesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Hours duration unit."]
    pub static mut EcsHours: ecs_entity_t;
}
extern "C" {
    #[doc = "< Hours duration unit."]
    pub static mut FLECS_IDEcsHoursID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Days duration unit."]
    pub static mut EcsDays: ecs_entity_t;
}
extern "C" {
    #[doc = "< Days duration unit."]
    pub static mut FLECS_IDEcsDaysID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Time quantity."]
    pub static mut EcsTime: ecs_entity_t;
}
extern "C" {
    #[doc = "< Time quantity."]
    pub static mut FLECS_IDEcsTimeID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Date unit."]
    pub static mut EcsDate: ecs_entity_t;
}
extern "C" {
    #[doc = "< Date unit."]
    pub static mut FLECS_IDEcsDateID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Mass quantity."]
    pub static mut EcsMass: ecs_entity_t;
}
extern "C" {
    #[doc = "< Mass quantity."]
    pub static mut FLECS_IDEcsMassID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Grams unit."]
    pub static mut EcsGrams: ecs_entity_t;
}
extern "C" {
    #[doc = "< Grams unit."]
    pub static mut FLECS_IDEcsGramsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloGrams unit."]
    pub static mut EcsKiloGrams: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloGrams unit."]
    pub static mut FLECS_IDEcsKiloGramsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< ElectricCurrent quantity."]
    pub static mut EcsElectricCurrent: ecs_entity_t;
}
extern "C" {
    #[doc = "< ElectricCurrent quantity."]
    pub static mut FLECS_IDEcsElectricCurrentID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Ampere unit."]
    pub static mut EcsAmpere: ecs_entity_t;
}
extern "C" {
    #[doc = "< Ampere unit."]
    pub static mut FLECS_IDEcsAmpereID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Amount quantity."]
    pub static mut EcsAmount: ecs_entity_t;
}
extern "C" {
    #[doc = "< Amount quantity."]
    pub static mut FLECS_IDEcsAmountID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Mole unit."]
    pub static mut EcsMole: ecs_entity_t;
}
extern "C" {
    #[doc = "< Mole unit."]
    pub static mut FLECS_IDEcsMoleID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< LuminousIntensity quantity."]
    pub static mut EcsLuminousIntensity: ecs_entity_t;
}
extern "C" {
    #[doc = "< LuminousIntensity quantity."]
    pub static mut FLECS_IDEcsLuminousIntensityID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Candela unit."]
    pub static mut EcsCandela: ecs_entity_t;
}
extern "C" {
    #[doc = "< Candela unit."]
    pub static mut FLECS_IDEcsCandelaID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Force quantity."]
    pub static mut EcsForce: ecs_entity_t;
}
extern "C" {
    #[doc = "< Force quantity."]
    pub static mut FLECS_IDEcsForceID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Newton unit."]
    pub static mut EcsNewton: ecs_entity_t;
}
extern "C" {
    #[doc = "< Newton unit."]
    pub static mut FLECS_IDEcsNewtonID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Length quantity."]
    pub static mut EcsLength: ecs_entity_t;
}
extern "C" {
    #[doc = "< Length quantity."]
    pub static mut FLECS_IDEcsLengthID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Meters unit."]
    pub static mut EcsMeters: ecs_entity_t;
}
extern "C" {
    #[doc = "< Meters unit."]
    pub static mut FLECS_IDEcsMetersID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< PicoMeters unit."]
    pub static mut EcsPicoMeters: ecs_entity_t;
}
extern "C" {
    #[doc = "< PicoMeters unit."]
    pub static mut FLECS_IDEcsPicoMetersID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< NanoMeters unit."]
    pub static mut EcsNanoMeters: ecs_entity_t;
}
extern "C" {
    #[doc = "< NanoMeters unit."]
    pub static mut FLECS_IDEcsNanoMetersID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MicroMeters unit."]
    pub static mut EcsMicroMeters: ecs_entity_t;
}
extern "C" {
    #[doc = "< MicroMeters unit."]
    pub static mut FLECS_IDEcsMicroMetersID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MilliMeters unit."]
    pub static mut EcsMilliMeters: ecs_entity_t;
}
extern "C" {
    #[doc = "< MilliMeters unit."]
    pub static mut FLECS_IDEcsMilliMetersID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< CentiMeters unit."]
    pub static mut EcsCentiMeters: ecs_entity_t;
}
extern "C" {
    #[doc = "< CentiMeters unit."]
    pub static mut FLECS_IDEcsCentiMetersID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloMeters unit."]
    pub static mut EcsKiloMeters: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloMeters unit."]
    pub static mut FLECS_IDEcsKiloMetersID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Miles unit."]
    pub static mut EcsMiles: ecs_entity_t;
}
extern "C" {
    #[doc = "< Miles unit."]
    pub static mut FLECS_IDEcsMilesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pixels unit."]
    pub static mut EcsPixels: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pixels unit."]
    pub static mut FLECS_IDEcsPixelsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pressure quantity."]
    pub static mut EcsPressure: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pressure quantity."]
    pub static mut FLECS_IDEcsPressureID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pascal unit."]
    pub static mut EcsPascal: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pascal unit."]
    pub static mut FLECS_IDEcsPascalID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Bar unit."]
    pub static mut EcsBar: ecs_entity_t;
}
extern "C" {
    #[doc = "< Bar unit."]
    pub static mut FLECS_IDEcsBarID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Speed quantity."]
    pub static mut EcsSpeed: ecs_entity_t;
}
extern "C" {
    #[doc = "< Speed quantity."]
    pub static mut FLECS_IDEcsSpeedID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MetersPerSecond unit."]
    pub static mut EcsMetersPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< MetersPerSecond unit."]
    pub static mut FLECS_IDEcsMetersPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloMetersPerSecond unit."]
    pub static mut EcsKiloMetersPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloMetersPerSecond unit."]
    pub static mut FLECS_IDEcsKiloMetersPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloMetersPerHour unit."]
    pub static mut EcsKiloMetersPerHour: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloMetersPerHour unit."]
    pub static mut FLECS_IDEcsKiloMetersPerHourID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MilesPerHour unit."]
    pub static mut EcsMilesPerHour: ecs_entity_t;
}
extern "C" {
    #[doc = "< MilesPerHour unit."]
    pub static mut FLECS_IDEcsMilesPerHourID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Temperature quantity."]
    pub static mut EcsTemperature: ecs_entity_t;
}
extern "C" {
    #[doc = "< Temperature quantity."]
    pub static mut FLECS_IDEcsTemperatureID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Kelvin unit."]
    pub static mut EcsKelvin: ecs_entity_t;
}
extern "C" {
    #[doc = "< Kelvin unit."]
    pub static mut FLECS_IDEcsKelvinID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Celsius unit."]
    pub static mut EcsCelsius: ecs_entity_t;
}
extern "C" {
    #[doc = "< Celsius unit."]
    pub static mut FLECS_IDEcsCelsiusID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Fahrenheit unit."]
    pub static mut EcsFahrenheit: ecs_entity_t;
}
extern "C" {
    #[doc = "< Fahrenheit unit."]
    pub static mut FLECS_IDEcsFahrenheitID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Data quantity."]
    pub static mut EcsData: ecs_entity_t;
}
extern "C" {
    #[doc = "< Data quantity."]
    pub static mut FLECS_IDEcsDataID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Bits unit."]
    pub static mut EcsBits: ecs_entity_t;
}
extern "C" {
    #[doc = "< Bits unit."]
    pub static mut FLECS_IDEcsBitsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloBits unit."]
    pub static mut EcsKiloBits: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloBits unit."]
    pub static mut FLECS_IDEcsKiloBitsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaBits unit."]
    pub static mut EcsMegaBits: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaBits unit."]
    pub static mut FLECS_IDEcsMegaBitsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaBits unit."]
    pub static mut EcsGigaBits: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaBits unit."]
    pub static mut FLECS_IDEcsGigaBitsID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Bytes unit."]
    pub static mut EcsBytes: ecs_entity_t;
}
extern "C" {
    #[doc = "< Bytes unit."]
    pub static mut FLECS_IDEcsBytesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloBytes unit."]
    pub static mut EcsKiloBytes: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloBytes unit."]
    pub static mut FLECS_IDEcsKiloBytesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaBytes unit."]
    pub static mut EcsMegaBytes: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaBytes unit."]
    pub static mut FLECS_IDEcsMegaBytesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaBytes unit."]
    pub static mut EcsGigaBytes: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaBytes unit."]
    pub static mut FLECS_IDEcsGigaBytesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KibiBytes unit."]
    pub static mut EcsKibiBytes: ecs_entity_t;
}
extern "C" {
    #[doc = "< KibiBytes unit."]
    pub static mut FLECS_IDEcsKibiBytesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MebiBytes unit."]
    pub static mut EcsMebiBytes: ecs_entity_t;
}
extern "C" {
    #[doc = "< MebiBytes unit."]
    pub static mut FLECS_IDEcsMebiBytesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< GibiBytes unit."]
    pub static mut EcsGibiBytes: ecs_entity_t;
}
extern "C" {
    #[doc = "< GibiBytes unit."]
    pub static mut FLECS_IDEcsGibiBytesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< DataRate quantity."]
    pub static mut EcsDataRate: ecs_entity_t;
}
extern "C" {
    #[doc = "< DataRate quantity."]
    pub static mut FLECS_IDEcsDataRateID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< BitsPerSecond unit."]
    pub static mut EcsBitsPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< BitsPerSecond unit."]
    pub static mut FLECS_IDEcsBitsPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloBitsPerSecond unit."]
    pub static mut EcsKiloBitsPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloBitsPerSecond unit."]
    pub static mut FLECS_IDEcsKiloBitsPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaBitsPerSecond unit."]
    pub static mut EcsMegaBitsPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaBitsPerSecond unit."]
    pub static mut FLECS_IDEcsMegaBitsPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaBitsPerSecond unit."]
    pub static mut EcsGigaBitsPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaBitsPerSecond unit."]
    pub static mut FLECS_IDEcsGigaBitsPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< BytesPerSecond unit."]
    pub static mut EcsBytesPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< BytesPerSecond unit."]
    pub static mut FLECS_IDEcsBytesPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloBytesPerSecond unit."]
    pub static mut EcsKiloBytesPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloBytesPerSecond unit."]
    pub static mut FLECS_IDEcsKiloBytesPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaBytesPerSecond unit."]
    pub static mut EcsMegaBytesPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaBytesPerSecond unit."]
    pub static mut FLECS_IDEcsMegaBytesPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaBytesPerSecond unit."]
    pub static mut EcsGigaBytesPerSecond: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaBytesPerSecond unit."]
    pub static mut FLECS_IDEcsGigaBytesPerSecondID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Angle quantity."]
    pub static mut EcsAngle: ecs_entity_t;
}
extern "C" {
    #[doc = "< Angle quantity."]
    pub static mut FLECS_IDEcsAngleID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Radians unit."]
    pub static mut EcsRadians: ecs_entity_t;
}
extern "C" {
    #[doc = "< Radians unit."]
    pub static mut FLECS_IDEcsRadiansID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Degrees unit."]
    pub static mut EcsDegrees: ecs_entity_t;
}
extern "C" {
    #[doc = "< Degrees unit."]
    pub static mut FLECS_IDEcsDegreesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Frequency quantity."]
    pub static mut EcsFrequency: ecs_entity_t;
}
extern "C" {
    #[doc = "< Frequency quantity."]
    pub static mut FLECS_IDEcsFrequencyID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Hertz unit."]
    pub static mut EcsHertz: ecs_entity_t;
}
extern "C" {
    #[doc = "< Hertz unit."]
    pub static mut FLECS_IDEcsHertzID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloHertz unit."]
    pub static mut EcsKiloHertz: ecs_entity_t;
}
extern "C" {
    #[doc = "< KiloHertz unit."]
    pub static mut FLECS_IDEcsKiloHertzID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaHertz unit."]
    pub static mut EcsMegaHertz: ecs_entity_t;
}
extern "C" {
    #[doc = "< MegaHertz unit."]
    pub static mut FLECS_IDEcsMegaHertzID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaHertz unit."]
    pub static mut EcsGigaHertz: ecs_entity_t;
}
extern "C" {
    #[doc = "< GigaHertz unit."]
    pub static mut FLECS_IDEcsGigaHertzID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< URI quantity."]
    pub static mut EcsUri: ecs_entity_t;
}
extern "C" {
    #[doc = "< URI quantity."]
    pub static mut FLECS_IDEcsUriID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< UriHyperlink unit."]
    pub static mut EcsUriHyperlink: ecs_entity_t;
}
extern "C" {
    #[doc = "< UriHyperlink unit."]
    pub static mut FLECS_IDEcsUriHyperlinkID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< UriImage unit."]
    pub static mut EcsUriImage: ecs_entity_t;
}
extern "C" {
    #[doc = "< UriImage unit."]
    pub static mut FLECS_IDEcsUriImageID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< UriFile unit."]
    pub static mut EcsUriFile: ecs_entity_t;
}
extern "C" {
    #[doc = "< UriFile unit."]
    pub static mut FLECS_IDEcsUriFileID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Color quantity."]
    pub static mut EcsColor: ecs_entity_t;
}
extern "C" {
    #[doc = "< Color quantity."]
    pub static mut FLECS_IDEcsColorID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< ColorRgb unit."]
    pub static mut EcsColorRgb: ecs_entity_t;
}
extern "C" {
    #[doc = "< ColorRgb unit."]
    pub static mut FLECS_IDEcsColorRgbID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< ColorHsl unit."]
    pub static mut EcsColorHsl: ecs_entity_t;
}
extern "C" {
    #[doc = "< ColorHsl unit."]
    pub static mut FLECS_IDEcsColorHslID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< ColorCss unit."]
    pub static mut EcsColorCss: ecs_entity_t;
}
extern "C" {
    #[doc = "< ColorCss unit."]
    pub static mut FLECS_IDEcsColorCssID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Acceleration unit."]
    pub static mut EcsAcceleration: ecs_entity_t;
}
extern "C" {
    #[doc = "< Acceleration unit."]
    pub static mut FLECS_IDEcsAccelerationID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Percentage unit."]
    pub static mut EcsPercentage: ecs_entity_t;
}
extern "C" {
    #[doc = "< Percentage unit."]
    pub static mut FLECS_IDEcsPercentageID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Bel unit."]
    pub static mut EcsBel: ecs_entity_t;
}
extern "C" {
    #[doc = "< Bel unit."]
    pub static mut FLECS_IDEcsBelID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< DeciBel unit."]
    pub static mut EcsDeciBel: ecs_entity_t;
}
extern "C" {
    #[doc = "< DeciBel unit."]
    pub static mut FLECS_IDEcsDeciBelID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Units module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsUnits)\n @endcode\n\n @param world The world."]
    pub fn FlecsUnitsImport(world: *mut ecs_world_t);
}
extern "C" {
    pub static mut FLECS_IDEcsScriptID_: ecs_entity_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_script_template_t {
    _unused: [u8; 0],
}
#[doc = " Script variable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_script_var_t {
    pub name: *const ::std::os::raw::c_char,
    pub value: ecs_value_t,
    pub type_info: *const ecs_type_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_script_var_t"][::std::mem::size_of::<ecs_script_var_t>() - 32usize];
    ["Alignment of ecs_script_var_t"][::std::mem::align_of::<ecs_script_var_t>() - 8usize];
    ["Offset of field: ecs_script_var_t::name"]
        [::std::mem::offset_of!(ecs_script_var_t, name) - 0usize];
    ["Offset of field: ecs_script_var_t::value"]
        [::std::mem::offset_of!(ecs_script_var_t, value) - 8usize];
    ["Offset of field: ecs_script_var_t::type_info"]
        [::std::mem::offset_of!(ecs_script_var_t, type_info) - 24usize];
};
#[doc = " Script variable scope."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_script_vars_t {
    pub parent: *mut ecs_script_vars_t,
    pub var_index: ecs_hashmap_t,
    pub vars: ecs_vec_t,
    pub world: *const ecs_world_t,
    pub stack: *mut ecs_stack_t,
    pub cursor: *mut ecs_stack_cursor_t,
    pub allocator: *mut ecs_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_script_vars_t"][::std::mem::size_of::<ecs_script_vars_t>() - 176usize];
    ["Alignment of ecs_script_vars_t"][::std::mem::align_of::<ecs_script_vars_t>() - 8usize];
    ["Offset of field: ecs_script_vars_t::parent"]
        [::std::mem::offset_of!(ecs_script_vars_t, parent) - 0usize];
    ["Offset of field: ecs_script_vars_t::var_index"]
        [::std::mem::offset_of!(ecs_script_vars_t, var_index) - 8usize];
    ["Offset of field: ecs_script_vars_t::vars"]
        [::std::mem::offset_of!(ecs_script_vars_t, vars) - 128usize];
    ["Offset of field: ecs_script_vars_t::world"]
        [::std::mem::offset_of!(ecs_script_vars_t, world) - 144usize];
    ["Offset of field: ecs_script_vars_t::stack"]
        [::std::mem::offset_of!(ecs_script_vars_t, stack) - 152usize];
    ["Offset of field: ecs_script_vars_t::cursor"]
        [::std::mem::offset_of!(ecs_script_vars_t, cursor) - 160usize];
    ["Offset of field: ecs_script_vars_t::allocator"]
        [::std::mem::offset_of!(ecs_script_vars_t, allocator) - 168usize];
};
#[doc = " Script object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_script_t {
    pub world: *mut ecs_world_t,
    pub name: *const ::std::os::raw::c_char,
    pub code: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_script_t"][::std::mem::size_of::<ecs_script_t>() - 24usize];
    ["Alignment of ecs_script_t"][::std::mem::align_of::<ecs_script_t>() - 8usize];
    ["Offset of field: ecs_script_t::world"][::std::mem::offset_of!(ecs_script_t, world) - 0usize];
    ["Offset of field: ecs_script_t::name"][::std::mem::offset_of!(ecs_script_t, name) - 8usize];
    ["Offset of field: ecs_script_t::code"][::std::mem::offset_of!(ecs_script_t, code) - 16usize];
};
#[doc = " Script component.\n This component is added to the entities of managed scripts and templates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsScript {
    pub script: *mut ecs_script_t,
    pub template_: *mut ecs_script_template_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsScript"][::std::mem::size_of::<EcsScript>() - 16usize];
    ["Alignment of EcsScript"][::std::mem::align_of::<EcsScript>() - 8usize];
    ["Offset of field: EcsScript::script"][::std::mem::offset_of!(EcsScript, script) - 0usize];
    ["Offset of field: EcsScript::template_"]
        [::std::mem::offset_of!(EcsScript, template_) - 8usize];
};
extern "C" {
    #[doc = " Parse script.\n This operation parses a script and returns a script object upon success. To\n run the script, call ecs_script_eval().\n\n @param world The world.\n @param name Name of the script (typically a file/module name).\n @param code The script code.\n @return Script object if success, NULL if failed."]
    pub fn ecs_script_parse(
        world: *mut ecs_world_t,
        name: *const ::std::os::raw::c_char,
        code: *const ::std::os::raw::c_char,
    ) -> *mut ecs_script_t;
}
extern "C" {
    #[doc = " Evaluate script.\n This operation evaluates (runs) a parsed script.\n\n @param script The script.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_script_eval(script: *mut ecs_script_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free script.\n This operation frees a script object.\n\n Templates created by the script rely upon resources in the script object,\n and for that reason keep the script alive until all templates created by the\n script are deleted.\n\n @param script The script."]
    pub fn ecs_script_free(script: *mut ecs_script_t);
}
extern "C" {
    #[doc = " Parse script.\n This parses a script and instantiates the entities in the world.\n This operation is the equivalent to doing:\n\n @code\n ecs_script_t *script = ecs_script_parse(world, name, code);\n ecs_script_eval(script);\n ecs_script_free(script);\n @endcode\n\n @param world The world.\n @param name The script name (typically the file).\n @param code The script.\n @return Zero if success, non-zero otherwise."]
    pub fn ecs_script_run(
        world: *mut ecs_world_t,
        name: *const ::std::os::raw::c_char,
        code: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse script file.\n This parses a script file and instantiates the entities in the world. This\n operation is equivalent to loading the file contents and passing it to\n ecs_script_run().\n\n @param world The world.\n @param filename The script file name.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_script_run_file(
        world: *mut ecs_world_t,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert script AST to string.\n This operation converts the script abstract syntax tree to a string, which\n can be used to debug a script.\n\n @param script The script.\n @param buf The buffer to write to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_script_ast_to_buf(
        script: *mut ecs_script_t,
        buf: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert script AST to string.\n This operation converts the script abstract syntax tree to a string, which\n can be used to debug a script.\n\n @param script The script.\n @return The string if success, NULL if failed."]
    pub fn ecs_script_ast_to_str(script: *mut ecs_script_t) -> *mut ::std::os::raw::c_char;
}
#[doc = " Used with ecs_script_init()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_script_desc_t {
    pub entity: ecs_entity_t,
    pub filename: *const ::std::os::raw::c_char,
    pub code: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_script_desc_t"][::std::mem::size_of::<ecs_script_desc_t>() - 24usize];
    ["Alignment of ecs_script_desc_t"][::std::mem::align_of::<ecs_script_desc_t>() - 8usize];
    ["Offset of field: ecs_script_desc_t::entity"]
        [::std::mem::offset_of!(ecs_script_desc_t, entity) - 0usize];
    ["Offset of field: ecs_script_desc_t::filename"]
        [::std::mem::offset_of!(ecs_script_desc_t, filename) - 8usize];
    ["Offset of field: ecs_script_desc_t::code"]
        [::std::mem::offset_of!(ecs_script_desc_t, code) - 16usize];
};
extern "C" {
    #[doc = " Load managed script.\n A managed script tracks which entities it creates, and keeps those entities\n synchronized when the contents of the script are updated. When the script is\n updated, entities that are no longer in the new version will be deleted.\n\n This feature is experimental.\n\n @param world The world.\n @param desc Script descriptor."]
    pub fn ecs_script_init(world: *mut ecs_world_t, desc: *const ecs_script_desc_t)
        -> ecs_entity_t;
}
extern "C" {
    #[doc = " Update script with new code.\n\n @param world The world.\n @param script The script entity.\n @param instance An template instance (optional).\n @param code The script code."]
    pub fn ecs_script_update(
        world: *mut ecs_world_t,
        script: ecs_entity_t,
        instance: ecs_entity_t,
        code: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clear all entities associated with script.\n\n @param world The world.\n @param script The script entity.\n @param instance The script instance."]
    pub fn ecs_script_clear(world: *mut ecs_world_t, script: ecs_entity_t, instance: ecs_entity_t);
}
extern "C" {
    #[doc = " Create new variable scope.\n Create root variable scope. A variable scope contains one or more variables.\n Scopes can be nested, which allows variables in different scopes to have the\n same name. Variables from parent scopes will be shadowed by variables in\n child scopes with the same name.\n\n Use the `ecs_script_vars_push()` and `ecs_script_vars_pop()` functions to\n push and pop variable scopes.\n\n When a variable contains allocated resources (e.g. a string), its resources\n will be freed when `ecs_script_vars_pop()` is called on the scope, the\n ecs_script_vars_t::type_info field is initialized for the variable, and\n `ecs_type_info_t::hooks::dtor` is set.\n\n @param world The world."]
    pub fn ecs_script_vars_init(world: *mut ecs_world_t) -> *mut ecs_script_vars_t;
}
extern "C" {
    #[doc = " Free variable scope.\n Free root variable scope. The provided scope should not have a parent. This\n operation calls `ecs_script_vars_pop()` on the scope.\n\n @param vars The variable scope."]
    pub fn ecs_script_vars_fini(vars: *mut ecs_script_vars_t);
}
extern "C" {
    #[doc = " Push new variable scope.\n\n Scopes created with ecs_script_vars_push() must be cleaned up with\n ecs_script_vars_pop().\n\n If the stack and allocator arguments are left to NULL, their values will be\n copied from the parent.\n\n @param parent The parent scope (provide NULL for root scope).\n @return The new variable scope."]
    pub fn ecs_script_vars_push(parent: *mut ecs_script_vars_t) -> *mut ecs_script_vars_t;
}
extern "C" {
    #[doc = " Pop variable scope.\n This frees up the resources for a variable scope. The scope must be at the\n top of a vars stack. Calling ecs_script_vars_pop() on a scope that is not the\n last scope causes undefined behavior.\n\n @param vars The scope to free.\n @return The parent scope."]
    pub fn ecs_script_vars_pop(vars: *mut ecs_script_vars_t) -> *mut ecs_script_vars_t;
}
extern "C" {
    #[doc = " Declare a variable.\n This operation declares a new variable in the current scope. If a variable\n with the specified name already exists, the operation will fail.\n\n This operation does not allocate storage for the variable. This is done to\n allow for variables that point to existing storage, which prevents having\n to copy existing values to a variable scope.\n\n @param vars The variable scope.\n @param name The variable name.\n @return The new variable, or NULL if the operation failed."]
    pub fn ecs_script_vars_declare(
        vars: *mut ecs_script_vars_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ecs_script_var_t;
}
extern "C" {
    #[doc = " Define a variable.\n This operation calls `ecs_script_vars_declare()` and allocates storage for\n the variable. If the type has a ctor, it will be called on the new storage.\n\n The scope's stack allocator will be used to allocate the storage. After\n `ecs_script_vars_pop()` is called on the scope, the variable storage will no\n longer be valid.\n\n The operation will fail if the type argument is not a type.\n\n @param vars The variable scope.\n @param name The variable name.\n @param type The variable type.\n @return The new variable, or NULL if the operation failed."]
    pub fn ecs_script_vars_define_id(
        vars: *mut ecs_script_vars_t,
        name: *const ::std::os::raw::c_char,
        type_: ecs_entity_t,
    ) -> *mut ecs_script_var_t;
}
extern "C" {
    #[doc = " Lookup a variable.\n This operation looks up a variable in the current scope. If the variable\n can't be found in the current scope, the operation will recursively search\n the parent scopes.\n\n @param vars The variable scope.\n @param name The variable name.\n @return The variable, or NULL if one with the provided name does not exist."]
    pub fn ecs_script_vars_lookup(
        vars: *const ecs_script_vars_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ecs_script_var_t;
}
extern "C" {
    #[doc = " Convert iterator to vars\n This operation converts an iterator to a variable array. This allows for\n using iterator results in expressions. The operation only converts a\n single result at a time, and does not progress the iterator.\n\n Iterator fields with data will be made available as variables with as name\n the field index (e.g. \"$1\"). The operation does not check if reflection data\n is registered for a field type. If no reflection data is registered for the\n type, using the field variable in expressions will fail.\n\n Field variables will only contain single elements, even if the iterator\n returns component arrays. The offset parameter can be used to specify which\n element in the component arrays to return. The offset parameter must be\n smaller than it->count.\n\n The operation will create a variable for query variables that contain a\n single entity.\n\n The operation will attempt to use existing variables. If a variable does not\n yet exist, the operation will create it. If an existing variable exists with\n a mismatching type, the operation will fail.\n\n Accessing variables after progressing the iterator or after the iterator is\n destroyed will result in undefined behavior.\n\n If vars contains a variable that is not present in the iterator, the variable\n will not be modified.\n\n @param it The iterator to convert to variables.\n @param vars The variables to write to.\n @param offset The offset to the current element."]
    pub fn ecs_script_vars_from_iter(
        it: *const ecs_iter_t,
        vars: *mut ecs_script_vars_t,
        offset: ::std::os::raw::c_int,
    );
}
#[doc = " Used with ecs_script_expr_run()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_script_expr_run_desc_t {
    pub name: *const ::std::os::raw::c_char,
    pub expr: *const ::std::os::raw::c_char,
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ecs_world_t,
            value: *const ::std::os::raw::c_char,
            ctx: *mut ::std::os::raw::c_void,
        ) -> ecs_entity_t,
    >,
    pub lookup_ctx: *mut ::std::os::raw::c_void,
    pub vars: *mut ecs_script_vars_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_script_expr_run_desc_t"]
        [::std::mem::size_of::<ecs_script_expr_run_desc_t>() - 40usize];
    ["Alignment of ecs_script_expr_run_desc_t"]
        [::std::mem::align_of::<ecs_script_expr_run_desc_t>() - 8usize];
    ["Offset of field: ecs_script_expr_run_desc_t::name"]
        [::std::mem::offset_of!(ecs_script_expr_run_desc_t, name) - 0usize];
    ["Offset of field: ecs_script_expr_run_desc_t::expr"]
        [::std::mem::offset_of!(ecs_script_expr_run_desc_t, expr) - 8usize];
    ["Offset of field: ecs_script_expr_run_desc_t::lookup_action"]
        [::std::mem::offset_of!(ecs_script_expr_run_desc_t, lookup_action) - 16usize];
    ["Offset of field: ecs_script_expr_run_desc_t::lookup_ctx"]
        [::std::mem::offset_of!(ecs_script_expr_run_desc_t, lookup_ctx) - 24usize];
    ["Offset of field: ecs_script_expr_run_desc_t::vars"]
        [::std::mem::offset_of!(ecs_script_expr_run_desc_t, vars) - 32usize];
};
extern "C" {
    #[doc = " Parse standalone expression into value.\n This operation parses a flecs expression into the provided pointer. The\n memory pointed to must be large enough to contain a value of the used type.\n\n If no type and pointer are provided for the value argument, the operation\n will discover the type from the expression and allocate storage for the\n value. The allocated value must be freed with ecs_value_free().\n\n @param world The world.\n @param ptr The pointer to the expression to parse.\n @param value The value containing type & pointer to write to.\n @param desc Configuration parameters for deserializer.\n @return Pointer to the character after the last one read, or NULL if failed."]
    pub fn ecs_script_expr_run(
        world: *mut ecs_world_t,
        ptr: *const ::std::os::raw::c_char,
        value: *mut ecs_value_t,
        desc: *const ecs_script_expr_run_desc_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Evaluate interpolated expressions in string.\n This operation evaluates expressions in a string, and replaces them with\n their evaluated result. Supported expression formats are:\n  - $variable_name\n  - {expression}\n\n The $, { and } characters can be escaped with a backslash (\\).\n\n @param world The world.\n @param str The string to evaluate.\n @param vars The variables to use for evaluation."]
    pub fn ecs_script_string_interpolate(
        world: *mut ecs_world_t,
        str_: *const ::std::os::raw::c_char,
        vars: *const ecs_script_vars_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize value into expression string.\n This operation serializes a value of the provided type to a string. The\n memory pointed to must be large enough to contain a value of the used type.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @return String with expression, or NULL if failed."]
    pub fn ecs_ptr_to_expr(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize value into expression buffer.\n Same as ecs_ptr_to_expr(), but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param buf The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_ptr_to_expr_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        buf: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Similar as ecs_ptr_to_expr(), but serializes values to string.\n Whereas the output of ecs_ptr_to_expr() is a valid expression, the output of\n ecs_ptr_to_str() is a string representation of the value. In most cases the\n output of the two operations is the same, but there are some differences:\n - Strings are not quoted\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @return String with result, or NULL if failed."]
    pub fn ecs_ptr_to_str(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Serialize value into string buffer.\n Same as ecs_ptr_to_str(), but serializes to an ecs_strbuf_t instance.\n\n @param world The world.\n @param type The type of the value to serialize.\n @param data The value to serialize.\n @param buf The strbuf to append the string to.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_ptr_to_str_buf(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        data: *const ::std::os::raw::c_void,
        buf: *mut ecs_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Script module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsScript)\n @endcode\n\n @param world The world."]
    pub fn FlecsScriptImport(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = "< Component id for EcsDocDescription."]
    pub static FLECS_IDEcsDocDescriptionID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag for adding brief descriptions to entities.\n Added to an entity as (EcsDocDescription, EcsBrief) by ecs_doc_set_brief()."]
    pub static EcsDocBrief: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag for adding detailed descriptions to entities.\n Added to an entity as (EcsDocDescription, EcsDocDetail) by ecs_doc_set_detail()."]
    pub static EcsDocDetail: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag for adding a link to entities.\n Added to an entity as (EcsDocDescription, EcsDocLink) by ecs_doc_set_link()."]
    pub static EcsDocLink: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag for adding a color to entities.\n Added to an entity as (EcsDocDescription, EcsDocColor) by ecs_doc_set_link()."]
    pub static EcsDocColor: ecs_entity_t;
}
#[doc = " Component that stores description.\n Used as pair together with the following tags to store entity documentation:\n - EcsName\n - EcsDocBrief\n - EcsDocDetail\n - EcsDocLink\n - EcsDocColor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsDocDescription {
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsDocDescription"][::std::mem::size_of::<EcsDocDescription>() - 8usize];
    ["Alignment of EcsDocDescription"][::std::mem::align_of::<EcsDocDescription>() - 8usize];
    ["Offset of field: EcsDocDescription::value"]
        [::std::mem::offset_of!(EcsDocDescription, value) - 0usize];
};
extern "C" {
    #[doc = " Add human-readable name to entity.\n Contrary to entity names, human readable names do not have to be unique and\n can contain special characters used in the query language like '*'.\n\n @param world The world.\n @param entity The entity to which to add the name.\n @param name The name to add.\n\n @see ecs_doc_get_name()\n @see flecs::doc::set_name()\n @see flecs::entity_builder::set_doc_name()"]
    pub fn ecs_doc_set_name(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add brief description to entity.\n\n @param world The world.\n @param entity The entity to which to add the description.\n @param description The description to add.\n\n @see ecs_doc_get_brief()\n @see flecs::doc::set_brief()\n @see flecs::entity_builder::set_doc_brief()"]
    pub fn ecs_doc_set_brief(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add detailed description to entity.\n\n @param world The world.\n @param entity The entity to which to add the description.\n @param description The description to add.\n\n @see ecs_doc_get_detail()\n @see flecs::doc::set_detail()\n @see flecs::entity_builder::set_doc_detail()"]
    pub fn ecs_doc_set_detail(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add link to external documentation to entity.\n\n @param world The world.\n @param entity The entity to which to add the link.\n @param link The link to add.\n\n @see ecs_doc_get_link()\n @see flecs::doc::set_link()\n @see flecs::entity_builder::set_doc_link()"]
    pub fn ecs_doc_set_link(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        link: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Add color to entity.\n UIs can use color as hint to improve visualizing entities.\n\n @param world The world.\n @param entity The entity to which to add the link.\n @param color The color to add.\n\n @see ecs_doc_get_color()\n @see flecs::doc::set_color()\n @see flecs::entity_builder::set_doc_color()"]
    pub fn ecs_doc_set_color(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        color: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Get human readable name from entity.\n If entity does not have an explicit human readable name, this operation will\n return the entity name.\n\n To test if an entity has a human readable name, use:\n\n @code\n ecs_has_pair(world, e, ecs_id(EcsDocDescription), EcsName);\n @endcode\n\n Or in C++:\n\n @code\n e.has<flecs::doc::Description>(flecs::Name);\n @endcode\n\n @param world The world.\n @param entity The entity from which to get the name.\n @return The name.\n\n @see ecs_doc_set_name()\n @see flecs::doc::get_name()\n @see flecs::entity_view::get_doc_name()"]
    pub fn ecs_doc_get_name(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get brief description from entity.\n\n @param world The world.\n @param entity The entity from which to get the description.\n @return The description.\n\n @see ecs_doc_set_brief()\n @see flecs::doc::get_brief()\n @see flecs::entity_view::get_doc_brief()"]
    pub fn ecs_doc_get_brief(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get detailed description from entity.\n\n @param world The world.\n @param entity The entity from which to get the description.\n @return The description.\n\n @see ecs_doc_set_detail()\n @see flecs::doc::get_detail()\n @see flecs::entity_view::get_doc_detail()"]
    pub fn ecs_doc_get_detail(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get link to external documentation from entity.\n\n @param world The world.\n @param entity The entity from which to get the link.\n @return The link.\n\n @see ecs_doc_set_link()\n @see flecs::doc::get_link()\n @see flecs::entity_view::get_doc_link()"]
    pub fn ecs_doc_get_link(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get color from entity.\n\n @param world The world.\n @param entity The entity from which to get the color.\n @return The color.\n\n @see ecs_doc_set_color()\n @see flecs::doc::get_color()\n @see flecs::entity_view::get_doc_color()"]
    pub fn ecs_doc_get_color(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Doc module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsDoc)\n @endcode\n\n @param world The world."]
    pub fn FlecsDocImport(world: *mut ecs_world_t);
}
pub type max_align_t = f64;
#[doc = " Primitive type definitions.\n These typedefs allow the builtin primitives to be used as regular components:\n\n @code\n ecs_set(world, e, ecs_i32_t, {10});\n @endcode\n\n Or a more useful example (create an enum constant with a manual value):\n\n @code\n ecs_set_pair_second(world, e, EcsConstant, ecs_i32_t, {10});\n @endcode"]
pub type ecs_bool_t = bool;
pub type ecs_char_t = ::std::os::raw::c_char;
pub type ecs_byte_t = ::std::os::raw::c_uchar;
pub type ecs_u8_t = u8;
pub type ecs_u16_t = u16;
pub type ecs_u32_t = u32;
pub type ecs_u64_t = u64;
pub type ecs_uptr_t = usize;
pub type ecs_i8_t = i8;
pub type ecs_i16_t = i16;
pub type ecs_i32_t = i32;
pub type ecs_i64_t = i64;
pub type ecs_iptr_t = isize;
pub type ecs_f32_t = f32;
pub type ecs_f64_t = f64;
pub type ecs_string_t = *mut ::std::os::raw::c_char;
extern "C" {
    #[doc = "< Id for component added to all types with reflection data."]
    pub static FLECS_IDEcsTypeID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores a type specific serializer."]
    pub static FLECS_IDEcsTypeSerializerID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores reflection data for a primitive type."]
    pub static FLECS_IDEcsPrimitiveID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores reflection data for an enum type."]
    pub static FLECS_IDEcsEnumID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores reflection data for a bitmask type."]
    pub static FLECS_IDEcsBitmaskID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores reflection data for struct members."]
    pub static FLECS_IDEcsMemberID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores min/max ranges for member values."]
    pub static FLECS_IDEcsMemberRangesID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores reflection data for a struct type."]
    pub static FLECS_IDEcsStructID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores reflection data for an array type."]
    pub static FLECS_IDEcsArrayID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores reflection data for a vector type."]
    pub static FLECS_IDEcsVectorID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores reflection data for an opaque type."]
    pub static FLECS_IDEcsOpaqueID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores unit data."]
    pub static FLECS_IDEcsUnitID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Id for component that stores unit prefix data."]
    pub static FLECS_IDEcsUnitPrefixID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tag added to enum/bitmask constants."]
    pub static EcsConstant: ecs_entity_t;
}
extern "C" {
    #[doc = "< Tag added to unit quantities."]
    pub static EcsQuantity: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin boolean type."]
    pub static FLECS_IDecs_bool_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin char type."]
    pub static FLECS_IDecs_char_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin byte type."]
    pub static FLECS_IDecs_byte_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 8 bit unsigned int type."]
    pub static FLECS_IDecs_u8_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 16 bit unsigned int type."]
    pub static FLECS_IDecs_u16_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 32 bit unsigned int type."]
    pub static FLECS_IDecs_u32_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 64 bit unsigned int type."]
    pub static FLECS_IDecs_u64_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin pointer sized unsigned int type."]
    pub static FLECS_IDecs_uptr_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 8 bit signed int type."]
    pub static FLECS_IDecs_i8_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 16 bit signed int type."]
    pub static FLECS_IDecs_i16_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 32 bit signed int type."]
    pub static FLECS_IDecs_i32_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 64 bit signed int type."]
    pub static FLECS_IDecs_i64_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin pointer sized signed int type."]
    pub static FLECS_IDecs_iptr_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 32 bit floating point type."]
    pub static FLECS_IDecs_f32_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin 64 bit floating point type."]
    pub static FLECS_IDecs_f64_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin string type."]
    pub static FLECS_IDecs_string_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin entity type."]
    pub static FLECS_IDecs_entity_tID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< Builtin (component) id type."]
    pub static FLECS_IDecs_id_tID_: ecs_entity_t;
}
pub const ecs_type_kind_t_EcsPrimitiveType: ecs_type_kind_t = 0;
pub const ecs_type_kind_t_EcsBitmaskType: ecs_type_kind_t = 1;
pub const ecs_type_kind_t_EcsEnumType: ecs_type_kind_t = 2;
pub const ecs_type_kind_t_EcsStructType: ecs_type_kind_t = 3;
pub const ecs_type_kind_t_EcsArrayType: ecs_type_kind_t = 4;
pub const ecs_type_kind_t_EcsVectorType: ecs_type_kind_t = 5;
pub const ecs_type_kind_t_EcsOpaqueType: ecs_type_kind_t = 6;
pub const ecs_type_kind_t_EcsTypeKindLast: ecs_type_kind_t = 6;
#[doc = " Type kinds supported by meta addon"]
pub type ecs_type_kind_t = ::std::os::raw::c_int;
#[doc = " Component that is automatically added to every type with the right kind."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsType {
    #[doc = "< Type kind."]
    pub kind: ecs_type_kind_t,
    #[doc = "< Did the type exist or is it populated from reflection"]
    pub existing: bool,
    #[doc = "< Is the reflection data a partial type description"]
    pub partial: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsType"][::std::mem::size_of::<EcsType>() - 8usize];
    ["Alignment of EcsType"][::std::mem::align_of::<EcsType>() - 4usize];
    ["Offset of field: EcsType::kind"][::std::mem::offset_of!(EcsType, kind) - 0usize];
    ["Offset of field: EcsType::existing"][::std::mem::offset_of!(EcsType, existing) - 4usize];
    ["Offset of field: EcsType::partial"][::std::mem::offset_of!(EcsType, partial) - 5usize];
};
pub const ecs_primitive_kind_t_EcsBool: ecs_primitive_kind_t = 1;
pub const ecs_primitive_kind_t_EcsChar: ecs_primitive_kind_t = 2;
pub const ecs_primitive_kind_t_EcsByte: ecs_primitive_kind_t = 3;
pub const ecs_primitive_kind_t_EcsU8: ecs_primitive_kind_t = 4;
pub const ecs_primitive_kind_t_EcsU16: ecs_primitive_kind_t = 5;
pub const ecs_primitive_kind_t_EcsU32: ecs_primitive_kind_t = 6;
pub const ecs_primitive_kind_t_EcsU64: ecs_primitive_kind_t = 7;
pub const ecs_primitive_kind_t_EcsI8: ecs_primitive_kind_t = 8;
pub const ecs_primitive_kind_t_EcsI16: ecs_primitive_kind_t = 9;
pub const ecs_primitive_kind_t_EcsI32: ecs_primitive_kind_t = 10;
pub const ecs_primitive_kind_t_EcsI64: ecs_primitive_kind_t = 11;
pub const ecs_primitive_kind_t_EcsF32: ecs_primitive_kind_t = 12;
pub const ecs_primitive_kind_t_EcsF64: ecs_primitive_kind_t = 13;
pub const ecs_primitive_kind_t_EcsUPtr: ecs_primitive_kind_t = 14;
pub const ecs_primitive_kind_t_EcsIPtr: ecs_primitive_kind_t = 15;
pub const ecs_primitive_kind_t_EcsString: ecs_primitive_kind_t = 16;
pub const ecs_primitive_kind_t_EcsEntity: ecs_primitive_kind_t = 17;
pub const ecs_primitive_kind_t_EcsId: ecs_primitive_kind_t = 18;
pub const ecs_primitive_kind_t_EcsPrimitiveKindLast: ecs_primitive_kind_t = 18;
#[doc = " Primitive type kinds supported by meta addon"]
pub type ecs_primitive_kind_t = ::std::os::raw::c_int;
#[doc = " Component added to primitive types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsPrimitive {
    #[doc = "< Primitive type kind."]
    pub kind: ecs_primitive_kind_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsPrimitive"][::std::mem::size_of::<EcsPrimitive>() - 4usize];
    ["Alignment of EcsPrimitive"][::std::mem::align_of::<EcsPrimitive>() - 4usize];
    ["Offset of field: EcsPrimitive::kind"][::std::mem::offset_of!(EcsPrimitive, kind) - 0usize];
};
#[doc = " Component added to member entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMember {
    #[doc = "< Member type."]
    pub type_: ecs_entity_t,
    #[doc = "< Number of elements (for inline arrays)."]
    pub count: i32,
    #[doc = "< Member unit."]
    pub unit: ecs_entity_t,
    #[doc = "< Member offset."]
    pub offset: i32,
    #[doc = "< If offset should be explicitly used."]
    pub use_offset: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsMember"][::std::mem::size_of::<EcsMember>() - 32usize];
    ["Alignment of EcsMember"][::std::mem::align_of::<EcsMember>() - 8usize];
    ["Offset of field: EcsMember::type_"][::std::mem::offset_of!(EcsMember, type_) - 0usize];
    ["Offset of field: EcsMember::count"][::std::mem::offset_of!(EcsMember, count) - 8usize];
    ["Offset of field: EcsMember::unit"][::std::mem::offset_of!(EcsMember, unit) - 16usize];
    ["Offset of field: EcsMember::offset"][::std::mem::offset_of!(EcsMember, offset) - 24usize];
    ["Offset of field: EcsMember::use_offset"]
        [::std::mem::offset_of!(EcsMember, use_offset) - 28usize];
};
#[doc = " Type expressing a range for a member value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_member_value_range_t {
    #[doc = "< Min member value."]
    pub min: f64,
    #[doc = "< Max member value."]
    pub max: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_member_value_range_t"]
        [::std::mem::size_of::<ecs_member_value_range_t>() - 16usize];
    ["Alignment of ecs_member_value_range_t"]
        [::std::mem::align_of::<ecs_member_value_range_t>() - 8usize];
    ["Offset of field: ecs_member_value_range_t::min"]
        [::std::mem::offset_of!(ecs_member_value_range_t, min) - 0usize];
    ["Offset of field: ecs_member_value_range_t::max"]
        [::std::mem::offset_of!(ecs_member_value_range_t, max) - 8usize];
};
#[doc = " Component added to member entities to express valid value ranges"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsMemberRanges {
    #[doc = "< Member value range."]
    pub value: ecs_member_value_range_t,
    #[doc = "< Member value warning range."]
    pub warning: ecs_member_value_range_t,
    #[doc = "< Member value error range."]
    pub error: ecs_member_value_range_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsMemberRanges"][::std::mem::size_of::<EcsMemberRanges>() - 48usize];
    ["Alignment of EcsMemberRanges"][::std::mem::align_of::<EcsMemberRanges>() - 8usize];
    ["Offset of field: EcsMemberRanges::value"]
        [::std::mem::offset_of!(EcsMemberRanges, value) - 0usize];
    ["Offset of field: EcsMemberRanges::warning"]
        [::std::mem::offset_of!(EcsMemberRanges, warning) - 16usize];
    ["Offset of field: EcsMemberRanges::error"]
        [::std::mem::offset_of!(EcsMemberRanges, error) - 32usize];
};
#[doc = " Element type of members vector in EcsStruct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_member_t {
    #[doc = " Must be set when used with ecs_struct_desc_t"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Member type."]
    pub type_: ecs_entity_t,
    #[doc = " Element count (for inline arrays). May be set when used with ecs_struct_desc_t"]
    pub count: i32,
    #[doc = " May be set when used with ecs_struct_desc_t. Member offset."]
    pub offset: i32,
    #[doc = " May be set when used with ecs_struct_desc_t, will be auto-populated if\n type entity is also a unit"]
    pub unit: ecs_entity_t,
    #[doc = " Set to true to prevent automatic offset computation. This option should\n be used when members are registered out of order or where calculation of\n member offsets doesn't match C type offsets."]
    pub use_offset: bool,
    #[doc = " Numerical range that specifies which values member can assume. This\n range may be used by UI elements such as a progress bar or slider. The\n value of a member should not exceed this range."]
    pub range: ecs_member_value_range_t,
    #[doc = " Numerical range outside of which the value represents an error. This\n range may be used by UI elements to style a value."]
    pub error_range: ecs_member_value_range_t,
    #[doc = " Numerical range outside of which the value represents an warning. This\n range may be used by UI elements to style a value."]
    pub warning_range: ecs_member_value_range_t,
    #[doc = " Should not be set by ecs_struct_desc_t"]
    pub size: ecs_size_t,
    #[doc = " Should not be set by ecs_struct_desc_t"]
    pub member: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_member_t"][::std::mem::size_of::<ecs_member_t>() - 104usize];
    ["Alignment of ecs_member_t"][::std::mem::align_of::<ecs_member_t>() - 8usize];
    ["Offset of field: ecs_member_t::name"][::std::mem::offset_of!(ecs_member_t, name) - 0usize];
    ["Offset of field: ecs_member_t::type_"][::std::mem::offset_of!(ecs_member_t, type_) - 8usize];
    ["Offset of field: ecs_member_t::count"][::std::mem::offset_of!(ecs_member_t, count) - 16usize];
    ["Offset of field: ecs_member_t::offset"]
        [::std::mem::offset_of!(ecs_member_t, offset) - 20usize];
    ["Offset of field: ecs_member_t::unit"][::std::mem::offset_of!(ecs_member_t, unit) - 24usize];
    ["Offset of field: ecs_member_t::use_offset"]
        [::std::mem::offset_of!(ecs_member_t, use_offset) - 32usize];
    ["Offset of field: ecs_member_t::range"][::std::mem::offset_of!(ecs_member_t, range) - 40usize];
    ["Offset of field: ecs_member_t::error_range"]
        [::std::mem::offset_of!(ecs_member_t, error_range) - 56usize];
    ["Offset of field: ecs_member_t::warning_range"]
        [::std::mem::offset_of!(ecs_member_t, warning_range) - 72usize];
    ["Offset of field: ecs_member_t::size"][::std::mem::offset_of!(ecs_member_t, size) - 88usize];
    ["Offset of field: ecs_member_t::member"]
        [::std::mem::offset_of!(ecs_member_t, member) - 96usize];
};
#[doc = " Component added to struct type entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsStruct {
    #[doc = " Populated from child entities with Member component"]
    pub members: ecs_vec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsStruct"][::std::mem::size_of::<EcsStruct>() - 16usize];
    ["Alignment of EcsStruct"][::std::mem::align_of::<EcsStruct>() - 8usize];
    ["Offset of field: EcsStruct::members"][::std::mem::offset_of!(EcsStruct, members) - 0usize];
};
#[doc = " Type that describes an enum constant"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_enum_constant_t {
    #[doc = " Must be set when used with ecs_enum_desc_t"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " May be set when used with ecs_enum_desc_t"]
    pub value: i32,
    #[doc = " Should not be set by ecs_enum_desc_t"]
    pub constant: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_enum_constant_t"][::std::mem::size_of::<ecs_enum_constant_t>() - 24usize];
    ["Alignment of ecs_enum_constant_t"][::std::mem::align_of::<ecs_enum_constant_t>() - 8usize];
    ["Offset of field: ecs_enum_constant_t::name"]
        [::std::mem::offset_of!(ecs_enum_constant_t, name) - 0usize];
    ["Offset of field: ecs_enum_constant_t::value"]
        [::std::mem::offset_of!(ecs_enum_constant_t, value) - 8usize];
    ["Offset of field: ecs_enum_constant_t::constant"]
        [::std::mem::offset_of!(ecs_enum_constant_t, constant) - 16usize];
};
#[doc = " Component added to enum type entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsEnum {
    #[doc = "< map<i32_t, ecs_enum_constant_t>"]
    pub constants: ecs_map_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsEnum"][::std::mem::size_of::<EcsEnum>() - 40usize];
    ["Alignment of EcsEnum"][::std::mem::align_of::<EcsEnum>() - 8usize];
    ["Offset of field: EcsEnum::constants"][::std::mem::offset_of!(EcsEnum, constants) - 0usize];
};
#[doc = " Type that describes an bitmask constant"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bitmask_constant_t {
    #[doc = " Must be set when used with ecs_bitmask_desc_t"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " May be set when used with ecs_bitmask_desc_t"]
    pub value: ecs_flags32_t,
    #[doc = " Should not be set by ecs_bitmask_desc_t"]
    pub constant: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_bitmask_constant_t"][::std::mem::size_of::<ecs_bitmask_constant_t>() - 24usize];
    ["Alignment of ecs_bitmask_constant_t"]
        [::std::mem::align_of::<ecs_bitmask_constant_t>() - 8usize];
    ["Offset of field: ecs_bitmask_constant_t::name"]
        [::std::mem::offset_of!(ecs_bitmask_constant_t, name) - 0usize];
    ["Offset of field: ecs_bitmask_constant_t::value"]
        [::std::mem::offset_of!(ecs_bitmask_constant_t, value) - 8usize];
    ["Offset of field: ecs_bitmask_constant_t::constant"]
        [::std::mem::offset_of!(ecs_bitmask_constant_t, constant) - 16usize];
};
#[doc = " Component added to bitmask type entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsBitmask {
    #[doc = "< map<u32_t, ecs_bitmask_constant_t>"]
    pub constants: ecs_map_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsBitmask"][::std::mem::size_of::<EcsBitmask>() - 40usize];
    ["Alignment of EcsBitmask"][::std::mem::align_of::<EcsBitmask>() - 8usize];
    ["Offset of field: EcsBitmask::constants"]
        [::std::mem::offset_of!(EcsBitmask, constants) - 0usize];
};
#[doc = " Component added to array type entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsArray {
    #[doc = "< Element type"]
    pub type_: ecs_entity_t,
    #[doc = "< Number of elements"]
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsArray"][::std::mem::size_of::<EcsArray>() - 16usize];
    ["Alignment of EcsArray"][::std::mem::align_of::<EcsArray>() - 8usize];
    ["Offset of field: EcsArray::type_"][::std::mem::offset_of!(EcsArray, type_) - 0usize];
    ["Offset of field: EcsArray::count"][::std::mem::offset_of!(EcsArray, count) - 8usize];
};
#[doc = " Component added to vector type entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsVector {
    #[doc = "< Element type"]
    pub type_: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsVector"][::std::mem::size_of::<EcsVector>() - 8usize];
    ["Alignment of EcsVector"][::std::mem::align_of::<EcsVector>() - 8usize];
    ["Offset of field: EcsVector::type_"][::std::mem::offset_of!(EcsVector, type_) - 0usize];
};
#[doc = " Serializer interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_serializer_t {
    pub value: ::std::option::Option<
        unsafe extern "C" fn(
            ser: *const ecs_serializer_t,
            type_: ecs_entity_t,
            value: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub member: ::std::option::Option<
        unsafe extern "C" fn(
            ser: *const ecs_serializer_t,
            member: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< The world."]
    pub world: *const ecs_world_t,
    #[doc = "< Serializer context."]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_serializer_t"][::std::mem::size_of::<ecs_serializer_t>() - 32usize];
    ["Alignment of ecs_serializer_t"][::std::mem::align_of::<ecs_serializer_t>() - 8usize];
    ["Offset of field: ecs_serializer_t::value"]
        [::std::mem::offset_of!(ecs_serializer_t, value) - 0usize];
    ["Offset of field: ecs_serializer_t::member"]
        [::std::mem::offset_of!(ecs_serializer_t, member) - 8usize];
    ["Offset of field: ecs_serializer_t::world"]
        [::std::mem::offset_of!(ecs_serializer_t, world) - 16usize];
    ["Offset of field: ecs_serializer_t::ctx"]
        [::std::mem::offset_of!(ecs_serializer_t, ctx) - 24usize];
};
#[doc = " Callback invoked serializing an opaque type."]
pub type ecs_meta_serialize_t = ::std::option::Option<
    unsafe extern "C" fn(
        ser: *const ecs_serializer_t,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Opaque type reflection data.\n An opaque type is a type with an unknown layout that can be mapped to a type\n known to the reflection framework. See the opaque type reflection examples."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsOpaque {
    #[doc = "< Type that describes the serialized output"]
    pub as_type: ecs_entity_t,
    #[doc = "< Serialize action"]
    pub serialize: ecs_meta_serialize_t,
    #[doc = " Assign bool value"]
    pub assign_bool:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: bool)>,
    #[doc = " Assign char value"]
    pub assign_char: ::std::option::Option<
        unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: ::std::os::raw::c_char),
    >,
    #[doc = " Assign int value"]
    pub assign_int:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: i64)>,
    #[doc = " Assign unsigned int value"]
    pub assign_uint:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: u64)>,
    #[doc = " Assign float value"]
    pub assign_float:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, value: f64)>,
    #[doc = " Assign string value"]
    pub assign_string: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            value: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Assign entity value"]
    pub assign_entity: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            world: *mut ecs_world_t,
            entity: ecs_entity_t,
        ),
    >,
    #[doc = " Assign (component) id value"]
    pub assign_id: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            world: *mut ecs_world_t,
            id: ecs_id_t,
        ),
    >,
    #[doc = " Assign null value"]
    pub assign_null: ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void)>,
    #[doc = " Clear collection elements"]
    pub clear: ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void)>,
    #[doc = " Ensure & get collection element"]
    pub ensure_element: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            elem: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Ensure & get element"]
    pub ensure_member: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut ::std::os::raw::c_void,
            member: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Return number of elements"]
    pub count:
        ::std::option::Option<unsafe extern "C" fn(dst: *const ::std::os::raw::c_void) -> usize>,
    #[doc = " Resize to number of elements"]
    pub resize:
        ::std::option::Option<unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, count: usize)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsOpaque"][::std::mem::size_of::<EcsOpaque>() - 128usize];
    ["Alignment of EcsOpaque"][::std::mem::align_of::<EcsOpaque>() - 8usize];
    ["Offset of field: EcsOpaque::as_type"][::std::mem::offset_of!(EcsOpaque, as_type) - 0usize];
    ["Offset of field: EcsOpaque::serialize"]
        [::std::mem::offset_of!(EcsOpaque, serialize) - 8usize];
    ["Offset of field: EcsOpaque::assign_bool"]
        [::std::mem::offset_of!(EcsOpaque, assign_bool) - 16usize];
    ["Offset of field: EcsOpaque::assign_char"]
        [::std::mem::offset_of!(EcsOpaque, assign_char) - 24usize];
    ["Offset of field: EcsOpaque::assign_int"]
        [::std::mem::offset_of!(EcsOpaque, assign_int) - 32usize];
    ["Offset of field: EcsOpaque::assign_uint"]
        [::std::mem::offset_of!(EcsOpaque, assign_uint) - 40usize];
    ["Offset of field: EcsOpaque::assign_float"]
        [::std::mem::offset_of!(EcsOpaque, assign_float) - 48usize];
    ["Offset of field: EcsOpaque::assign_string"]
        [::std::mem::offset_of!(EcsOpaque, assign_string) - 56usize];
    ["Offset of field: EcsOpaque::assign_entity"]
        [::std::mem::offset_of!(EcsOpaque, assign_entity) - 64usize];
    ["Offset of field: EcsOpaque::assign_id"]
        [::std::mem::offset_of!(EcsOpaque, assign_id) - 72usize];
    ["Offset of field: EcsOpaque::assign_null"]
        [::std::mem::offset_of!(EcsOpaque, assign_null) - 80usize];
    ["Offset of field: EcsOpaque::clear"][::std::mem::offset_of!(EcsOpaque, clear) - 88usize];
    ["Offset of field: EcsOpaque::ensure_element"]
        [::std::mem::offset_of!(EcsOpaque, ensure_element) - 96usize];
    ["Offset of field: EcsOpaque::ensure_member"]
        [::std::mem::offset_of!(EcsOpaque, ensure_member) - 104usize];
    ["Offset of field: EcsOpaque::count"][::std::mem::offset_of!(EcsOpaque, count) - 112usize];
    ["Offset of field: EcsOpaque::resize"][::std::mem::offset_of!(EcsOpaque, resize) - 120usize];
};
#[doc = " Helper type to describe translation between two units. Note that this\n is not intended as a generic approach to unit conversions (e.g. from celsius\n to fahrenheit) but to translate between units that derive from the same base\n (e.g. meters to kilometers).\n\n Note that power is applied to the factor. When describing a translation of\n 1000, either use {factor = 1000, power = 1} or {factor = 1, power = 3}."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_unit_translation_t {
    #[doc = "< Factor to apply (e.g. \"1000\", \"1000000\", \"1024\")"]
    pub factor: i32,
    #[doc = "< Power to apply to factor (e.g. \"1\", \"3\", \"-9\")"]
    pub power: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_unit_translation_t"][::std::mem::size_of::<ecs_unit_translation_t>() - 8usize];
    ["Alignment of ecs_unit_translation_t"]
        [::std::mem::align_of::<ecs_unit_translation_t>() - 4usize];
    ["Offset of field: ecs_unit_translation_t::factor"]
        [::std::mem::offset_of!(ecs_unit_translation_t, factor) - 0usize];
    ["Offset of field: ecs_unit_translation_t::power"]
        [::std::mem::offset_of!(ecs_unit_translation_t, power) - 4usize];
};
#[doc = " Component that stores unit data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsUnit {
    #[doc = "< Unit symbol."]
    pub symbol: *mut ::std::os::raw::c_char,
    #[doc = "< Order of magnitude prefix relative to derived"]
    pub prefix: ecs_entity_t,
    #[doc = "< Base unit (e.g. \"meters\")"]
    pub base: ecs_entity_t,
    #[doc = "< Over unit (e.g. \"per second\")"]
    pub over: ecs_entity_t,
    #[doc = "< Translation for derived unit"]
    pub translation: ecs_unit_translation_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsUnit"][::std::mem::size_of::<EcsUnit>() - 40usize];
    ["Alignment of EcsUnit"][::std::mem::align_of::<EcsUnit>() - 8usize];
    ["Offset of field: EcsUnit::symbol"][::std::mem::offset_of!(EcsUnit, symbol) - 0usize];
    ["Offset of field: EcsUnit::prefix"][::std::mem::offset_of!(EcsUnit, prefix) - 8usize];
    ["Offset of field: EcsUnit::base"][::std::mem::offset_of!(EcsUnit, base) - 16usize];
    ["Offset of field: EcsUnit::over"][::std::mem::offset_of!(EcsUnit, over) - 24usize];
    ["Offset of field: EcsUnit::translation"]
        [::std::mem::offset_of!(EcsUnit, translation) - 32usize];
};
#[doc = " Component that stores unit prefix data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsUnitPrefix {
    #[doc = "< Symbol of prefix (e.g. \"K\", \"M\", \"Ki\")"]
    pub symbol: *mut ::std::os::raw::c_char,
    #[doc = "< Translation of prefix"]
    pub translation: ecs_unit_translation_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsUnitPrefix"][::std::mem::size_of::<EcsUnitPrefix>() - 16usize];
    ["Alignment of EcsUnitPrefix"][::std::mem::align_of::<EcsUnitPrefix>() - 8usize];
    ["Offset of field: EcsUnitPrefix::symbol"]
        [::std::mem::offset_of!(EcsUnitPrefix, symbol) - 0usize];
    ["Offset of field: EcsUnitPrefix::translation"]
        [::std::mem::offset_of!(EcsUnitPrefix, translation) - 8usize];
};
pub const ecs_meta_type_op_kind_t_EcsOpArray: ecs_meta_type_op_kind_t = 0;
pub const ecs_meta_type_op_kind_t_EcsOpVector: ecs_meta_type_op_kind_t = 1;
pub const ecs_meta_type_op_kind_t_EcsOpOpaque: ecs_meta_type_op_kind_t = 2;
pub const ecs_meta_type_op_kind_t_EcsOpPush: ecs_meta_type_op_kind_t = 3;
pub const ecs_meta_type_op_kind_t_EcsOpPop: ecs_meta_type_op_kind_t = 4;
#[doc = "< Marks last constant that can open/close a scope"]
pub const ecs_meta_type_op_kind_t_EcsOpScope: ecs_meta_type_op_kind_t = 5;
pub const ecs_meta_type_op_kind_t_EcsOpEnum: ecs_meta_type_op_kind_t = 6;
pub const ecs_meta_type_op_kind_t_EcsOpBitmask: ecs_meta_type_op_kind_t = 7;
#[doc = "< Marks first constant that's a primitive"]
pub const ecs_meta_type_op_kind_t_EcsOpPrimitive: ecs_meta_type_op_kind_t = 8;
pub const ecs_meta_type_op_kind_t_EcsOpBool: ecs_meta_type_op_kind_t = 9;
pub const ecs_meta_type_op_kind_t_EcsOpChar: ecs_meta_type_op_kind_t = 10;
pub const ecs_meta_type_op_kind_t_EcsOpByte: ecs_meta_type_op_kind_t = 11;
pub const ecs_meta_type_op_kind_t_EcsOpU8: ecs_meta_type_op_kind_t = 12;
pub const ecs_meta_type_op_kind_t_EcsOpU16: ecs_meta_type_op_kind_t = 13;
pub const ecs_meta_type_op_kind_t_EcsOpU32: ecs_meta_type_op_kind_t = 14;
pub const ecs_meta_type_op_kind_t_EcsOpU64: ecs_meta_type_op_kind_t = 15;
pub const ecs_meta_type_op_kind_t_EcsOpI8: ecs_meta_type_op_kind_t = 16;
pub const ecs_meta_type_op_kind_t_EcsOpI16: ecs_meta_type_op_kind_t = 17;
pub const ecs_meta_type_op_kind_t_EcsOpI32: ecs_meta_type_op_kind_t = 18;
pub const ecs_meta_type_op_kind_t_EcsOpI64: ecs_meta_type_op_kind_t = 19;
pub const ecs_meta_type_op_kind_t_EcsOpF32: ecs_meta_type_op_kind_t = 20;
pub const ecs_meta_type_op_kind_t_EcsOpF64: ecs_meta_type_op_kind_t = 21;
pub const ecs_meta_type_op_kind_t_EcsOpUPtr: ecs_meta_type_op_kind_t = 22;
pub const ecs_meta_type_op_kind_t_EcsOpIPtr: ecs_meta_type_op_kind_t = 23;
pub const ecs_meta_type_op_kind_t_EcsOpString: ecs_meta_type_op_kind_t = 24;
pub const ecs_meta_type_op_kind_t_EcsOpEntity: ecs_meta_type_op_kind_t = 25;
pub const ecs_meta_type_op_kind_t_EcsOpId: ecs_meta_type_op_kind_t = 26;
pub const ecs_meta_type_op_kind_t_EcsMetaTypeOpKindLast: ecs_meta_type_op_kind_t = 26;
#[doc = " Serializer instruction opcodes.\n The meta type serializer works by generating a flattened array with\n instructions that tells a serializer what kind of fields can be found in a\n type at which offsets."]
pub type ecs_meta_type_op_kind_t = ::std::os::raw::c_int;
#[doc = " Meta type serializer instruction data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_meta_type_op_t {
    #[doc = "< Instruction opcode."]
    pub kind: ecs_meta_type_op_kind_t,
    #[doc = "< Offset of current field"]
    pub offset: ecs_size_t,
    #[doc = "< Number of elements (for inline arrays)."]
    pub count: i32,
    #[doc = "< Name of value (only used for struct members)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Number of operations until next field or end"]
    pub op_count: i32,
    #[doc = "< Size of type of operation"]
    pub size: ecs_size_t,
    #[doc = "< Type entity"]
    pub type_: ecs_entity_t,
    #[doc = "< Index of member in struct"]
    pub member_index: i32,
    #[doc = "< string -> member index (structs only)"]
    pub members: *mut ecs_hashmap_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_meta_type_op_t"][::std::mem::size_of::<ecs_meta_type_op_t>() - 56usize];
    ["Alignment of ecs_meta_type_op_t"][::std::mem::align_of::<ecs_meta_type_op_t>() - 8usize];
    ["Offset of field: ecs_meta_type_op_t::kind"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, kind) - 0usize];
    ["Offset of field: ecs_meta_type_op_t::offset"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, offset) - 4usize];
    ["Offset of field: ecs_meta_type_op_t::count"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, count) - 8usize];
    ["Offset of field: ecs_meta_type_op_t::name"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, name) - 16usize];
    ["Offset of field: ecs_meta_type_op_t::op_count"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, op_count) - 24usize];
    ["Offset of field: ecs_meta_type_op_t::size"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, size) - 28usize];
    ["Offset of field: ecs_meta_type_op_t::type_"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, type_) - 32usize];
    ["Offset of field: ecs_meta_type_op_t::member_index"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, member_index) - 40usize];
    ["Offset of field: ecs_meta_type_op_t::members"]
        [::std::mem::offset_of!(ecs_meta_type_op_t, members) - 48usize];
};
#[doc = " Component that stores the type serializer.\n Added to all types with reflection data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsTypeSerializer {
    #[doc = "< vector<ecs_meta_type_op_t>"]
    pub ops: ecs_vec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsTypeSerializer"][::std::mem::size_of::<EcsTypeSerializer>() - 16usize];
    ["Alignment of EcsTypeSerializer"][::std::mem::align_of::<EcsTypeSerializer>() - 8usize];
    ["Offset of field: EcsTypeSerializer::ops"]
        [::std::mem::offset_of!(EcsTypeSerializer, ops) - 0usize];
};
#[doc = " Type with information about currently serialized scope."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_meta_scope_t {
    #[doc = "< The type being iterated"]
    pub type_: ecs_entity_t,
    #[doc = "< The type operations (see ecs_meta_type_op_t)"]
    pub ops: *mut ecs_meta_type_op_t,
    #[doc = "< Number of operations in ops array to process"]
    pub op_count: i32,
    #[doc = "< Current operation"]
    pub op_cur: i32,
    #[doc = "< Current element (for collections)"]
    pub elem_cur: i32,
    #[doc = "< Depth to restore, in case dotmember was used"]
    pub prev_depth: i32,
    #[doc = "< Pointer to the value being iterated"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to component, in case size/alignment is needed"]
    pub comp: *const EcsComponent,
    #[doc = "< Opaque type interface"]
    pub opaque: *const EcsOpaque,
    #[doc = "< Current vector, in case a vector is iterated"]
    pub vector: *mut ecs_vec_t,
    #[doc = "< string -> member index"]
    pub members: *mut ecs_hashmap_t,
    #[doc = "< Is the scope iterating elements?"]
    pub is_collection: bool,
    #[doc = "< Is the scope iterating an inline array?"]
    pub is_inline_array: bool,
    #[doc = "< Was scope populated (for collections)"]
    pub is_empty_scope: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_meta_scope_t"][::std::mem::size_of::<ecs_meta_scope_t>() - 80usize];
    ["Alignment of ecs_meta_scope_t"][::std::mem::align_of::<ecs_meta_scope_t>() - 8usize];
    ["Offset of field: ecs_meta_scope_t::type_"]
        [::std::mem::offset_of!(ecs_meta_scope_t, type_) - 0usize];
    ["Offset of field: ecs_meta_scope_t::ops"]
        [::std::mem::offset_of!(ecs_meta_scope_t, ops) - 8usize];
    ["Offset of field: ecs_meta_scope_t::op_count"]
        [::std::mem::offset_of!(ecs_meta_scope_t, op_count) - 16usize];
    ["Offset of field: ecs_meta_scope_t::op_cur"]
        [::std::mem::offset_of!(ecs_meta_scope_t, op_cur) - 20usize];
    ["Offset of field: ecs_meta_scope_t::elem_cur"]
        [::std::mem::offset_of!(ecs_meta_scope_t, elem_cur) - 24usize];
    ["Offset of field: ecs_meta_scope_t::prev_depth"]
        [::std::mem::offset_of!(ecs_meta_scope_t, prev_depth) - 28usize];
    ["Offset of field: ecs_meta_scope_t::ptr"]
        [::std::mem::offset_of!(ecs_meta_scope_t, ptr) - 32usize];
    ["Offset of field: ecs_meta_scope_t::comp"]
        [::std::mem::offset_of!(ecs_meta_scope_t, comp) - 40usize];
    ["Offset of field: ecs_meta_scope_t::opaque"]
        [::std::mem::offset_of!(ecs_meta_scope_t, opaque) - 48usize];
    ["Offset of field: ecs_meta_scope_t::vector"]
        [::std::mem::offset_of!(ecs_meta_scope_t, vector) - 56usize];
    ["Offset of field: ecs_meta_scope_t::members"]
        [::std::mem::offset_of!(ecs_meta_scope_t, members) - 64usize];
    ["Offset of field: ecs_meta_scope_t::is_collection"]
        [::std::mem::offset_of!(ecs_meta_scope_t, is_collection) - 72usize];
    ["Offset of field: ecs_meta_scope_t::is_inline_array"]
        [::std::mem::offset_of!(ecs_meta_scope_t, is_inline_array) - 73usize];
    ["Offset of field: ecs_meta_scope_t::is_empty_scope"]
        [::std::mem::offset_of!(ecs_meta_scope_t, is_empty_scope) - 74usize];
};
#[doc = " Type that enables iterating/populating a value using reflection data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_meta_cursor_t {
    #[doc = "< The world."]
    pub world: *const ecs_world_t,
    #[doc = "< Cursor scope stack."]
    pub scope: [ecs_meta_scope_t; 32usize],
    #[doc = "< Current scope depth."]
    pub depth: i32,
    #[doc = "< Does the cursor point to a valid field."]
    pub valid: bool,
    #[doc = "< If in root scope, this allows for a push for primitive types"]
    pub is_primitive_scope: bool,
    #[doc = " Custom entity lookup action for overriding default ecs_lookup"]
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ecs_world_t,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ecs_entity_t,
    >,
    #[doc = "< Context for lookup_action"]
    pub lookup_ctx: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_meta_cursor_t"][::std::mem::size_of::<ecs_meta_cursor_t>() - 2592usize];
    ["Alignment of ecs_meta_cursor_t"][::std::mem::align_of::<ecs_meta_cursor_t>() - 8usize];
    ["Offset of field: ecs_meta_cursor_t::world"]
        [::std::mem::offset_of!(ecs_meta_cursor_t, world) - 0usize];
    ["Offset of field: ecs_meta_cursor_t::scope"]
        [::std::mem::offset_of!(ecs_meta_cursor_t, scope) - 8usize];
    ["Offset of field: ecs_meta_cursor_t::depth"]
        [::std::mem::offset_of!(ecs_meta_cursor_t, depth) - 2568usize];
    ["Offset of field: ecs_meta_cursor_t::valid"]
        [::std::mem::offset_of!(ecs_meta_cursor_t, valid) - 2572usize];
    ["Offset of field: ecs_meta_cursor_t::is_primitive_scope"]
        [::std::mem::offset_of!(ecs_meta_cursor_t, is_primitive_scope) - 2573usize];
    ["Offset of field: ecs_meta_cursor_t::lookup_action"]
        [::std::mem::offset_of!(ecs_meta_cursor_t, lookup_action) - 2576usize];
    ["Offset of field: ecs_meta_cursor_t::lookup_ctx"]
        [::std::mem::offset_of!(ecs_meta_cursor_t, lookup_ctx) - 2584usize];
};
extern "C" {
    #[doc = " Create meta cursor.\n A meta cursor allows for walking over, reading and writing a value without\n having to know its type at compile time.\n\n When a value is assigned through the cursor API, it will get converted to\n the actual value of the underlying type. This allows the underlying type to\n change without having to update the serialized data. For example, an integer\n field can be set by a string, a floating point can be set as integer etc.\n\n @param world The world.\n @param type The type of the value.\n @param ptr Pointer to the value.\n @return A meta cursor for the value."]
    pub fn ecs_meta_cursor(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ecs_meta_cursor_t;
}
extern "C" {
    #[doc = " Get pointer to current field.\n\n @param cursor The cursor.\n @return A pointer to the current field."]
    pub fn ecs_meta_get_ptr(cursor: *mut ecs_meta_cursor_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Move cursor to next field.\n\n @param cursor The cursor.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_next(cursor: *mut ecs_meta_cursor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move cursor to a field.\n\n @param cursor The cursor.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_elem(cursor: *mut ecs_meta_cursor_t, elem: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move cursor to member.\n\n @param cursor The cursor.\n @param name The name of the member.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_member(
        cursor: *mut ecs_meta_cursor_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move cursor to member.\n Same as ecs_meta_member(), but with support for \"foo.bar\" syntax.\n\n @param cursor The cursor.\n @param name The name of the member.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_dotmember(
        cursor: *mut ecs_meta_cursor_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Push a scope (required/only valid for structs & collections).\n\n @param cursor The cursor.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_push(cursor: *mut ecs_meta_cursor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pop a struct or collection scope (must follow a push).\n\n @param cursor The cursor.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_pop(cursor: *mut ecs_meta_cursor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the current scope a collection?.\n\n @param cursor The cursor.\n @return True if current scope is a collection, false if not."]
    pub fn ecs_meta_is_collection(cursor: *const ecs_meta_cursor_t) -> bool;
}
extern "C" {
    #[doc = " Get type of current field.\n\n @param cursor The cursor.\n @return The type of the current field."]
    pub fn ecs_meta_get_type(cursor: *const ecs_meta_cursor_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get unit of current field.\n\n @param cursor The cursor.\n @return The unit of the current field."]
    pub fn ecs_meta_get_unit(cursor: *const ecs_meta_cursor_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get member name of current field.\n\n @param cursor The cursor.\n @return The member name of the current field."]
    pub fn ecs_meta_get_member(cursor: *const ecs_meta_cursor_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get member entity of current field.\n\n @param cursor The cursor.\n @return The member entity of the current field."]
    pub fn ecs_meta_get_member_id(cursor: *const ecs_meta_cursor_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set field with boolean value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_bool(cursor: *mut ecs_meta_cursor_t, value: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with char value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_char(
        cursor: *mut ecs_meta_cursor_t,
        value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with int value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_int(cursor: *mut ecs_meta_cursor_t, value: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with uint value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_uint(cursor: *mut ecs_meta_cursor_t, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with float value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_float(cursor: *mut ecs_meta_cursor_t, value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with string value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_string(
        cursor: *mut ecs_meta_cursor_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with string literal value (has enclosing \"\").\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_string_literal(
        cursor: *mut ecs_meta_cursor_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with entity value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_entity(
        cursor: *mut ecs_meta_cursor_t,
        value: ecs_entity_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with (component) id value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_id(
        cursor: *mut ecs_meta_cursor_t,
        value: ecs_id_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with null value.\n\n @param cursor The cursor.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_null(cursor: *mut ecs_meta_cursor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set field with dynamic value.\n\n @param cursor The cursor.\n @param value The value to set.\n @return Zero if success, non-zero if failed."]
    pub fn ecs_meta_set_value(
        cursor: *mut ecs_meta_cursor_t,
        value: *const ecs_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get field value as boolean.\n\n @param cursor The cursor.\n @return The value of the current field."]
    pub fn ecs_meta_get_bool(cursor: *const ecs_meta_cursor_t) -> bool;
}
extern "C" {
    #[doc = " Get field value as char.\n\n @param cursor The cursor.\n @return The value of the current field."]
    pub fn ecs_meta_get_char(cursor: *const ecs_meta_cursor_t) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get field value as signed integer.\n\n @param cursor The cursor.\n @return The value of the current field."]
    pub fn ecs_meta_get_int(cursor: *const ecs_meta_cursor_t) -> i64;
}
extern "C" {
    #[doc = " Get field value as unsigned integer.\n\n @param cursor The cursor.\n @return The value of the current field."]
    pub fn ecs_meta_get_uint(cursor: *const ecs_meta_cursor_t) -> u64;
}
extern "C" {
    #[doc = " Get field value as float.\n\n @param cursor The cursor.\n @return The value of the current field."]
    pub fn ecs_meta_get_float(cursor: *const ecs_meta_cursor_t) -> f64;
}
extern "C" {
    #[doc = " Get field value as string.\n This operation does not perform conversions. If the field is not a string,\n this operation will fail.\n\n @param cursor The cursor.\n @return The value of the current field."]
    pub fn ecs_meta_get_string(cursor: *const ecs_meta_cursor_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get field value as entity.\n This operation does not perform conversions.\n\n @param cursor The cursor.\n @return The value of the current field."]
    pub fn ecs_meta_get_entity(cursor: *const ecs_meta_cursor_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get field value as (component) id.\n This operation can convert from an entity.\n\n @param cursor The cursor.\n @return The value of the current field."]
    pub fn ecs_meta_get_id(cursor: *const ecs_meta_cursor_t) -> ecs_id_t;
}
extern "C" {
    #[doc = " Convert pointer of primitive kind to float.\n\n @param type_kind The primitive type kind of the value.\n @param ptr Pointer to a value of a primitive type.\n @return The value in floating point format."]
    pub fn ecs_meta_ptr_to_float(
        type_kind: ecs_primitive_kind_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> f64;
}
#[doc = " Used with ecs_primitive_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_primitive_desc_t {
    #[doc = "< Existing entity to use for type (optional)."]
    pub entity: ecs_entity_t,
    #[doc = "< Primitive type kind."]
    pub kind: ecs_primitive_kind_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_primitive_desc_t"][::std::mem::size_of::<ecs_primitive_desc_t>() - 16usize];
    ["Alignment of ecs_primitive_desc_t"][::std::mem::align_of::<ecs_primitive_desc_t>() - 8usize];
    ["Offset of field: ecs_primitive_desc_t::entity"]
        [::std::mem::offset_of!(ecs_primitive_desc_t, entity) - 0usize];
    ["Offset of field: ecs_primitive_desc_t::kind"]
        [::std::mem::offset_of!(ecs_primitive_desc_t, kind) - 8usize];
};
extern "C" {
    #[doc = " Create a new primitive type.\n\n @param world The world.\n @param desc The type descriptor.\n @return The new type, 0 if failed."]
    pub fn ecs_primitive_init(
        world: *mut ecs_world_t,
        desc: *const ecs_primitive_desc_t,
    ) -> ecs_entity_t;
}
#[doc = " Used with ecs_enum_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_enum_desc_t {
    #[doc = "< Existing entity to use for type (optional)."]
    pub entity: ecs_entity_t,
    #[doc = "< Enum constants."]
    pub constants: [ecs_enum_constant_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_enum_desc_t"][::std::mem::size_of::<ecs_enum_desc_t>() - 776usize];
    ["Alignment of ecs_enum_desc_t"][::std::mem::align_of::<ecs_enum_desc_t>() - 8usize];
    ["Offset of field: ecs_enum_desc_t::entity"]
        [::std::mem::offset_of!(ecs_enum_desc_t, entity) - 0usize];
    ["Offset of field: ecs_enum_desc_t::constants"]
        [::std::mem::offset_of!(ecs_enum_desc_t, constants) - 8usize];
};
extern "C" {
    #[doc = " Create a new enum type.\n\n @param world The world.\n @param desc The type descriptor.\n @return The new type, 0 if failed."]
    pub fn ecs_enum_init(world: *mut ecs_world_t, desc: *const ecs_enum_desc_t) -> ecs_entity_t;
}
#[doc = " Used with ecs_bitmask_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bitmask_desc_t {
    #[doc = "< Existing entity to use for type (optional)."]
    pub entity: ecs_entity_t,
    #[doc = "< Bitmask constants."]
    pub constants: [ecs_bitmask_constant_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_bitmask_desc_t"][::std::mem::size_of::<ecs_bitmask_desc_t>() - 776usize];
    ["Alignment of ecs_bitmask_desc_t"][::std::mem::align_of::<ecs_bitmask_desc_t>() - 8usize];
    ["Offset of field: ecs_bitmask_desc_t::entity"]
        [::std::mem::offset_of!(ecs_bitmask_desc_t, entity) - 0usize];
    ["Offset of field: ecs_bitmask_desc_t::constants"]
        [::std::mem::offset_of!(ecs_bitmask_desc_t, constants) - 8usize];
};
extern "C" {
    #[doc = " Create a new bitmask type.\n\n @param world The world.\n @param desc The type descriptor.\n @return The new type, 0 if failed."]
    pub fn ecs_bitmask_init(
        world: *mut ecs_world_t,
        desc: *const ecs_bitmask_desc_t,
    ) -> ecs_entity_t;
}
#[doc = " Used with ecs_array_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_array_desc_t {
    #[doc = "< Existing entity to use for type (optional)."]
    pub entity: ecs_entity_t,
    #[doc = "< Element type."]
    pub type_: ecs_entity_t,
    #[doc = "< Number of elements."]
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_array_desc_t"][::std::mem::size_of::<ecs_array_desc_t>() - 24usize];
    ["Alignment of ecs_array_desc_t"][::std::mem::align_of::<ecs_array_desc_t>() - 8usize];
    ["Offset of field: ecs_array_desc_t::entity"]
        [::std::mem::offset_of!(ecs_array_desc_t, entity) - 0usize];
    ["Offset of field: ecs_array_desc_t::type_"]
        [::std::mem::offset_of!(ecs_array_desc_t, type_) - 8usize];
    ["Offset of field: ecs_array_desc_t::count"]
        [::std::mem::offset_of!(ecs_array_desc_t, count) - 16usize];
};
extern "C" {
    #[doc = " Create a new array type.\n\n @param world The world.\n @param desc The type descriptor.\n @return The new type, 0 if failed."]
    pub fn ecs_array_init(world: *mut ecs_world_t, desc: *const ecs_array_desc_t) -> ecs_entity_t;
}
#[doc = " Used with ecs_vector_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_vector_desc_t {
    #[doc = "< Existing entity to use for type (optional)."]
    pub entity: ecs_entity_t,
    #[doc = "< Element type."]
    pub type_: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_vector_desc_t"][::std::mem::size_of::<ecs_vector_desc_t>() - 16usize];
    ["Alignment of ecs_vector_desc_t"][::std::mem::align_of::<ecs_vector_desc_t>() - 8usize];
    ["Offset of field: ecs_vector_desc_t::entity"]
        [::std::mem::offset_of!(ecs_vector_desc_t, entity) - 0usize];
    ["Offset of field: ecs_vector_desc_t::type_"]
        [::std::mem::offset_of!(ecs_vector_desc_t, type_) - 8usize];
};
extern "C" {
    #[doc = " Create a new vector type.\n\n @param world The world.\n @param desc The type descriptor.\n @return The new type, 0 if failed."]
    pub fn ecs_vector_init(world: *mut ecs_world_t, desc: *const ecs_vector_desc_t)
        -> ecs_entity_t;
}
#[doc = " Used with ecs_struct_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_struct_desc_t {
    #[doc = "< Existing entity to use for type (optional)."]
    pub entity: ecs_entity_t,
    #[doc = "< Struct members."]
    pub members: [ecs_member_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_struct_desc_t"][::std::mem::size_of::<ecs_struct_desc_t>() - 3336usize];
    ["Alignment of ecs_struct_desc_t"][::std::mem::align_of::<ecs_struct_desc_t>() - 8usize];
    ["Offset of field: ecs_struct_desc_t::entity"]
        [::std::mem::offset_of!(ecs_struct_desc_t, entity) - 0usize];
    ["Offset of field: ecs_struct_desc_t::members"]
        [::std::mem::offset_of!(ecs_struct_desc_t, members) - 8usize];
};
extern "C" {
    #[doc = " Create a new struct type.\n\n @param world The world.\n @param desc The type descriptor.\n @return The new type, 0 if failed."]
    pub fn ecs_struct_init(world: *mut ecs_world_t, desc: *const ecs_struct_desc_t)
        -> ecs_entity_t;
}
#[doc = " Used with ecs_opaque_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_opaque_desc_t {
    #[doc = "< Existing entity to use for type (optional)."]
    pub entity: ecs_entity_t,
    #[doc = "< Type that the opaque type maps to."]
    pub type_: EcsOpaque,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_opaque_desc_t"][::std::mem::size_of::<ecs_opaque_desc_t>() - 136usize];
    ["Alignment of ecs_opaque_desc_t"][::std::mem::align_of::<ecs_opaque_desc_t>() - 8usize];
    ["Offset of field: ecs_opaque_desc_t::entity"]
        [::std::mem::offset_of!(ecs_opaque_desc_t, entity) - 0usize];
    ["Offset of field: ecs_opaque_desc_t::type_"]
        [::std::mem::offset_of!(ecs_opaque_desc_t, type_) - 8usize];
};
extern "C" {
    #[doc = " Create a new opaque type.\n Opaque types are types of which the layout doesn't match what can be modelled\n with the primitives of the meta framework, but which have a structure\n that can be described with meta primitives. Typical examples are STL types\n such as std::string or std::vector, types with a nontrivial layout, and types\n that only expose getter/setter methods.\n\n An opaque type is a combination of a serialization function, and a handle to\n a meta type which describes the structure of the serialized output. For\n example, an opaque type for std::string would have a serializer function that\n accesses .c_str(), and with type ecs_string_t.\n\n The serializer callback accepts a serializer object and a pointer to the\n value of the opaque type to be serialized. The serializer has two methods:\n\n - value, which serializes a value (such as .c_str())\n - member, which specifies a member to be serialized (in the case of a struct)\n\n @param world The world.\n @param desc The type descriptor.\n @return The new type, 0 if failed."]
    pub fn ecs_opaque_init(world: *mut ecs_world_t, desc: *const ecs_opaque_desc_t)
        -> ecs_entity_t;
}
#[doc = " Used with ecs_unit_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_unit_desc_t {
    #[doc = " Existing entity to associate with unit (optional)."]
    pub entity: ecs_entity_t,
    #[doc = " Unit symbol, e.g. \"m\", \"%\", \"g\". (optional)."]
    pub symbol: *const ::std::os::raw::c_char,
    #[doc = " Unit quantity, e.g. distance, percentage, weight. (optional)."]
    pub quantity: ecs_entity_t,
    #[doc = " Base unit, e.g. \"meters\" (optional)."]
    pub base: ecs_entity_t,
    #[doc = " Over unit, e.g. \"per second\" (optional)."]
    pub over: ecs_entity_t,
    #[doc = " Translation to apply to derived unit (optional)."]
    pub translation: ecs_unit_translation_t,
    #[doc = " Prefix indicating order of magnitude relative to the derived unit. If set\n together with \"translation\", the values must match. If translation is not\n set, setting prefix will auto-populate it.\n Additionally, setting the prefix will enforce that the symbol (if set)\n is consistent with the prefix symbol + symbol of the derived unit. If the\n symbol is not set, it will be auto populated."]
    pub prefix: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_unit_desc_t"][::std::mem::size_of::<ecs_unit_desc_t>() - 56usize];
    ["Alignment of ecs_unit_desc_t"][::std::mem::align_of::<ecs_unit_desc_t>() - 8usize];
    ["Offset of field: ecs_unit_desc_t::entity"]
        [::std::mem::offset_of!(ecs_unit_desc_t, entity) - 0usize];
    ["Offset of field: ecs_unit_desc_t::symbol"]
        [::std::mem::offset_of!(ecs_unit_desc_t, symbol) - 8usize];
    ["Offset of field: ecs_unit_desc_t::quantity"]
        [::std::mem::offset_of!(ecs_unit_desc_t, quantity) - 16usize];
    ["Offset of field: ecs_unit_desc_t::base"]
        [::std::mem::offset_of!(ecs_unit_desc_t, base) - 24usize];
    ["Offset of field: ecs_unit_desc_t::over"]
        [::std::mem::offset_of!(ecs_unit_desc_t, over) - 32usize];
    ["Offset of field: ecs_unit_desc_t::translation"]
        [::std::mem::offset_of!(ecs_unit_desc_t, translation) - 40usize];
    ["Offset of field: ecs_unit_desc_t::prefix"]
        [::std::mem::offset_of!(ecs_unit_desc_t, prefix) - 48usize];
};
extern "C" {
    #[doc = " Create a new unit.\n\n @param world The world.\n @param desc The unit descriptor.\n @return The new unit, 0 if failed."]
    pub fn ecs_unit_init(world: *mut ecs_world_t, desc: *const ecs_unit_desc_t) -> ecs_entity_t;
}
#[doc = " Used with ecs_unit_prefix_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_unit_prefix_desc_t {
    #[doc = " Existing entity to associate with unit prefix (optional)."]
    pub entity: ecs_entity_t,
    #[doc = " Unit symbol, e.g. \"m\", \"%\", \"g\". (optional)."]
    pub symbol: *const ::std::os::raw::c_char,
    #[doc = " Translation to apply to derived unit (optional)."]
    pub translation: ecs_unit_translation_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_unit_prefix_desc_t"][::std::mem::size_of::<ecs_unit_prefix_desc_t>() - 24usize];
    ["Alignment of ecs_unit_prefix_desc_t"]
        [::std::mem::align_of::<ecs_unit_prefix_desc_t>() - 8usize];
    ["Offset of field: ecs_unit_prefix_desc_t::entity"]
        [::std::mem::offset_of!(ecs_unit_prefix_desc_t, entity) - 0usize];
    ["Offset of field: ecs_unit_prefix_desc_t::symbol"]
        [::std::mem::offset_of!(ecs_unit_prefix_desc_t, symbol) - 8usize];
    ["Offset of field: ecs_unit_prefix_desc_t::translation"]
        [::std::mem::offset_of!(ecs_unit_prefix_desc_t, translation) - 16usize];
};
extern "C" {
    #[doc = " Create a new unit prefix.\n\n @param world The world.\n @param desc The type descriptor.\n @return The new unit prefix, 0 if failed."]
    pub fn ecs_unit_prefix_init(
        world: *mut ecs_world_t,
        desc: *const ecs_unit_prefix_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Create a new quantity.\n\n @param world The world.\n @param desc The quantity descriptor.\n @return The new quantity, 0 if failed."]
    pub fn ecs_quantity_init(
        world: *mut ecs_world_t,
        desc: *const ecs_entity_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Meta module import function.\n Usage:\n @code\n ECS_IMPORT(world, FlecsMeta)\n @endcode\n\n @param world The world."]
    pub fn FlecsMetaImport(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Populate meta information from type descriptor."]
    pub fn ecs_meta_from_desc(
        world: *mut ecs_world_t,
        component: ecs_entity_t,
        kind: ecs_type_kind_t,
        desc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecs_set_os_api_impl();
}
extern "C" {
    #[doc = " Import a module.\n This operation will load a modules and store the public module handles in the\n handles_out out parameter. The module name will be used to verify if the\n module was already loaded, in which case it won't be reimported. The name\n will be translated from PascalCase to an entity path (pascal.case) before the\n lookup occurs.\n\n Module contents will be stored as children of the module entity. This\n prevents modules from accidentally defining conflicting identifiers. This is\n enforced by setting the scope before and after loading the module to the\n module entity id.\n\n A more convenient way to import a module is by using the ECS_IMPORT macro.\n\n @param world The world.\n @param module The module import function.\n @param module_name The name of the module.\n @return The module entity."]
    pub fn ecs_import(
        world: *mut ecs_world_t,
        module: ecs_module_action_t,
        module_name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Same as ecs_import(), but with name to scope conversion.\n PascalCase names are automatically converted to scoped names.\n\n @param world The world.\n @param module The module import function.\n @param module_name_c The name of the module.\n @return The module entity."]
    pub fn ecs_import_c(
        world: *mut ecs_world_t,
        module: ecs_module_action_t,
        module_name_c: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Import a module from a library.\n Similar to ecs_import(), except that this operation will attempt to load the\n module from a dynamic library.\n\n A library may contain multiple modules, which is why both a library name and\n a module name need to be provided. If only a library name is provided, the\n library name will be reused for the module name.\n\n The library will be looked up using a canonical name, which is in the same\n form as a module, like `flecs.components.transform`. To transform this\n identifier to a platform specific library name, the operation relies on the\n module_to_dl callback of the os_api which the application has to override if\n the default does not yield the correct library name.\n\n @param world The world.\n @param library_name The name of the library to load.\n @param module_name The name of the module to load."]
    pub fn ecs_import_from_library(
        world: *mut ecs_world_t,
        library_name: *const ::std::os::raw::c_char,
        module_name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Register a new module."]
    pub fn ecs_module_init(
        world: *mut ecs_world_t,
        c_name: *const ::std::os::raw::c_char,
        desc: *const ecs_component_desc_t,
    ) -> ecs_entity_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[doc = "< Table cache of element. Of type ecs_id_record_t* for component index elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_cache_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_id_record_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_var_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_op_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_op_ctx_t {
    pub _address: u8,
}
